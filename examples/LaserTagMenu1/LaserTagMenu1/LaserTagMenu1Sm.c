// Autogenerated with StateSmith
#include "LaserTagMenu1Sm.h"
#include "App.h"
#include "Display.h"
#include "PortApi.h"
#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset

static void ROOT_enter(LaserTagMenu1Sm* self);
static void ROOT_exit(LaserTagMenu1Sm* self);

static void HOME_enter(LaserTagMenu1Sm* self);
static void HOME_exit(LaserTagMenu1Sm* self);
static void HOME_ok_press(LaserTagMenu1Sm* self);

static void HOME1_enter(LaserTagMenu1Sm* self);
static void HOME1_exit(LaserTagMenu1Sm* self);
static void HOME1_down_press(LaserTagMenu1Sm* self);
static void HOME1_up_press(LaserTagMenu1Sm* self);

static void HOME2_enter(LaserTagMenu1Sm* self);
static void HOME2_exit(LaserTagMenu1Sm* self);
static void HOME2_down_press(LaserTagMenu1Sm* self);
static void HOME2_up_press(LaserTagMenu1Sm* self);

static void HOME3_enter(LaserTagMenu1Sm* self);
static void HOME3_exit(LaserTagMenu1Sm* self);
static void HOME3_down_press(LaserTagMenu1Sm* self);
static void HOME3_up_press(LaserTagMenu1Sm* self);

static void MENUS_GROUP_enter(LaserTagMenu1Sm* self);
static void MENUS_GROUP_exit(LaserTagMenu1Sm* self);
static void MENUS_GROUP_back_held(LaserTagMenu1Sm* self);
static void MENUS_GROUP_back_press(LaserTagMenu1Sm* self);

static void CLASS_SAVED_enter(LaserTagMenu1Sm* self);
static void CLASS_SAVED_exit(LaserTagMenu1Sm* self);
static void CLASS_SAVED_do(LaserTagMenu1Sm* self);

static void MAIN_MENU_enter(LaserTagMenu1Sm* self);
static void MAIN_MENU_exit(LaserTagMenu1Sm* self);

static void MM_BACK_PRESS_EATER_OPTION_enter(LaserTagMenu1Sm* self);
static void MM_BACK_PRESS_EATER_OPTION_exit(LaserTagMenu1Sm* self);
static void MM_BACK_PRESS_EATER_OPTION_ok_press(LaserTagMenu1Sm* self);
static void MM_BACK_PRESS_EATER_OPTION_up_press(LaserTagMenu1Sm* self);

static void MM_SELECT_CLASS_OPTION_enter(LaserTagMenu1Sm* self);
static void MM_SELECT_CLASS_OPTION_exit(LaserTagMenu1Sm* self);
static void MM_SELECT_CLASS_OPTION_down_press(LaserTagMenu1Sm* self);
static void MM_SELECT_CLASS_OPTION_ok_press(LaserTagMenu1Sm* self);

static void MM_SHOW_INFO_OPTION_enter(LaserTagMenu1Sm* self);
static void MM_SHOW_INFO_OPTION_exit(LaserTagMenu1Sm* self);
static void MM_SHOW_INFO_OPTION_down_press(LaserTagMenu1Sm* self);
static void MM_SHOW_INFO_OPTION_ok_press(LaserTagMenu1Sm* self);
static void MM_SHOW_INFO_OPTION_up_press(LaserTagMenu1Sm* self);

static void MM_BACK_PRESS_EATER_enter(LaserTagMenu1Sm* self);
static void MM_BACK_PRESS_EATER_exit(LaserTagMenu1Sm* self);
static void MM_BACK_PRESS_EATER_back_press(LaserTagMenu1Sm* self);

static void MM_BACK_PRESS_EATER_1_enter(LaserTagMenu1Sm* self);
static void MM_BACK_PRESS_EATER_1_exit(LaserTagMenu1Sm* self);
static void MM_BACK_PRESS_EATER_1_do(LaserTagMenu1Sm* self);

static void MM_BACK_PRESS_EATER_2_enter(LaserTagMenu1Sm* self);
static void MM_BACK_PRESS_EATER_2_exit(LaserTagMenu1Sm* self);
static void MM_BACK_PRESS_EATER_2_do(LaserTagMenu1Sm* self);

static void MM_BACK_PRESS_EATER_3_enter(LaserTagMenu1Sm* self);
static void MM_BACK_PRESS_EATER_3_exit(LaserTagMenu1Sm* self);
static void MM_BACK_PRESS_EATER_3_do(LaserTagMenu1Sm* self);

static void MM_BACK_PRESS_EATER_4_enter(LaserTagMenu1Sm* self);
static void MM_BACK_PRESS_EATER_4_exit(LaserTagMenu1Sm* self);
static void MM_BACK_PRESS_EATER_4_do(LaserTagMenu1Sm* self);

static void MM_BACK_PRESS_EATER_5_enter(LaserTagMenu1Sm* self);
static void MM_BACK_PRESS_EATER_5_exit(LaserTagMenu1Sm* self);
static void MM_BACK_PRESS_EATER_5_back_press(LaserTagMenu1Sm* self);
static void MM_BACK_PRESS_EATER_5_do(LaserTagMenu1Sm* self);

static void MM_SELECT_CLASS_enter(LaserTagMenu1Sm* self);
static void MM_SELECT_CLASS_exit(LaserTagMenu1Sm* self);
static void MM_SELECT_CLASS_back_press(LaserTagMenu1Sm* self);
static void MM_SELECT_CLASS_ok_press(LaserTagMenu1Sm* self);

static void MM_SC_ENGINEER_enter(LaserTagMenu1Sm* self);
static void MM_SC_ENGINEER_exit(LaserTagMenu1Sm* self);
static void MM_SC_ENGINEER_down_press(LaserTagMenu1Sm* self);

static void MM_SC_MID_enter(LaserTagMenu1Sm* self);
static void MM_SC_MID_exit(LaserTagMenu1Sm* self);
static void MM_SC_MID_down_held(LaserTagMenu1Sm* self);
static void MM_SC_MID_up_held(LaserTagMenu1Sm* self);

static void MM_SC_ARCHER_enter(LaserTagMenu1Sm* self);
static void MM_SC_ARCHER_exit(LaserTagMenu1Sm* self);
static void MM_SC_ARCHER_down_press(LaserTagMenu1Sm* self);
static void MM_SC_ARCHER_up_press(LaserTagMenu1Sm* self);

static void MM_SC_HEAVY_enter(LaserTagMenu1Sm* self);
static void MM_SC_HEAVY_exit(LaserTagMenu1Sm* self);
static void MM_SC_HEAVY_down_press(LaserTagMenu1Sm* self);
static void MM_SC_HEAVY_up_press(LaserTagMenu1Sm* self);

static void MM_SC_WIZARD_enter(LaserTagMenu1Sm* self);
static void MM_SC_WIZARD_exit(LaserTagMenu1Sm* self);
static void MM_SC_WIZARD_down_press(LaserTagMenu1Sm* self);
static void MM_SC_WIZARD_up_press(LaserTagMenu1Sm* self);

static void MM_SC_SPY_enter(LaserTagMenu1Sm* self);
static void MM_SC_SPY_exit(LaserTagMenu1Sm* self);
static void MM_SC_SPY_up_press(LaserTagMenu1Sm* self);

static void MM_SHOW_INFO_enter(LaserTagMenu1Sm* self);
static void MM_SHOW_INFO_exit(LaserTagMenu1Sm* self);
static void MM_SHOW_INFO_back_press(LaserTagMenu1Sm* self);

static void MM_SHOW_INFO_1_enter(LaserTagMenu1Sm* self);
static void MM_SHOW_INFO_1_exit(LaserTagMenu1Sm* self);
static void MM_SHOW_INFO_1_do(LaserTagMenu1Sm* self);
static void MM_SHOW_INFO_1_down_press(LaserTagMenu1Sm* self);

static void MM_SHOW_INFO_2_enter(LaserTagMenu1Sm* self);
static void MM_SHOW_INFO_2_exit(LaserTagMenu1Sm* self);
static void MM_SHOW_INFO_2_do(LaserTagMenu1Sm* self);
static void MM_SHOW_INFO_2_down_press(LaserTagMenu1Sm* self);

static void MM_SHOW_INFO_3_enter(LaserTagMenu1Sm* self);
static void MM_SHOW_INFO_3_exit(LaserTagMenu1Sm* self);
static void MM_SHOW_INFO_3_do(LaserTagMenu1Sm* self);
static void MM_SHOW_INFO_3_down_press(LaserTagMenu1Sm* self);

static void WELCOME_SCREEN_enter(LaserTagMenu1Sm* self);
static void WELCOME_SCREEN_exit(LaserTagMenu1Sm* self);
static void WELCOME_SCREEN_do(LaserTagMenu1Sm* self);

static void exit_up_to_state_handler(LaserTagMenu1Sm* self, const LaserTagMenu1Sm_Func desired_state_exit_handler);


void LaserTagMenu1Sm_ctor(LaserTagMenu1Sm* self)
{
    memset(self, 0, sizeof(*self));
}

static void exit_up_to_state_handler(LaserTagMenu1Sm* self, const LaserTagMenu1Sm_Func desired_state_exit_handler)
{
    while (self->current_state_exit_handler != desired_state_exit_handler)
    {
        self->current_state_exit_handler(self);
    }
}

void LaserTagMenu1Sm_start(LaserTagMenu1Sm* self)
{
    ROOT_enter(self);
    // ROOT behavior
    // uml: TransitionTo(ROOT.InitialState)
    if (true)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // At this point, StateSmith doesn't know what the active leaf state is. It could be ROOT or one of its sub states.
        exit_up_to_state_handler(self, ROOT_exit);  // Exit until we reach ROOT state.
        
        // Enter towards target
        
        // ROOT.InitialState behavior
        // uml: TransitionTo(WELCOME_SCREEN)
        if (true)
        {
            
            // Enter towards target
            WELCOME_SCREEN_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_WELCOME_SCREEN;
            self->ancestor_event_handler = NULL;
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for ROOT.InitialState
    } // end of behavior for ROOT
}

void LaserTagMenu1Sm_dispatch_event(LaserTagMenu1Sm* self, enum LaserTagMenu1Sm_EventId event_id)
{
    LaserTagMenu1Sm_Func behavior_func = self->current_event_handlers[event_id];
    
    while (behavior_func != NULL)
    {
        self->ancestor_event_handler = NULL;
        behavior_func(self);
        behavior_func = self->ancestor_event_handler;
    }
}

const char* LaserTagMenu1Sm_state_id_to_string(const enum LaserTagMenu1Sm_StateId id)
{
    switch (id)
    {
        case LaserTagMenu1Sm_StateId_ROOT: return "ROOT";
        case LaserTagMenu1Sm_StateId_HOME: return "HOME";
        case LaserTagMenu1Sm_StateId_HOME1: return "HOME1";
        case LaserTagMenu1Sm_StateId_HOME2: return "HOME2";
        case LaserTagMenu1Sm_StateId_HOME3: return "HOME3";
        case LaserTagMenu1Sm_StateId_MENUS_GROUP: return "MENUS_GROUP";
        case LaserTagMenu1Sm_StateId_CLASS_SAVED: return "CLASS_SAVED";
        case LaserTagMenu1Sm_StateId_MAIN_MENU: return "MAIN_MENU";
        case LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER_OPTION: return "MM_BACK_PRESS_EATER_OPTION";
        case LaserTagMenu1Sm_StateId_MM_SELECT_CLASS_OPTION: return "MM_SELECT_CLASS_OPTION";
        case LaserTagMenu1Sm_StateId_MM_SHOW_INFO_OPTION: return "MM_SHOW_INFO_OPTION";
        case LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER: return "MM_BACK_PRESS_EATER";
        case LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER_1: return "MM_BACK_PRESS_EATER_1";
        case LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER_2: return "MM_BACK_PRESS_EATER_2";
        case LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER_3: return "MM_BACK_PRESS_EATER_3";
        case LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER_4: return "MM_BACK_PRESS_EATER_4";
        case LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER_5: return "MM_BACK_PRESS_EATER_5";
        case LaserTagMenu1Sm_StateId_MM_SELECT_CLASS: return "MM_SELECT_CLASS";
        case LaserTagMenu1Sm_StateId_MM_SC_ENGINEER: return "MM_SC_ENGINEER";
        case LaserTagMenu1Sm_StateId_MM_SC_MID: return "MM_SC_MID";
        case LaserTagMenu1Sm_StateId_MM_SC_ARCHER: return "MM_SC_ARCHER";
        case LaserTagMenu1Sm_StateId_MM_SC_HEAVY: return "MM_SC_HEAVY";
        case LaserTagMenu1Sm_StateId_MM_SC_WIZARD: return "MM_SC_WIZARD";
        case LaserTagMenu1Sm_StateId_MM_SC_SPY: return "MM_SC_SPY";
        case LaserTagMenu1Sm_StateId_MM_SHOW_INFO: return "MM_SHOW_INFO";
        case LaserTagMenu1Sm_StateId_MM_SHOW_INFO_1: return "MM_SHOW_INFO_1";
        case LaserTagMenu1Sm_StateId_MM_SHOW_INFO_2: return "MM_SHOW_INFO_2";
        case LaserTagMenu1Sm_StateId_MM_SHOW_INFO_3: return "MM_SHOW_INFO_3";
        case LaserTagMenu1Sm_StateId_WELCOME_SCREEN: return "WELCOME_SCREEN";
        default: return "?";
    }
}

////////////////////////////////////////////////////////////////////////////////
// event handlers for state ROOT
////////////////////////////////////////////////////////////////////////////////

static void ROOT_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = ROOT_exit;
}

static void ROOT_exit(LaserTagMenu1Sm* self)
{
    // State machine root is a special case. It cannot be exited.
    (void)self;  // nothing to see here compiler. move along!
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state HOME
////////////////////////////////////////////////////////////////////////////////

static void HOME_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = HOME_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_OK_PRESS] = HOME_ok_press;
}

static void HOME_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_OK_PRESS] = NULL;  // no ancestor listens to this event
}

static void HOME_ok_press(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `OK_PRESS` event.
    
    // HOME behavior
    // uml: OK_PRESS TransitionTo(MAIN_MENU)
    if (true)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // At this point, StateSmith doesn't know what the active leaf state is. It could be HOME or one of its sub states.
        exit_up_to_state_handler(self, ROOT_exit);  // Exit until we reach ROOT state.
        
        // Enter towards target
        MENUS_GROUP_enter(self);
        MAIN_MENU_enter(self);
        
        // MAIN_MENU.InitialState behavior
        // uml: TransitionTo(MM_SELECT_CLASS_OPTION)
        if (true)
        {
            
            // Enter towards target
            MM_SELECT_CLASS_OPTION_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_MM_SELECT_CLASS_OPTION;
            self->ancestor_event_handler = NULL;
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for MAIN_MENU.InitialState
    } // end of behavior for HOME
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state HOME1
////////////////////////////////////////////////////////////////////////////////

static void HOME1_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = HOME1_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = HOME1_down_press;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = HOME1_up_press;
    
    // HOME1 behavior
    // uml: enter / { show_home_screen_1(); }
    if (true)
    {
        Display_show_home_screen_1();
    } // end of behavior for HOME1
}

static void HOME1_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = HOME_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = NULL;  // no ancestor listens to this event
}

static void HOME1_down_press(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `DOWN_PRESS` event.
    
    // HOME1 behavior
    // uml: DOWN_PRESS TransitionTo(HOME2)
    if (true)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Avoid exit-while-loop here because we know that the active leaf state is HOME1 and it is the only state being exited at this point.
        HOME1_exit(self);
        
        // Enter towards target
        HOME2_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_HOME2;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for HOME1
}

static void HOME1_up_press(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `UP_PRESS` event.
    
    // HOME1 behavior
    // uml: UP_PRESS TransitionTo(HOME3)
    if (true)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Avoid exit-while-loop here because we know that the active leaf state is HOME1 and it is the only state being exited at this point.
        HOME1_exit(self);
        
        // Enter towards target
        HOME3_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_HOME3;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for HOME1
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state HOME2
////////////////////////////////////////////////////////////////////////////////

static void HOME2_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = HOME2_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = HOME2_down_press;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = HOME2_up_press;
    
    // HOME2 behavior
    // uml: enter / { show_home_screen_2(); }
    if (true)
    {
        Display_show_home_screen_2();
    } // end of behavior for HOME2
}

static void HOME2_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = HOME_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = NULL;  // no ancestor listens to this event
}

static void HOME2_down_press(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `DOWN_PRESS` event.
    
    // HOME2 behavior
    // uml: DOWN_PRESS TransitionTo(HOME3)
    if (true)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Avoid exit-while-loop here because we know that the active leaf state is HOME2 and it is the only state being exited at this point.
        HOME2_exit(self);
        
        // Enter towards target
        HOME3_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_HOME3;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for HOME2
}

static void HOME2_up_press(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `UP_PRESS` event.
    
    // HOME2 behavior
    // uml: UP_PRESS TransitionTo(HOME1)
    if (true)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Avoid exit-while-loop here because we know that the active leaf state is HOME2 and it is the only state being exited at this point.
        HOME2_exit(self);
        
        // Enter towards target
        HOME1_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_HOME1;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for HOME2
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state HOME3
////////////////////////////////////////////////////////////////////////////////

static void HOME3_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = HOME3_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = HOME3_down_press;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = HOME3_up_press;
    
    // HOME3 behavior
    // uml: enter / { show_home_screen_3(); }
    if (true)
    {
        Display_show_home_screen_3();
    } // end of behavior for HOME3
}

static void HOME3_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = HOME_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = NULL;  // no ancestor listens to this event
}

static void HOME3_down_press(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `DOWN_PRESS` event.
    
    // HOME3 behavior
    // uml: DOWN_PRESS TransitionTo(HOME1)
    if (true)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Avoid exit-while-loop here because we know that the active leaf state is HOME3 and it is the only state being exited at this point.
        HOME3_exit(self);
        
        // Enter towards target
        HOME1_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_HOME1;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for HOME3
}

static void HOME3_up_press(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `UP_PRESS` event.
    
    // HOME3 behavior
    // uml: UP_PRESS TransitionTo(HOME2)
    if (true)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Avoid exit-while-loop here because we know that the active leaf state is HOME3 and it is the only state being exited at this point.
        HOME3_exit(self);
        
        // Enter towards target
        HOME2_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_HOME2;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for HOME3
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MENUS_GROUP
////////////////////////////////////////////////////////////////////////////////

static void MENUS_GROUP_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MENUS_GROUP_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_HELD] = MENUS_GROUP_back_held;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_PRESS] = MENUS_GROUP_back_press;
}

static void MENUS_GROUP_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_HELD] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_PRESS] = NULL;  // no ancestor listens to this event
}

static void MENUS_GROUP_back_held(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `BACK_HELD` event.
    
    // MENUS_GROUP behavior
    // uml: BACK_HELD TransitionTo(HOME)
    if (true)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // At this point, StateSmith doesn't know what the active leaf state is. It could be MENUS_GROUP or one of its sub states.
        exit_up_to_state_handler(self, ROOT_exit);  // Exit until we reach ROOT state.
        
        // Enter towards target
        HOME_enter(self);
        
        // HOME.InitialState behavior
        // uml: TransitionTo(HOME1)
        if (true)
        {
            
            // Enter towards target
            HOME1_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_HOME1;
            self->ancestor_event_handler = NULL;
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for HOME.InitialState
    } // end of behavior for MENUS_GROUP
}

static void MENUS_GROUP_back_press(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `BACK_PRESS` event.
    
    // MENUS_GROUP behavior
    // uml: BACK_PRESS TransitionTo(HOME)
    if (true)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // At this point, StateSmith doesn't know what the active leaf state is. It could be MENUS_GROUP or one of its sub states.
        exit_up_to_state_handler(self, ROOT_exit);  // Exit until we reach ROOT state.
        
        // Enter towards target
        HOME_enter(self);
        
        // HOME.InitialState behavior
        // uml: TransitionTo(HOME1)
        if (true)
        {
            
            // Enter towards target
            HOME1_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_HOME1;
            self->ancestor_event_handler = NULL;
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for HOME.InitialState
    } // end of behavior for MENUS_GROUP
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CLASS_SAVED
////////////////////////////////////////////////////////////////////////////////

static void CLASS_SAVED_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = CLASS_SAVED_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = CLASS_SAVED_do;
    
    // CLASS_SAVED behavior
    // uml: enter / { Display_class_saved(); }
    if (true)
    {
        Display_class_saved();
    } // end of behavior for CLASS_SAVED
    
    // CLASS_SAVED behavior
    // uml: enter / { reset_timer1(); }
    if (true)
    {
        self->vars.timer1_started_at_ms = PortApi_get_time_ms();
    } // end of behavior for CLASS_SAVED
}

static void CLASS_SAVED_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MENUS_GROUP_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void CLASS_SAVED_do(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `do` event.
    
    // CLASS_SAVED behavior
    // uml: do [after_timer1_ms(4000)] TransitionTo(MM_SELECT_CLASS_OPTION)
    if (( (PortApi_get_time_ms() - self->vars.timer1_started_at_ms) >= 4000 ))
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Avoid exit-while-loop here because we know that the active leaf state is CLASS_SAVED and it is the only state being exited at this point.
        CLASS_SAVED_exit(self);
        
        // Enter towards target
        MAIN_MENU_enter(self);
        MM_SELECT_CLASS_OPTION_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_MM_SELECT_CLASS_OPTION;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for CLASS_SAVED
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MAIN_MENU
////////////////////////////////////////////////////////////////////////////////

static void MAIN_MENU_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MAIN_MENU_exit;
    
    // MAIN_MENU behavior
    // uml: enter / { Display_menu_header("MAIN MENU"); }
    if (true)
    {
        Display_menu_header("MAIN MENU");
    } // end of behavior for MAIN_MENU
}

static void MAIN_MENU_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MENUS_GROUP_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_BACK_PRESS_EATER_OPTION
////////////////////////////////////////////////////////////////////////////////

static void MM_BACK_PRESS_EATER_OPTION_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_BACK_PRESS_EATER_OPTION_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_OK_PRESS] = MM_BACK_PRESS_EATER_OPTION_ok_press;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = MM_BACK_PRESS_EATER_OPTION_up_press;
    
    // MM_BACK_PRESS_EATER_OPTION behavior
    // uml: enter / { Display_menu_option("EAT BACK PRESS?"); }
    if (true)
    {
        Display_menu_option("EAT BACK PRESS?");
    } // end of behavior for MM_BACK_PRESS_EATER_OPTION
    
    // MM_BACK_PRESS_EATER_OPTION behavior
    // uml: enter / { menu_at_bottom(); }
    if (true)
    {
        Display_menu_at_bottom();
    } // end of behavior for MM_BACK_PRESS_EATER_OPTION
}

static void MM_BACK_PRESS_EATER_OPTION_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MAIN_MENU_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_OK_PRESS] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_BACK_PRESS_EATER_OPTION_ok_press(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `OK_PRESS` event.
    
    // MM_BACK_PRESS_EATER_OPTION behavior
    // uml: OK_PRESS TransitionTo(MM_BACK_PRESS_EATER)
    if (true)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // At this point, StateSmith doesn't know what the active leaf state is. It could be MM_BACK_PRESS_EATER_OPTION or one of its sub states.
        exit_up_to_state_handler(self, MENUS_GROUP_exit);  // Exit until we reach MENUS_GROUP state.
        
        // Enter towards target
        MM_BACK_PRESS_EATER_enter(self);
        
        // MM_BACK_PRESS_EATER.InitialState behavior
        // uml: TransitionTo(MM_BACK_PRESS_EATER_1)
        if (true)
        {
            
            // Enter towards target
            MM_BACK_PRESS_EATER_1_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER_1;
            self->ancestor_event_handler = NULL;
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for MM_BACK_PRESS_EATER.InitialState
    } // end of behavior for MM_BACK_PRESS_EATER_OPTION
}

static void MM_BACK_PRESS_EATER_OPTION_up_press(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `UP_PRESS` event.
    
    // MM_BACK_PRESS_EATER_OPTION behavior
    // uml: UP_PRESS TransitionTo(MM_SHOW_INFO_OPTION)
    if (true)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Avoid exit-while-loop here because we know that the active leaf state is MM_BACK_PRESS_EATER_OPTION and it is the only state being exited at this point.
        MM_BACK_PRESS_EATER_OPTION_exit(self);
        
        // Enter towards target
        MM_SHOW_INFO_OPTION_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_MM_SHOW_INFO_OPTION;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for MM_BACK_PRESS_EATER_OPTION
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_SELECT_CLASS_OPTION
////////////////////////////////////////////////////////////////////////////////

static void MM_SELECT_CLASS_OPTION_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_SELECT_CLASS_OPTION_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = MM_SELECT_CLASS_OPTION_down_press;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_OK_PRESS] = MM_SELECT_CLASS_OPTION_ok_press;
    
    // MM_SELECT_CLASS_OPTION behavior
    // uml: enter / { Display_menu_option("SELECT CLASS");\nmenu_at_top(); }
    if (true)
    {
        Display_menu_option("SELECT CLASS");
        Display_menu_at_top();
    } // end of behavior for MM_SELECT_CLASS_OPTION
}

static void MM_SELECT_CLASS_OPTION_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MAIN_MENU_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[LaserTagMenu1Sm_EventId_OK_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_SELECT_CLASS_OPTION_down_press(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `DOWN_PRESS` event.
    
    // MM_SELECT_CLASS_OPTION behavior
    // uml: DOWN_PRESS TransitionTo(MM_SHOW_INFO_OPTION)
    if (true)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Avoid exit-while-loop here because we know that the active leaf state is MM_SELECT_CLASS_OPTION and it is the only state being exited at this point.
        MM_SELECT_CLASS_OPTION_exit(self);
        
        // Enter towards target
        MM_SHOW_INFO_OPTION_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_MM_SHOW_INFO_OPTION;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for MM_SELECT_CLASS_OPTION
}

static void MM_SELECT_CLASS_OPTION_ok_press(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `OK_PRESS` event.
    
    // MM_SELECT_CLASS_OPTION behavior
    // uml: OK_PRESS TransitionTo(MM_SELECT_CLASS)
    if (true)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // At this point, StateSmith doesn't know what the active leaf state is. It could be MM_SELECT_CLASS_OPTION or one of its sub states.
        exit_up_to_state_handler(self, MENUS_GROUP_exit);  // Exit until we reach MENUS_GROUP state.
        
        // Enter towards target
        MM_SELECT_CLASS_enter(self);
        
        // MM_SELECT_CLASS.InitialState behavior
        // uml: TransitionTo(MM_SC_ENGINEER)
        if (true)
        {
            
            // Enter towards target
            MM_SC_ENGINEER_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_MM_SC_ENGINEER;
            self->ancestor_event_handler = NULL;
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for MM_SELECT_CLASS.InitialState
    } // end of behavior for MM_SELECT_CLASS_OPTION
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_SHOW_INFO_OPTION
////////////////////////////////////////////////////////////////////////////////

static void MM_SHOW_INFO_OPTION_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_SHOW_INFO_OPTION_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = MM_SHOW_INFO_OPTION_down_press;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_OK_PRESS] = MM_SHOW_INFO_OPTION_ok_press;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = MM_SHOW_INFO_OPTION_up_press;
    
    // MM_SHOW_INFO_OPTION behavior
    // uml: enter / { Display_menu_option("SHOW INFO"); }
    if (true)
    {
        Display_menu_option("SHOW INFO");
    } // end of behavior for MM_SHOW_INFO_OPTION
    
    // MM_SHOW_INFO_OPTION behavior
    // uml: enter / { menu_at_mid(); }
    if (true)
    {
        Display_menu_at_mid();
    } // end of behavior for MM_SHOW_INFO_OPTION
}

static void MM_SHOW_INFO_OPTION_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MAIN_MENU_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[LaserTagMenu1Sm_EventId_OK_PRESS] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_SHOW_INFO_OPTION_down_press(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `DOWN_PRESS` event.
    
    // MM_SHOW_INFO_OPTION behavior
    // uml: DOWN_PRESS TransitionTo(MM_BACK_PRESS_EATER_OPTION)
    if (true)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Avoid exit-while-loop here because we know that the active leaf state is MM_SHOW_INFO_OPTION and it is the only state being exited at this point.
        MM_SHOW_INFO_OPTION_exit(self);
        
        // Enter towards target
        MM_BACK_PRESS_EATER_OPTION_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER_OPTION;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for MM_SHOW_INFO_OPTION
}

static void MM_SHOW_INFO_OPTION_ok_press(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `OK_PRESS` event.
    
    // MM_SHOW_INFO_OPTION behavior
    // uml: OK_PRESS TransitionTo(MM_SHOW_INFO)
    if (true)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // At this point, StateSmith doesn't know what the active leaf state is. It could be MM_SHOW_INFO_OPTION or one of its sub states.
        exit_up_to_state_handler(self, MENUS_GROUP_exit);  // Exit until we reach MENUS_GROUP state.
        
        // Enter towards target
        MM_SHOW_INFO_enter(self);
        
        // MM_SHOW_INFO.InitialState behavior
        // uml: TransitionTo(MM_SHOW_INFO_1)
        if (true)
        {
            
            // Enter towards target
            MM_SHOW_INFO_1_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_MM_SHOW_INFO_1;
            self->ancestor_event_handler = NULL;
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for MM_SHOW_INFO.InitialState
    } // end of behavior for MM_SHOW_INFO_OPTION
}

static void MM_SHOW_INFO_OPTION_up_press(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `UP_PRESS` event.
    
    // MM_SHOW_INFO_OPTION behavior
    // uml: UP_PRESS TransitionTo(MM_SELECT_CLASS_OPTION)
    if (true)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Avoid exit-while-loop here because we know that the active leaf state is MM_SHOW_INFO_OPTION and it is the only state being exited at this point.
        MM_SHOW_INFO_OPTION_exit(self);
        
        // Enter towards target
        MM_SELECT_CLASS_OPTION_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_MM_SELECT_CLASS_OPTION;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for MM_SHOW_INFO_OPTION
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_BACK_PRESS_EATER
////////////////////////////////////////////////////////////////////////////////

static void MM_BACK_PRESS_EATER_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_BACK_PRESS_EATER_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_PRESS] = MM_BACK_PRESS_EATER_back_press;
    
    // MM_BACK_PRESS_EATER behavior
    // uml: enter / { back_press_eat_count = 0;\nshow_back_press_count(); }
    if (true)
    {
        self->vars.back_press_eat_count = 0;
        Display_show_back_press_count(self->vars.back_press_eat_count);
    } // end of behavior for MM_BACK_PRESS_EATER
}

static void MM_BACK_PRESS_EATER_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MENUS_GROUP_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_PRESS] = MENUS_GROUP_back_press;  // the next ancestor that handles this event is MENUS_GROUP
}

static void MM_BACK_PRESS_EATER_back_press(LaserTagMenu1Sm* self)
{
    // Setup handler for next ancestor that listens to `BACK_PRESS` event.
    self->ancestor_event_handler = MENUS_GROUP_back_press;
    
    // MM_BACK_PRESS_EATER behavior
    // uml: BACK_PRESS / { back_press_eat_count++;\nshow_back_press_count(); }
    if (true)
    {
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        self->vars.back_press_eat_count++;
        Display_show_back_press_count(self->vars.back_press_eat_count);
        
        if (consume_event)
        {
            // Mark event as handled.
            self->ancestor_event_handler = NULL;
        }
    } // end of behavior for MM_BACK_PRESS_EATER
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_BACK_PRESS_EATER_1
////////////////////////////////////////////////////////////////////////////////

static void MM_BACK_PRESS_EATER_1_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_BACK_PRESS_EATER_1_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = MM_BACK_PRESS_EATER_1_do;
    
    // MM_BACK_PRESS_EATER_1 behavior
    // uml: enter / { show_back_press_taunt("GET TO 5?"); }
    if (true)
    {
        Display_show_back_press_taunt("GET TO 5?");
    } // end of behavior for MM_BACK_PRESS_EATER_1
}

static void MM_BACK_PRESS_EATER_1_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MM_BACK_PRESS_EATER_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void MM_BACK_PRESS_EATER_1_do(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `do` event.
    
    // MM_BACK_PRESS_EATER_1 behavior
    // uml: do [back_press_eat_count >= 5] TransitionTo(MM_BACK_PRESS_EATER_2)
    if (self->vars.back_press_eat_count >= 5)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Avoid exit-while-loop here because we know that the active leaf state is MM_BACK_PRESS_EATER_1 and it is the only state being exited at this point.
        MM_BACK_PRESS_EATER_1_exit(self);
        
        // Enter towards target
        MM_BACK_PRESS_EATER_2_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER_2;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for MM_BACK_PRESS_EATER_1
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_BACK_PRESS_EATER_2
////////////////////////////////////////////////////////////////////////////////

static void MM_BACK_PRESS_EATER_2_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_BACK_PRESS_EATER_2_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = MM_BACK_PRESS_EATER_2_do;
    
    // MM_BACK_PRESS_EATER_2 behavior
    // uml: enter / { show_back_press_taunt("BACKPRESS FUTILE"); }
    if (true)
    {
        Display_show_back_press_taunt("BACKPRESS FUTILE");
    } // end of behavior for MM_BACK_PRESS_EATER_2
    
    // MM_BACK_PRESS_EATER_2 behavior
    // uml: enter / { reset_timer1(); }
    if (true)
    {
        self->vars.timer1_started_at_ms = PortApi_get_time_ms();
    } // end of behavior for MM_BACK_PRESS_EATER_2
}

static void MM_BACK_PRESS_EATER_2_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MM_BACK_PRESS_EATER_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void MM_BACK_PRESS_EATER_2_do(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `do` event.
    
    // MM_BACK_PRESS_EATER_2 behavior
    // uml: do [after_timer1_ms(3000)] TransitionTo(MM_BACK_PRESS_EATER_3)
    if (( (PortApi_get_time_ms() - self->vars.timer1_started_at_ms) >= 3000 ))
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Avoid exit-while-loop here because we know that the active leaf state is MM_BACK_PRESS_EATER_2 and it is the only state being exited at this point.
        MM_BACK_PRESS_EATER_2_exit(self);
        
        // Enter towards target
        MM_BACK_PRESS_EATER_3_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER_3;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for MM_BACK_PRESS_EATER_2
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_BACK_PRESS_EATER_3
////////////////////////////////////////////////////////////////////////////////

static void MM_BACK_PRESS_EATER_3_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_BACK_PRESS_EATER_3_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = MM_BACK_PRESS_EATER_3_do;
    
    // MM_BACK_PRESS_EATER_3 behavior
    // uml: enter / { show_back_press_taunt("TRY HOLDING BACK"); }
    if (true)
    {
        Display_show_back_press_taunt("TRY HOLDING BACK");
    } // end of behavior for MM_BACK_PRESS_EATER_3
    
    // MM_BACK_PRESS_EATER_3 behavior
    // uml: enter / { reset_timer1(); }
    if (true)
    {
        self->vars.timer1_started_at_ms = PortApi_get_time_ms();
    } // end of behavior for MM_BACK_PRESS_EATER_3
}

static void MM_BACK_PRESS_EATER_3_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MM_BACK_PRESS_EATER_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void MM_BACK_PRESS_EATER_3_do(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `do` event.
    
    // MM_BACK_PRESS_EATER_3 behavior
    // uml: do [back_press_eat_count >= 10 && after_timer1_ms(3000)] TransitionTo(MM_BACK_PRESS_EATER_4)
    if (self->vars.back_press_eat_count >= 10 && ( (PortApi_get_time_ms() - self->vars.timer1_started_at_ms) >= 3000 ))
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Avoid exit-while-loop here because we know that the active leaf state is MM_BACK_PRESS_EATER_3 and it is the only state being exited at this point.
        MM_BACK_PRESS_EATER_3_exit(self);
        
        // Enter towards target
        MM_BACK_PRESS_EATER_4_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER_4;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for MM_BACK_PRESS_EATER_3
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_BACK_PRESS_EATER_4
////////////////////////////////////////////////////////////////////////////////

static void MM_BACK_PRESS_EATER_4_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_BACK_PRESS_EATER_4_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = MM_BACK_PRESS_EATER_4_do;
    
    // MM_BACK_PRESS_EATER_4 behavior
    // uml: enter / { show_back_press_taunt("I CAN'T EVENT..."); }
    if (true)
    {
        Display_show_back_press_taunt("I CAN'T EVENT...");
    } // end of behavior for MM_BACK_PRESS_EATER_4
    
    // MM_BACK_PRESS_EATER_4 behavior
    // uml: enter / { reset_timer1(); }
    if (true)
    {
        self->vars.timer1_started_at_ms = PortApi_get_time_ms();
    } // end of behavior for MM_BACK_PRESS_EATER_4
}

static void MM_BACK_PRESS_EATER_4_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MM_BACK_PRESS_EATER_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void MM_BACK_PRESS_EATER_4_do(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `do` event.
    
    // MM_BACK_PRESS_EATER_4 behavior
    // uml: do [back_press_eat_count >= 15 && after_timer1_ms(3000)] TransitionTo(MM_BACK_PRESS_EATER_5)
    if (self->vars.back_press_eat_count >= 15 && ( (PortApi_get_time_ms() - self->vars.timer1_started_at_ms) >= 3000 ))
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Avoid exit-while-loop here because we know that the active leaf state is MM_BACK_PRESS_EATER_4 and it is the only state being exited at this point.
        MM_BACK_PRESS_EATER_4_exit(self);
        
        // Enter towards target
        MM_BACK_PRESS_EATER_5_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER_5;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for MM_BACK_PRESS_EATER_4
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_BACK_PRESS_EATER_5
////////////////////////////////////////////////////////////////////////////////

static void MM_BACK_PRESS_EATER_5_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_BACK_PRESS_EATER_5_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_PRESS] = MM_BACK_PRESS_EATER_5_back_press;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = MM_BACK_PRESS_EATER_5_do;
    
    // MM_BACK_PRESS_EATER_5 behavior
    // uml: enter / { reset_timer1(); }
    if (true)
    {
        self->vars.timer1_started_at_ms = PortApi_get_time_ms();
    } // end of behavior for MM_BACK_PRESS_EATER_5
    
    // MM_BACK_PRESS_EATER_5 behavior
    // uml: enter / { show_random_back_press_taunt(); }
    if (true)
    {
        Display_show_random_back_press_taunt();
    } // end of behavior for MM_BACK_PRESS_EATER_5
}

static void MM_BACK_PRESS_EATER_5_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MM_BACK_PRESS_EATER_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_PRESS] = MM_BACK_PRESS_EATER_back_press;  // the next ancestor that handles this event is MM_BACK_PRESS_EATER
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void MM_BACK_PRESS_EATER_5_back_press(LaserTagMenu1Sm* self)
{
    // Setup handler for next ancestor that listens to `BACK_PRESS` event.
    self->ancestor_event_handler = MM_BACK_PRESS_EATER_back_press;
    
    // MM_BACK_PRESS_EATER_5 behavior
    // uml: BACK_PRESS / { dont_consume_event(); // allow parent inc count\nreset_timer1();\nshow_random_back_press_taunt(); }
    if (true)
    {
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        consume_event = false; // allow parent inc count
        self->vars.timer1_started_at_ms = PortApi_get_time_ms();
        Display_show_random_back_press_taunt();
        
        if (consume_event)
        {
            // Mark event as handled.
            self->ancestor_event_handler = NULL;
        }
    } // end of behavior for MM_BACK_PRESS_EATER_5
}

static void MM_BACK_PRESS_EATER_5_do(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `do` event.
    
    // MM_BACK_PRESS_EATER_5 behavior
    // uml: 1.1. do [after_timer1_ms(2000) && back_press_eat_count > 25] / { back_press_eat_count = 0; } TransitionTo(MM_BACK_PRESS_EATER_2)
    if (( (PortApi_get_time_ms() - self->vars.timer1_started_at_ms) >= 2000 ) && self->vars.back_press_eat_count > 25)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Avoid exit-while-loop here because we know that the active leaf state is MM_BACK_PRESS_EATER_5 and it is the only state being exited at this point.
        MM_BACK_PRESS_EATER_5_exit(self);
        self->vars.back_press_eat_count = 0;
        
        // Enter towards target
        MM_BACK_PRESS_EATER_2_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER_2;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for MM_BACK_PRESS_EATER_5
    
    // MM_BACK_PRESS_EATER_5 behavior
    // uml: 2. do [after_timer1_ms(2000)] TransitionTo(MM_BACK_PRESS_EATER_5)
    if (( (PortApi_get_time_ms() - self->vars.timer1_started_at_ms) >= 2000 ))
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Avoid exit-while-loop here because we know that the active leaf state is MM_BACK_PRESS_EATER_5 and it is the only state being exited at this point.
        MM_BACK_PRESS_EATER_5_exit(self);
        
        // Enter towards target
        MM_BACK_PRESS_EATER_5_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER_5;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for MM_BACK_PRESS_EATER_5
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_SELECT_CLASS
////////////////////////////////////////////////////////////////////////////////

static void MM_SELECT_CLASS_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_SELECT_CLASS_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_PRESS] = MM_SELECT_CLASS_back_press;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_OK_PRESS] = MM_SELECT_CLASS_ok_press;
    
    // MM_SELECT_CLASS behavior
    // uml: enter / { Display_menu_header("SELECT CLASS"); }
    if (true)
    {
        Display_menu_header("SELECT CLASS");
    } // end of behavior for MM_SELECT_CLASS
}

static void MM_SELECT_CLASS_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MENUS_GROUP_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_PRESS] = MENUS_GROUP_back_press;  // the next ancestor that handles this event is MENUS_GROUP
    self->current_event_handlers[LaserTagMenu1Sm_EventId_OK_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_SELECT_CLASS_back_press(LaserTagMenu1Sm* self)
{
    // Setup handler for next ancestor that listens to `BACK_PRESS` event.
    self->ancestor_event_handler = MENUS_GROUP_back_press;
    
    // MM_SELECT_CLASS behavior
    // uml: BACK_PRESS TransitionTo(MM_SELECT_CLASS_OPTION)
    if (true)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // At this point, StateSmith doesn't know what the active leaf state is. It could be MM_SELECT_CLASS or one of its sub states.
        exit_up_to_state_handler(self, MENUS_GROUP_exit);  // Exit until we reach MENUS_GROUP state.
        
        // Enter towards target
        MAIN_MENU_enter(self);
        MM_SELECT_CLASS_OPTION_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_MM_SELECT_CLASS_OPTION;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for MM_SELECT_CLASS
}

static void MM_SELECT_CLASS_ok_press(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `OK_PRESS` event.
    
    // MM_SELECT_CLASS behavior
    // uml: OK_PRESS / { save_option_as_class(); } TransitionTo(MM_SELECT_CLASS.ExitPoint(saved))
    if (true)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // At this point, StateSmith doesn't know what the active leaf state is. It could be MM_SELECT_CLASS or one of its sub states.
        exit_up_to_state_handler(self, MM_SELECT_CLASS_exit);  // Exit until we reach MM_SELECT_CLASS state.
        App_save_player_class(self->vars.option_value);
        
        // Enter towards target
        
        // MM_SELECT_CLASS.ExitPoint(saved) behavior
        // uml: TransitionTo(CLASS_SAVED)
        if (true)
        {
            // Avoid exit-while-loop here because we know that the active leaf state is MM_SELECT_CLASS and it is the only state being exited at this point.
            MM_SELECT_CLASS_exit(self);
            
            // Enter towards target
            CLASS_SAVED_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_CLASS_SAVED;
            self->ancestor_event_handler = NULL;
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for MM_SELECT_CLASS.ExitPoint(saved)
    } // end of behavior for MM_SELECT_CLASS
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_SC_ENGINEER
////////////////////////////////////////////////////////////////////////////////

static void MM_SC_ENGINEER_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_SC_ENGINEER_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = MM_SC_ENGINEER_down_press;
    
    // MM_SC_ENGINEER behavior
    // uml: enter / { Display_menu_option("ENGINEER");\noption_value = PlayerClass_ENGINEER;\nmenu_at_top(); }
    if (true)
    {
        Display_menu_option("ENGINEER");
        self->vars.option_value = PlayerClass_ENGINEER;
        Display_menu_at_top();
    } // end of behavior for MM_SC_ENGINEER
}

static void MM_SC_ENGINEER_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MM_SELECT_CLASS_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_SC_ENGINEER_down_press(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `DOWN_PRESS` event.
    
    // MM_SC_ENGINEER behavior
    // uml: DOWN_PRESS TransitionTo(MM_SC_HEAVY)
    if (true)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Avoid exit-while-loop here because we know that the active leaf state is MM_SC_ENGINEER and it is the only state being exited at this point.
        MM_SC_ENGINEER_exit(self);
        
        // Enter towards target
        MM_SC_MID_enter(self);
        MM_SC_HEAVY_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_MM_SC_HEAVY;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for MM_SC_ENGINEER
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_SC_MID
////////////////////////////////////////////////////////////////////////////////

static void MM_SC_MID_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_SC_MID_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_HELD] = MM_SC_MID_down_held;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_HELD] = MM_SC_MID_up_held;
    
    // MM_SC_MID behavior
    // uml: enter / { menu_at_mid(); }
    if (true)
    {
        Display_menu_at_mid();
    } // end of behavior for MM_SC_MID
}

static void MM_SC_MID_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MM_SELECT_CLASS_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_HELD] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_HELD] = NULL;  // no ancestor listens to this event
}

static void MM_SC_MID_down_held(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `DOWN_HELD` event.
    
    // MM_SC_MID behavior
    // uml: DOWN_HELD TransitionTo(MM_SC_SPY)
    if (true)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // At this point, StateSmith doesn't know what the active leaf state is. It could be MM_SC_MID or one of its sub states.
        exit_up_to_state_handler(self, MM_SELECT_CLASS_exit);  // Exit until we reach MM_SELECT_CLASS state.
        
        // Enter towards target
        MM_SC_SPY_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_MM_SC_SPY;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for MM_SC_MID
}

static void MM_SC_MID_up_held(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `UP_HELD` event.
    
    // MM_SC_MID behavior
    // uml: UP_HELD TransitionTo(MM_SC_ENGINEER)
    if (true)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // At this point, StateSmith doesn't know what the active leaf state is. It could be MM_SC_MID or one of its sub states.
        exit_up_to_state_handler(self, MM_SELECT_CLASS_exit);  // Exit until we reach MM_SELECT_CLASS state.
        
        // Enter towards target
        MM_SC_ENGINEER_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_MM_SC_ENGINEER;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for MM_SC_MID
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_SC_ARCHER
////////////////////////////////////////////////////////////////////////////////

static void MM_SC_ARCHER_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_SC_ARCHER_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = MM_SC_ARCHER_down_press;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = MM_SC_ARCHER_up_press;
    
    // MM_SC_ARCHER behavior
    // uml: enter / { set_menu_option_and_class(ARCHER); }
    if (true)
    {
        Display_menu_option("ARCHER"); self->vars.option_value = PlayerClass_ARCHER;
    } // end of behavior for MM_SC_ARCHER
}

static void MM_SC_ARCHER_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MM_SC_MID_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_SC_ARCHER_down_press(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `DOWN_PRESS` event.
    
    // MM_SC_ARCHER behavior
    // uml: DOWN_PRESS TransitionTo(MM_SC_WIZARD)
    if (true)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Avoid exit-while-loop here because we know that the active leaf state is MM_SC_ARCHER and it is the only state being exited at this point.
        MM_SC_ARCHER_exit(self);
        
        // Enter towards target
        MM_SC_WIZARD_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_MM_SC_WIZARD;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for MM_SC_ARCHER
}

static void MM_SC_ARCHER_up_press(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `UP_PRESS` event.
    
    // MM_SC_ARCHER behavior
    // uml: UP_PRESS TransitionTo(MM_SC_HEAVY)
    if (true)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Avoid exit-while-loop here because we know that the active leaf state is MM_SC_ARCHER and it is the only state being exited at this point.
        MM_SC_ARCHER_exit(self);
        
        // Enter towards target
        MM_SC_HEAVY_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_MM_SC_HEAVY;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for MM_SC_ARCHER
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_SC_HEAVY
////////////////////////////////////////////////////////////////////////////////

static void MM_SC_HEAVY_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_SC_HEAVY_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = MM_SC_HEAVY_down_press;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = MM_SC_HEAVY_up_press;
    
    // MM_SC_HEAVY behavior
    // uml: enter / { Display_menu_option("HEAVY");\nset_option_class(HEAVY); }
    if (true)
    {
        Display_menu_option("HEAVY");
        self->vars.option_value = PlayerClass_HEAVY;
    } // end of behavior for MM_SC_HEAVY
}

static void MM_SC_HEAVY_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MM_SC_MID_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_SC_HEAVY_down_press(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `DOWN_PRESS` event.
    
    // MM_SC_HEAVY behavior
    // uml: DOWN_PRESS TransitionTo(MM_SC_ARCHER)
    if (true)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Avoid exit-while-loop here because we know that the active leaf state is MM_SC_HEAVY and it is the only state being exited at this point.
        MM_SC_HEAVY_exit(self);
        
        // Enter towards target
        MM_SC_ARCHER_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_MM_SC_ARCHER;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for MM_SC_HEAVY
}

static void MM_SC_HEAVY_up_press(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `UP_PRESS` event.
    
    // MM_SC_HEAVY behavior
    // uml: UP_PRESS TransitionTo(MM_SC_ENGINEER)
    if (true)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // At this point, StateSmith doesn't know what the active leaf state is. It could be MM_SC_HEAVY or one of its sub states.
        exit_up_to_state_handler(self, MM_SELECT_CLASS_exit);  // Exit until we reach MM_SELECT_CLASS state.
        
        // Enter towards target
        MM_SC_ENGINEER_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_MM_SC_ENGINEER;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for MM_SC_HEAVY
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_SC_WIZARD
////////////////////////////////////////////////////////////////////////////////

static void MM_SC_WIZARD_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_SC_WIZARD_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = MM_SC_WIZARD_down_press;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = MM_SC_WIZARD_up_press;
    
    // MM_SC_WIZARD behavior
    // uml: enter / { set_menu_option_and_class(WIZARD); }
    if (true)
    {
        Display_menu_option("WIZARD"); self->vars.option_value = PlayerClass_WIZARD;
    } // end of behavior for MM_SC_WIZARD
}

static void MM_SC_WIZARD_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MM_SC_MID_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_SC_WIZARD_down_press(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `DOWN_PRESS` event.
    
    // MM_SC_WIZARD behavior
    // uml: DOWN_PRESS TransitionTo(MM_SC_SPY)
    if (true)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // At this point, StateSmith doesn't know what the active leaf state is. It could be MM_SC_WIZARD or one of its sub states.
        exit_up_to_state_handler(self, MM_SELECT_CLASS_exit);  // Exit until we reach MM_SELECT_CLASS state.
        
        // Enter towards target
        MM_SC_SPY_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_MM_SC_SPY;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for MM_SC_WIZARD
}

static void MM_SC_WIZARD_up_press(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `UP_PRESS` event.
    
    // MM_SC_WIZARD behavior
    // uml: UP_PRESS TransitionTo(MM_SC_ARCHER)
    if (true)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Avoid exit-while-loop here because we know that the active leaf state is MM_SC_WIZARD and it is the only state being exited at this point.
        MM_SC_WIZARD_exit(self);
        
        // Enter towards target
        MM_SC_ARCHER_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_MM_SC_ARCHER;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for MM_SC_WIZARD
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_SC_SPY
////////////////////////////////////////////////////////////////////////////////

static void MM_SC_SPY_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_SC_SPY_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = MM_SC_SPY_up_press;
    
    // MM_SC_SPY behavior
    // uml: enter / { set_menu_option_and_class(SPY);\nmenu_at_bottom(); }
    if (true)
    {
        Display_menu_option("SPY"); self->vars.option_value = PlayerClass_SPY;
        Display_menu_at_bottom();
    } // end of behavior for MM_SC_SPY
}

static void MM_SC_SPY_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MM_SELECT_CLASS_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_SC_SPY_up_press(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `UP_PRESS` event.
    
    // MM_SC_SPY behavior
    // uml: UP_PRESS TransitionTo(MM_SC_WIZARD)
    if (true)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Avoid exit-while-loop here because we know that the active leaf state is MM_SC_SPY and it is the only state being exited at this point.
        MM_SC_SPY_exit(self);
        
        // Enter towards target
        MM_SC_MID_enter(self);
        MM_SC_WIZARD_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_MM_SC_WIZARD;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for MM_SC_SPY
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_SHOW_INFO
////////////////////////////////////////////////////////////////////////////////

static void MM_SHOW_INFO_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_SHOW_INFO_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_PRESS] = MM_SHOW_INFO_back_press;
}

static void MM_SHOW_INFO_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MENUS_GROUP_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_PRESS] = MENUS_GROUP_back_press;  // the next ancestor that handles this event is MENUS_GROUP
}

static void MM_SHOW_INFO_back_press(LaserTagMenu1Sm* self)
{
    // Setup handler for next ancestor that listens to `BACK_PRESS` event.
    self->ancestor_event_handler = MENUS_GROUP_back_press;
    
    // MM_SHOW_INFO behavior
    // uml: BACK_PRESS TransitionTo(MM_SHOW_INFO_OPTION)
    if (true)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // At this point, StateSmith doesn't know what the active leaf state is. It could be MM_SHOW_INFO or one of its sub states.
        exit_up_to_state_handler(self, MENUS_GROUP_exit);  // Exit until we reach MENUS_GROUP state.
        
        // Enter towards target
        MAIN_MENU_enter(self);
        MM_SHOW_INFO_OPTION_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_MM_SHOW_INFO_OPTION;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for MM_SHOW_INFO
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_SHOW_INFO_1
////////////////////////////////////////////////////////////////////////////////

static void MM_SHOW_INFO_1_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_SHOW_INFO_1_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = MM_SHOW_INFO_1_do;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = MM_SHOW_INFO_1_down_press;
    
    // MM_SHOW_INFO_1 behavior
    // uml: enter / { Display_top_line("INFO 1 LINE 1");\nDisplay_bot_line("INFO 1 LINE 2");\nreset_timer1(); }
    if (true)
    {
        Display_top_line("INFO 1 LINE 1");
        Display_bot_line("INFO 1 LINE 2");
        self->vars.timer1_started_at_ms = PortApi_get_time_ms();
    } // end of behavior for MM_SHOW_INFO_1
}

static void MM_SHOW_INFO_1_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MM_SHOW_INFO_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_SHOW_INFO_1_do(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `do` event.
    
    // MM_SHOW_INFO_1 behavior
    // uml: do [info_timed_out] TransitionTo(MM_SHOW_INFO_2)
    if ((( (PortApi_get_time_ms() - self->vars.timer1_started_at_ms) >= 3000 )))
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Avoid exit-while-loop here because we know that the active leaf state is MM_SHOW_INFO_1 and it is the only state being exited at this point.
        MM_SHOW_INFO_1_exit(self);
        
        // Enter towards target
        MM_SHOW_INFO_2_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_MM_SHOW_INFO_2;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for MM_SHOW_INFO_1
}

static void MM_SHOW_INFO_1_down_press(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `DOWN_PRESS` event.
    
    // MM_SHOW_INFO_1 behavior
    // uml: DOWN_PRESS TransitionTo(MM_SHOW_INFO_2)
    if (true)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Avoid exit-while-loop here because we know that the active leaf state is MM_SHOW_INFO_1 and it is the only state being exited at this point.
        MM_SHOW_INFO_1_exit(self);
        
        // Enter towards target
        MM_SHOW_INFO_2_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_MM_SHOW_INFO_2;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for MM_SHOW_INFO_1
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_SHOW_INFO_2
////////////////////////////////////////////////////////////////////////////////

static void MM_SHOW_INFO_2_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_SHOW_INFO_2_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = MM_SHOW_INFO_2_do;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = MM_SHOW_INFO_2_down_press;
    
    // MM_SHOW_INFO_2 behavior
    // uml: enter / { Display_top_line("INFO 2 LINE 1");\nDisplay_bot_line("INFO 2 LINE 2");\nreset_timer1(); }
    if (true)
    {
        Display_top_line("INFO 2 LINE 1");
        Display_bot_line("INFO 2 LINE 2");
        self->vars.timer1_started_at_ms = PortApi_get_time_ms();
    } // end of behavior for MM_SHOW_INFO_2
}

static void MM_SHOW_INFO_2_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MM_SHOW_INFO_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_SHOW_INFO_2_do(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `do` event.
    
    // MM_SHOW_INFO_2 behavior
    // uml: do [info_timed_out] TransitionTo(MM_SHOW_INFO_3)
    if ((( (PortApi_get_time_ms() - self->vars.timer1_started_at_ms) >= 3000 )))
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Avoid exit-while-loop here because we know that the active leaf state is MM_SHOW_INFO_2 and it is the only state being exited at this point.
        MM_SHOW_INFO_2_exit(self);
        
        // Enter towards target
        MM_SHOW_INFO_3_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_MM_SHOW_INFO_3;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for MM_SHOW_INFO_2
}

static void MM_SHOW_INFO_2_down_press(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `DOWN_PRESS` event.
    
    // MM_SHOW_INFO_2 behavior
    // uml: DOWN_PRESS TransitionTo(MM_SHOW_INFO_3)
    if (true)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Avoid exit-while-loop here because we know that the active leaf state is MM_SHOW_INFO_2 and it is the only state being exited at this point.
        MM_SHOW_INFO_2_exit(self);
        
        // Enter towards target
        MM_SHOW_INFO_3_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_MM_SHOW_INFO_3;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for MM_SHOW_INFO_2
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_SHOW_INFO_3
////////////////////////////////////////////////////////////////////////////////

static void MM_SHOW_INFO_3_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_SHOW_INFO_3_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = MM_SHOW_INFO_3_do;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = MM_SHOW_INFO_3_down_press;
    
    // MM_SHOW_INFO_3 behavior
    // uml: enter / { Display_top_line("INFO 3 LINE 1");\nDisplay_bot_line("INFO 3 LINE 2");\nreset_timer1(); }
    if (true)
    {
        Display_top_line("INFO 3 LINE 1");
        Display_bot_line("INFO 3 LINE 2");
        self->vars.timer1_started_at_ms = PortApi_get_time_ms();
    } // end of behavior for MM_SHOW_INFO_3
}

static void MM_SHOW_INFO_3_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MM_SHOW_INFO_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_SHOW_INFO_3_do(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `do` event.
    
    // MM_SHOW_INFO_3 behavior
    // uml: do [info_timed_out] TransitionTo(MM_SHOW_INFO_1)
    if ((( (PortApi_get_time_ms() - self->vars.timer1_started_at_ms) >= 3000 )))
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Avoid exit-while-loop here because we know that the active leaf state is MM_SHOW_INFO_3 and it is the only state being exited at this point.
        MM_SHOW_INFO_3_exit(self);
        
        // Enter towards target
        MM_SHOW_INFO_1_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_MM_SHOW_INFO_1;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for MM_SHOW_INFO_3
}

static void MM_SHOW_INFO_3_down_press(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `DOWN_PRESS` event.
    
    // MM_SHOW_INFO_3 behavior
    // uml: DOWN_PRESS TransitionTo(MM_SHOW_INFO_1)
    if (true)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Avoid exit-while-loop here because we know that the active leaf state is MM_SHOW_INFO_3 and it is the only state being exited at this point.
        MM_SHOW_INFO_3_exit(self);
        
        // Enter towards target
        MM_SHOW_INFO_1_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_MM_SHOW_INFO_1;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for MM_SHOW_INFO_3
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state WELCOME_SCREEN
////////////////////////////////////////////////////////////////////////////////

static void WELCOME_SCREEN_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = WELCOME_SCREEN_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = WELCOME_SCREEN_do;
    
    // WELCOME_SCREEN behavior
    // uml: enter / { Display_top_line("WELCOME!"); }
    if (true)
    {
        Display_top_line("WELCOME!");
    } // end of behavior for WELCOME_SCREEN
    
    // WELCOME_SCREEN behavior
    // uml: enter / { reset_timer1(); }
    if (true)
    {
        self->vars.timer1_started_at_ms = PortApi_get_time_ms();
    } // end of behavior for WELCOME_SCREEN
}

static void WELCOME_SCREEN_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void WELCOME_SCREEN_do(LaserTagMenu1Sm* self)
{
    // No ancestor state handles `do` event.
    
    // WELCOME_SCREEN behavior
    // uml: do [after_timer1_ms(2500)] TransitionTo(HOME)
    if (( (PortApi_get_time_ms() - self->vars.timer1_started_at_ms) >= 2500 ))
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Avoid exit-while-loop here because we know that the active leaf state is WELCOME_SCREEN and it is the only state being exited at this point.
        WELCOME_SCREEN_exit(self);
        
        // Enter towards target
        HOME_enter(self);
        
        // HOME.InitialState behavior
        // uml: TransitionTo(HOME1)
        if (true)
        {
            
            // Enter towards target
            HOME1_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_HOME1;
            self->ancestor_event_handler = NULL;
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for HOME.InitialState
    } // end of behavior for WELCOME_SCREEN
}


