<!-- 
  -- This file was generated by StateSmith.
  -- Note! The generated state machine code in this file has been specially instrumented to support simulator features.
  -- Regular generated javascript state machine code is smaller and simpler.
  -->
<html>
  <head>
    <link rel='icon' type='image/png' href='https://statesmith.github.io/favicon.png'>

      <!-- The below css makes the titlebar-icon functionality work. See https://fonts.google.com/icons -->
    <link rel='stylesheet' href='https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined'>

    <style>
      body {
        display: flex;
        flex-direction: row;
        margin: 0px;
        color: #cacad1;
        font-family: 'Arial';
        font-size: 13px;
      }

      code {
        font-family: monospace;
        color:aquamarine;
        white-space: pre;
      }

      .identifier {
        color: #9bc2e4;
      }

      /* Fix for mermaid content requiring scroll bars https://github.com/StateSmith/StateSmith/issues/288 */
      pre.mermaid {
        margin: 0px;
      }

      #event-logs a {
        text-decoration: none;
        color: inherit;
      }

      .wrapper {
        height: 100vh;
        width: 100vw;
        display: flex;
      }

      .pane {
        padding: 1em;
        min-width: 200px;
      }

      .titlebar-icon {
        font-family: 'Material Symbols Outlined', sans-serif;
        font-size: 16px;
        color: #b4b4b4;
        border-radius: 5px;
      }

      .gutter {
        width: 10px;
        height: 100%;
        background: #ccc;
        position: absolute;
        top: 0;
        left: 0;
        cursor: col-resize;
      }

      .main {
        flex: 1;
        overflow: auto;
        padding: 10px;
        background-color: #1E222A; /* Dark theme */
      }

      .sidebar {
        width: 300px;
        padding-top: 0px;
        position: relative;
        background-color: #30394b;
        border-left: 1px solid #ccc;
        display: flex;
        flex-direction: column;
      }

      #buttons {
        display: flex;
        flex-direction: column;
      }

      .titlebar {
        background-color: #1d222e;
        border-bottom: 1px solid #454f64;
        font-weight: bold;
        padding: 5px;
        display: flex;
      }

      .console {
        border-collapse: collapse;
        margin-top: 10px;
        width: 100%;
      }

      table.console td.timestamp {
        display: none;
      }

      table.console.timestamps td.timestamp {
        display: table-cell;
      }

      table.console td {
          color: inherit;
      }

      table.console td .dispatched {
          font-weight: bold;
          color: #dbdbdb;
      }

      table.console tr:has(+tr td .dispatched) {
          border-bottom: 0px;
      }

      table.console tr:has(+tr td .dispatched) td {
          padding-bottom: 25px;
      }

      .console tbody {
        font-family: monospace;
      }

      .console tr {
        border-bottom: 1px solid #596275;
      }

      .console td {
        padding: 5px;
      }
  
      .console td.timestamp {
        font-size: small;
      }

      #event-logs {
        margin-top: 30px;       
        display: flex;
        overflow: auto;    
        flex-direction: column-reverse;
      }

      .console tr:last-child td {
        border-bottom: none;
      }

      .dispatched {
        font-weight: bold;
      }

      .dispatched .event-id {
        border: 1px solid #000;
        border-radius: 4px;
        padding: 2px 4px;
      }

      .dispatched .forced-state {
        border: 1px solid #000;
        /* color: white; */
        color: #252541;
        background-color: #E06C75;
        border-radius: 4px;
        padding: 2px 4px;
      }

      button {
        margin: 5px;
      }

      button.event-button, .event-id {
        /* background-color: #4e98d4;
        color: #252541; */
        background-color: #08487c;
        color: #e9f5ff;
      }

      button.event-button {
        transition: opacity 0.3s ease, background-color 0.3s ease;
        opacity: 1;
        cursor: pointer;
      }

      button.event-button.hasNoEventHandler {
        opacity: 0.4;
        background-color: #f0f0f0;
        color: #2b2b30;
        cursor: not-allowed;
      }

      button.event-button:not(.hasNoEventHandler):hover {
        background-color: #00559b;
      }

      /* Style for hiding irrelevant events */
      button.event-button.hidden {
        display: none;
      }



      /* ----------------------------- Dropdown related start ----------------------------- */
      
      .dropdown-button {
        border: none;
        cursor: pointer;
        user-select: none;
      }
      
      .dropdown-button:hover, .dropdown-button:focus {
        background-color: aquamarine;
        color: #000;
      }
      
      .dropdown {
        position: relative;
        display: inline-block;
        margin-left: auto;
      }
      
      .dropdown-content {
        display: none;
        position: absolute;
        right: 0;
        background-color: #24253c;
        min-width: 250px;
        overflow: auto;
        box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
        z-index: 1;
      }
      
      .dropdown-content .dropdown-item {
        display: block;
        padding: 12px 16px;
        font-weight: normal;
      }

      .dropdown-content .dropdown-item:hover {
        background-color: #333786;
        cursor: pointer;
      }

      .show {
        display: block;
      }

      /* ----------------------------- Dropdown related end ----------------------------- */

      .transition {
        stroke-width: 2px !important;
      }

      .transition.available {
        stroke: #7e70cf !important;
        /* stroke: #4e98d4 !important; */
        stroke-width: 4px !important;
        filter: drop-shadow( 2px 2px 1px rgba(0, 0, 0, .7));
      }

      .transition.active {
        stroke: #E06C75 !important;
        stroke-width: 5px !important;
        filter: drop-shadow( 3px 3px 2px rgba(0, 0, 0, .7));
      }

      .statediagram-state.active > * {
        fill: #4e98d4 !important;
        stroke: #00559b !important;
        stroke-width: 2px !important;
      }

      .statediagram-state.active span.nodeLabel {
        color: #000d53 !important;
      }

      /* we don't want to fill body of parent state with regular active yellow. It's just too much! */
      .statediagram-state.active rect.inner {
        fill: #444  !important;
        stroke-width: 2px !important;
      }

      .clickableDiagramElement {
        cursor: pointer;
      }

      span.edgeLabel.clickableDiagramElement:hover {
        color: aquamarine !important;
      }

      span.nodeLabel.clickableDiagramElement:hover {
        color: aquamarine !important;
      }

    </style>
  </head>

  <body>
    <div class='wrapper'>
    <div class='pane main'>
        <!-- mermaid themes: default, dark, forest, neutral, base https://mermaid.ai/open-source/config/theming.html -->
        <pre class='mermaid'>
---

config:
    theme: 'base'
    themeVariables:
        primaryColor: '#1f2020'
        primaryTextColor: '#f0f0f0'
        background: '#333'
        primaryBorderColor: '#888888'
        lineColor: '#999'

---

stateDiagram

%% Initial state name as "." so that it fits in black circle shape.
%% See https://github.com/StateSmith/StateSmith/issues/404
state "." as ROOT.(InitialState)

SPLASH_SCREEN

SPLASH_SCREEN : SPLASH_SCREEN

SPLASH_SCREEN : enter / #123; ShowSplashScreen()#59; #125;

DONE

DONE : DONE

DONE : enter / #123; ShowDoneScreen()#59; #125;

state MENU {

        state MAIN_MENU_INNER {

                %% Initial state name as "." so that it fits in black circle shape.
                %% See https://github.com/StateSmith/StateSmith/issues/404
                state "." as MAIN_MENU_INNER.(InitialState)

                DRINK

                DRINK : DRINK

                DRINK : enter / #123; MenuOption("Select Drink")#59; #125;

                FOOD

                FOOD : FOOD

                FOOD : enter / #123; MenuOption("Select Food")#59; #125;

                FOOD : (UP, PG_UP) / #123; Beep()#59; #125;

                SYSTEM_INFO

                SYSTEM_INFO : SYSTEM_INFO

                SYSTEM_INFO : enter / #123; MenuOption("System Info")#59; #125;

                SYSTEM_INFO : (DOWN, PG_DOWN) / #123; Beep()#59; #125;

        }

        state ESC_CATCHER_1 {

                DRINK_MENU

                DRINK_MENU : DRINK_MENU

                DRINK_MENU : enter / #123; MenuHeader("Coffee System Offline")#59;\nMenuOption("Activate self destruct?")#59; #125;

                state FOOD_MENU {

                        EAT_BURRITO

                        EAT_BURRITO : EAT_BURRITO

                        EAT_BURRITO : enter / #123; MenuOption("Big Fat Burrito")#59; #125;

                        %% Initial state name as "." so that it fits in black circle shape.
                        %% See https://github.com/StateSmith/StateSmith/issues/404
                        state "." as FOOD_MENU.(InitialState)

                        EAT_SLUDGE

                        EAT_SLUDGE : EAT_SLUDGE

                        EAT_SLUDGE : enter / #123; MenuOption("Nutrient Mush")#59; #125;

                        EAT_MRE

                        EAT_MRE : EAT_MRE

                        EAT_MRE : enter / #123; MenuOption("MRE")#59; #125;

                        state "$exit_pt.food_selected" as FOOD_MENU.(ExitPoint)(food_selected)

                        state EVENT_EATER_2 {

                                COOKING_FOOD1

                                COOKING_FOOD1 : COOKING_FOOD1

                                COOKING_FOOD1 : enter / #123; t1Restart()#59; #125;

                                COOKING_FOOD1 : enter / #123; MenuHeader("Mush...")#59; #125;

                                COOKING_FOOD1 : enter / #123; MenuOption("Gross...")#59; #125;

                                COOKING_FOOD

                                COOKING_FOOD : COOKING_FOOD

                                COOKING_FOOD : enter / #123; t1Restart()#59;\nMenuHeader("Cooking Food")#59;\nMenuOption("...")#59; #125;

                        }

                }

                state SYSTEM_INFO_MENU {

                        BURRITO_COUNT

                        BURRITO_COUNT : BURRITO_COUNT

                        BURRITO_COUNT : enter / #123; MenuOption("Burrito count#58#59; " + burritoCount)#59; #125;

                        DISTANCE

                        DISTANCE : DISTANCE

                        DISTANCE : enter / #123; MenuOption("Distance to Tau Ceti#58#59; " + distance)#59; #125;

                        DISTANCE : (UP, PG_UP) / #123; Beep()#59; #125;

                        SELF_DESTRUCT_OPTION

                        SELF_DESTRUCT_OPTION : SELF_DESTRUCT_OPTION

                        SELF_DESTRUCT_OPTION : enter / #123; count = 0#59;\nMenuOption("Self Destruct?")#59; #125;

                        SELF_DESTRUCT_OPTION : 1. RIGHT / #123; count++#59; Beep()#59; #125;

                        SELF_DESTRUCT_OPTION : (DOWN, PG_DOWN) / #123; Beep()#59; #125;

                        %% Initial state name as "." so that it fits in black circle shape.
                        %% See https://github.com/StateSmith/StateSmith/issues/404
                        state "." as SYSTEM_INFO_MENU.(InitialState)

                        state "$entry_pt.self_destruct" as SYSTEM_INFO_MENU.(EntryPoint)(self_destruct)

                        state SELF_DESTRUCT {

                                SD_1

                                SD_1 : SD_1

                                SD_1 : enter / #123; Beep()#59; #125;

                                SD_1 : enter / #123; t1.Restart()#59; #125;

                                SD_1 : enter / #123; MenuHeader($"SELF DESTRUCT IN " + SelfDestructSeconds)#59; #125;

                                SD_1 : DO [SelfDestructSeconds <= 0] / #123; SelfDestruct()#59; #125;

                                %% Initial state name as "." so that it fits in black circle shape.
                                %% See https://github.com/StateSmith/StateSmith/issues/404
                                state "." as SELF_DESTRUCT.(InitialState)

                        }

                }

        }

        %% Initial state name as "." so that it fits in black circle shape.
        %% See https://github.com/StateSmith/StateSmith/issues/404
        state "." as MENU.(InitialState)

}

ROOT.(InitialState) --> SPLASH_SCREEN

SPLASH_SCREEN --> MENU : RIGHT

MENU --> DONE : ESC

MAIN_MENU_INNER --> SYSTEM_INFO : PG_DOWN

MAIN_MENU_INNER --> FOOD : PG_UP

MAIN_MENU_INNER.(InitialState) --> FOOD

DRINK --> SYSTEM_INFO : DOWN

DRINK --> FOOD : UP

DRINK --> DRINK_MENU : RIGHT

FOOD --> FOOD_MENU : RIGHT

FOOD --> DRINK : DOWN

SYSTEM_INFO --> SYSTEM_INFO_MENU : RIGHT

SYSTEM_INFO --> DRINK : UP

ESC_CATCHER_1 --> MAIN_MENU_INNER : ESC

DRINK_MENU --> DRINK : LEFT

DRINK_MENU --> SYSTEM_INFO_MENU.(EntryPoint)(self_destruct) : RIGHT

FOOD_MENU --> FOOD : LEFT

EAT_BURRITO --> EAT_SLUDGE : DOWN

EAT_BURRITO --> COOKING_FOOD : RIGHT / #123; burritoCount--#59; #125;

FOOD_MENU.(InitialState) --> EAT_BURRITO

EAT_SLUDGE --> EAT_MRE : DOWN

EAT_SLUDGE --> EAT_BURRITO : UP

EAT_SLUDGE --> COOKING_FOOD1 : RIGHT

EAT_MRE --> EAT_SLUDGE : UP

EAT_MRE --> COOKING_FOOD : RIGHT

FOOD_MENU.(ExitPoint)(food_selected) --> FOOD

COOKING_FOOD1 --> COOKING_FOOD : do [t1After( 1s )]

COOKING_FOOD --> FOOD_MENU.(ExitPoint)(food_selected) : do [t1After( 3.5 s )]

SYSTEM_INFO_MENU --> SYSTEM_INFO : LEFT

SYSTEM_INFO_MENU --> SELF_DESTRUCT_OPTION : PG_DOWN

SYSTEM_INFO_MENU --> DISTANCE : PG_UP

BURRITO_COUNT --> SELF_DESTRUCT_OPTION : DOWN

BURRITO_COUNT --> DISTANCE : UP

DISTANCE --> BURRITO_COUNT : DOWN

SELF_DESTRUCT_OPTION --> BURRITO_COUNT : UP

SELF_DESTRUCT_OPTION --> SELF_DESTRUCT : RIGHT [count >= 5]

SYSTEM_INFO_MENU.(InitialState) --> DISTANCE : / #123; MenuHeader("System Info")#59; #125;

SYSTEM_INFO_MENU.(EntryPoint)(self_destruct) --> SELF_DESTRUCT

SD_1 --> SD_1 : do [t1.Elapsed.Seconds >= 1]

SELF_DESTRUCT.(InitialState) --> SD_1

MENU.(InitialState) --> MAIN_MENU_INNER



        </pre>
    </div>

    <div class='pane sidebar'>
      <div id='buttons'>
        <div class='titlebar'>Events
          <div class='dropdown'>
            <span id='settings-dropdown-button' class='titlebar-icon dropdown-button' title='Settings'>settings</span>
            <span id='clear-button' class='titlebar-icon dropdown-button' title='Clear event log'>delete</span>
            <a href='https://github.com/StateSmith/StateSmith/wiki/Simulator' id='help-button' class='titlebar-icon dropdown-button' target='_blank' title='CHECK THIS!&#10;The simulator has a number of quirks and limitations&#10;that you should be aware of.'>help</a>
            <div id='myDropdown' class='dropdown-content'>

              <!-- 
                NOTE! Try not to change the ids of input checkboxes below as that will reset user preferences stored in localStorage.
                NOTE! New settings will be automatically picked up if they start with 'savedSetting_' and are checkboxes.
               -->

              <label class='dropdown-item' for='savedSetting_hideIrrelevantEvents'
                title='When enabled, event dispatching buttons will be hidden if the current active state(s) ignore the event.'>
                <input type='checkbox' id='savedSetting_hideIrrelevantEvents' name='savedSetting_hideIrrelevantEvents'>
                Hide ignored event buttons
              </label>
              <label class='dropdown-item' for='savedSetting_verboseEnter'
                title='Every time a state is entered, it will be logged below in the event log.'>
                <input type='checkbox' id='savedSetting_verboseEnter' name='savedSetting_verboseEnter' checked>
                Log State Entry
              </label>
              <label class='dropdown-item' for='savedSetting_verboseExit'
                title='Every time a state is exited, it will be logged below in the event log.'>
                <input type='checkbox' id='savedSetting_verboseExit' name='savedSetting_verboseExit' checked>
                Log State Exit
              </label>
              <label class='dropdown-item' for='savedSetting_verboseHistory'
                title='Log history pseudo state variable updates'>
                <input type='checkbox' id='savedSetting_verboseHistory' name='savedSetting_verboseHistory' checked>
                Log History Variables
              </label>
              <label class='dropdown-item' for='savedSetting_showEventButtonTooltips'
                 title='Event dispatching buttons will have tooltips with additional info.&#10;ðŸ“¢ NOTE! Changes to this setting take effect on state change or page reload.'>
                <input type='checkbox' id='savedSetting_showEventButtonTooltips' name='savedSetting_showEventButtonTooltips' checked>
                Show event button tooltips
              </label>
              <!-- setting for requiring CTRL to held while clicking to force state -->
                <label class='dropdown-item' for='savedSetting_requireCtrlForForceState'
                    title='CTRL key must be held while clicking a state to force it.&#10;This can help prevent accidental forced state changes.'>
                    <input type='checkbox' id='savedSetting_requireCtrlForForceState' name='savedSetting_requireCtrlForForceState'>
                    Require CTRL to force state
                </label>
              <label class='dropdown-item' for='savedSetting_timestamps'
                title='Controls whether timestamps are shown along side event dispatches.'>
                <input type='checkbox' id='savedSetting_timestamps' name='savedSetting_timestamps'>
                Timestamps
              </label>
            </div>
          </div>
        </div>
      </div>
    
      <div id='event-logs'>
        <table class='console'>
          <tbody>
          </tbody>
        </table>
      </div>
    
      <div class='gutter'></div>
    </div>
    </div>

<script>
// Autogenerated with StateSmith.
// Algorithm: Balanced2. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

// Generated state machine
class SpaceControlUiSm
{
// Null by default.
// May be overridden to override guard evaluation (eg. in a simulator)
evaluateGuard = null;
    static EventId = 
    {
        DO : 0, // The `do` event is special. State event handlers do not consume this event (ancestors all get it too) unless a transition occurs.
        DOWN : 1,
        ESC : 2,
        LEFT : 3,
        PG_DOWN : 4,
        PG_UP : 5,
        RIGHT : 6,
        UP : 7,
    }
    static { Object.freeze(this.EventId); }
    
    static EventIdCount = 8;
    static { Object.freeze(this.EventIdCount); }
    
    static StateId = 
    {
        ROOT : 0,
        DONE : 1,
        MENU : 2,
        ESC_CATCHER_1 : 3,
        DRINK_MENU : 4,
        FOOD_MENU : 5,
        EAT_BURRITO : 6,
        EAT_MRE : 7,
        EAT_SLUDGE : 8,
        EVENT_EATER_2 : 9,
        COOKING_FOOD : 10,
        COOKING_FOOD1 : 11,
        SYSTEM_INFO_MENU : 12,
        BURRITO_COUNT : 13,
        DISTANCE : 14,
        SELF_DESTRUCT : 15,
        SD_1 : 16,
        SELF_DESTRUCT_OPTION : 17,
        MAIN_MENU_INNER : 18,
        DRINK : 19,
        FOOD : 20,
        SYSTEM_INFO : 21,
        SPLASH_SCREEN : 22,
    }
    static { Object.freeze(this.StateId); }
    
    static StateIdCount = 23;
    static { Object.freeze(this.StateIdCount); }
    
    // Used internally by state machine. Feel free to inspect, but don't modify.
    stateId;
    
    // Starts the state machine. Must be called before dispatching events. Not thread safe.
    start()
    {
        this._ROOT_enter();
        // ROOT behavior
        // uml: TransitionTo(ROOT.<InitialState>)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
            // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.
            
            // ROOT.<InitialState> behavior
            // uml: / { this.tracer?.edgeTransition('edge0'); } TransitionTo(SPLASH_SCREEN)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.edgeTransition('edge0');`.
                this.tracer?.edgeTransition('edge0');
                
                // Step 3: Enter/move towards transition target `SPLASH_SCREEN`.
                this._SPLASH_SCREEN_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for ROOT.<InitialState>
        } // end of behavior for ROOT
    }
    
    // Dispatches an event to the state machine. Not thread safe.
    // Note! This function assumes that the `eventId` parameter is valid.
    dispatchEvent(eventId)
    {
        switch (this.stateId)
        {
            // STATE: SpaceControlUiSm
            case SpaceControlUiSm.StateId.ROOT:
                // No events handled by this state (or its ancestors).
                break;
            
            // STATE: DONE
            case SpaceControlUiSm.StateId.DONE:
                // No events handled by this state (or its ancestors).
                break;
            
            // STATE: MENU
            case SpaceControlUiSm.StateId.MENU:
                switch (eventId)
                {
                    case SpaceControlUiSm.EventId.ESC: this._MENU_esc(); break;
                }
                break;
            
            // STATE: ESC_CATCHER_1
            case SpaceControlUiSm.StateId.ESC_CATCHER_1:
                switch (eventId)
                {
                    case SpaceControlUiSm.EventId.ESC: this._ESC_CATCHER_1_esc(); break;
                }
                break;
            
            // STATE: DRINK_MENU
            case SpaceControlUiSm.StateId.DRINK_MENU:
                switch (eventId)
                {
                    case SpaceControlUiSm.EventId.LEFT: this._DRINK_MENU_left(); break;
                    case SpaceControlUiSm.EventId.RIGHT: this._DRINK_MENU_right(); break;
                    case SpaceControlUiSm.EventId.ESC: this._ESC_CATCHER_1_esc(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: FOOD_MENU
            case SpaceControlUiSm.StateId.FOOD_MENU:
                switch (eventId)
                {
                    case SpaceControlUiSm.EventId.LEFT: this._FOOD_MENU_left(); break;
                    case SpaceControlUiSm.EventId.ESC: this._ESC_CATCHER_1_esc(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: EAT_BURRITO
            case SpaceControlUiSm.StateId.EAT_BURRITO:
                switch (eventId)
                {
                    case SpaceControlUiSm.EventId.DOWN: this._EAT_BURRITO_down(); break;
                    case SpaceControlUiSm.EventId.RIGHT: this._EAT_BURRITO_right(); break;
                    case SpaceControlUiSm.EventId.ESC: this._ESC_CATCHER_1_esc(); break; // First ancestor handler for this event
                    case SpaceControlUiSm.EventId.LEFT: this._FOOD_MENU_left(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: EAT_MRE
            case SpaceControlUiSm.StateId.EAT_MRE:
                switch (eventId)
                {
                    case SpaceControlUiSm.EventId.UP: this._EAT_MRE_up(); break;
                    case SpaceControlUiSm.EventId.RIGHT: this._EAT_MRE_right(); break;
                    case SpaceControlUiSm.EventId.ESC: this._ESC_CATCHER_1_esc(); break; // First ancestor handler for this event
                    case SpaceControlUiSm.EventId.LEFT: this._FOOD_MENU_left(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: EAT_SLUDGE
            case SpaceControlUiSm.StateId.EAT_SLUDGE:
                switch (eventId)
                {
                    case SpaceControlUiSm.EventId.DOWN: this._EAT_SLUDGE_down(); break;
                    case SpaceControlUiSm.EventId.UP: this._EAT_SLUDGE_up(); break;
                    case SpaceControlUiSm.EventId.RIGHT: this._EAT_SLUDGE_right(); break;
                    case SpaceControlUiSm.EventId.ESC: this._ESC_CATCHER_1_esc(); break; // First ancestor handler for this event
                    case SpaceControlUiSm.EventId.LEFT: this._FOOD_MENU_left(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: EVENT_EATER_2
            case SpaceControlUiSm.StateId.EVENT_EATER_2:
                switch (eventId)
                {
                    case SpaceControlUiSm.EventId.LEFT: this._EVENT_EATER_2_left(); break;
                    case SpaceControlUiSm.EventId.ESC: this._EVENT_EATER_2_esc(); break;
                }
                break;
            
            // STATE: COOKING_FOOD
            case SpaceControlUiSm.StateId.COOKING_FOOD:
                switch (eventId)
                {
                    case SpaceControlUiSm.EventId.DO: this._COOKING_FOOD_do(); break;
                    case SpaceControlUiSm.EventId.ESC: this._EVENT_EATER_2_esc(); break; // First ancestor handler for this event
                    case SpaceControlUiSm.EventId.LEFT: this._EVENT_EATER_2_left(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: COOKING_FOOD1
            case SpaceControlUiSm.StateId.COOKING_FOOD1:
                switch (eventId)
                {
                    case SpaceControlUiSm.EventId.DO: this._COOKING_FOOD1_do(); break;
                    case SpaceControlUiSm.EventId.ESC: this._EVENT_EATER_2_esc(); break; // First ancestor handler for this event
                    case SpaceControlUiSm.EventId.LEFT: this._EVENT_EATER_2_left(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: SYSTEM_INFO_MENU
            case SpaceControlUiSm.StateId.SYSTEM_INFO_MENU:
                switch (eventId)
                {
                    case SpaceControlUiSm.EventId.LEFT: this._SYSTEM_INFO_MENU_left(); break;
                    case SpaceControlUiSm.EventId.PG_DOWN: this._SYSTEM_INFO_MENU_pg_down(); break;
                    case SpaceControlUiSm.EventId.PG_UP: this._SYSTEM_INFO_MENU_pg_up(); break;
                    case SpaceControlUiSm.EventId.ESC: this._ESC_CATCHER_1_esc(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: BURRITO_COUNT
            case SpaceControlUiSm.StateId.BURRITO_COUNT:
                switch (eventId)
                {
                    case SpaceControlUiSm.EventId.DOWN: this._BURRITO_COUNT_down(); break;
                    case SpaceControlUiSm.EventId.UP: this._BURRITO_COUNT_up(); break;
                    case SpaceControlUiSm.EventId.ESC: this._ESC_CATCHER_1_esc(); break; // First ancestor handler for this event
                    case SpaceControlUiSm.EventId.PG_DOWN: this._SYSTEM_INFO_MENU_pg_down(); break; // First ancestor handler for this event
                    case SpaceControlUiSm.EventId.PG_UP: this._SYSTEM_INFO_MENU_pg_up(); break; // First ancestor handler for this event
                    case SpaceControlUiSm.EventId.LEFT: this._SYSTEM_INFO_MENU_left(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: DISTANCE
            case SpaceControlUiSm.StateId.DISTANCE:
                switch (eventId)
                {
                    case SpaceControlUiSm.EventId.UP: this._DISTANCE_up(); break;
                    case SpaceControlUiSm.EventId.PG_UP: this._DISTANCE_pg_up(); break;
                    case SpaceControlUiSm.EventId.DOWN: this._DISTANCE_down(); break;
                    case SpaceControlUiSm.EventId.ESC: this._ESC_CATCHER_1_esc(); break; // First ancestor handler for this event
                    case SpaceControlUiSm.EventId.PG_DOWN: this._SYSTEM_INFO_MENU_pg_down(); break; // First ancestor handler for this event
                    case SpaceControlUiSm.EventId.LEFT: this._SYSTEM_INFO_MENU_left(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: SELF_DESTRUCT
            case SpaceControlUiSm.StateId.SELF_DESTRUCT:
                switch (eventId)
                {
                    case SpaceControlUiSm.EventId.LEFT: this._SELF_DESTRUCT_left(); break;
                    case SpaceControlUiSm.EventId.ESC: this._ESC_CATCHER_1_esc(); break; // First ancestor handler for this event
                    case SpaceControlUiSm.EventId.PG_DOWN: this._SYSTEM_INFO_MENU_pg_down(); break; // First ancestor handler for this event
                    case SpaceControlUiSm.EventId.PG_UP: this._SYSTEM_INFO_MENU_pg_up(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: SD_1
            case SpaceControlUiSm.StateId.SD_1:
                switch (eventId)
                {
                    case SpaceControlUiSm.EventId.DO: this._SD_1_do(); break;
                    case SpaceControlUiSm.EventId.ESC: this._ESC_CATCHER_1_esc(); break; // First ancestor handler for this event
                    case SpaceControlUiSm.EventId.PG_DOWN: this._SYSTEM_INFO_MENU_pg_down(); break; // First ancestor handler for this event
                    case SpaceControlUiSm.EventId.PG_UP: this._SYSTEM_INFO_MENU_pg_up(); break; // First ancestor handler for this event
                    case SpaceControlUiSm.EventId.LEFT: this._SELF_DESTRUCT_left(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: SELF_DESTRUCT_OPTION
            case SpaceControlUiSm.StateId.SELF_DESTRUCT_OPTION:
                switch (eventId)
                {
                    case SpaceControlUiSm.EventId.RIGHT: this._SELF_DESTRUCT_OPTION_right(); break;
                    case SpaceControlUiSm.EventId.DOWN: this._SELF_DESTRUCT_OPTION_down(); break;
                    case SpaceControlUiSm.EventId.PG_DOWN: this._SELF_DESTRUCT_OPTION_pg_down(); break;
                    case SpaceControlUiSm.EventId.UP: this._SELF_DESTRUCT_OPTION_up(); break;
                    case SpaceControlUiSm.EventId.ESC: this._ESC_CATCHER_1_esc(); break; // First ancestor handler for this event
                    case SpaceControlUiSm.EventId.PG_UP: this._SYSTEM_INFO_MENU_pg_up(); break; // First ancestor handler for this event
                    case SpaceControlUiSm.EventId.LEFT: this._SYSTEM_INFO_MENU_left(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: MAIN_MENU_INNER
            case SpaceControlUiSm.StateId.MAIN_MENU_INNER:
                switch (eventId)
                {
                    case SpaceControlUiSm.EventId.PG_DOWN: this._MAIN_MENU_INNER_pg_down(); break;
                    case SpaceControlUiSm.EventId.PG_UP: this._MAIN_MENU_INNER_pg_up(); break;
                    case SpaceControlUiSm.EventId.ESC: this._MENU_esc(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: DRINK
            case SpaceControlUiSm.StateId.DRINK:
                switch (eventId)
                {
                    case SpaceControlUiSm.EventId.DOWN: this._DRINK_down(); break;
                    case SpaceControlUiSm.EventId.UP: this._DRINK_up(); break;
                    case SpaceControlUiSm.EventId.RIGHT: this._DRINK_right(); break;
                    case SpaceControlUiSm.EventId.ESC: this._MENU_esc(); break; // First ancestor handler for this event
                    case SpaceControlUiSm.EventId.PG_DOWN: this._MAIN_MENU_INNER_pg_down(); break; // First ancestor handler for this event
                    case SpaceControlUiSm.EventId.PG_UP: this._MAIN_MENU_INNER_pg_up(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: FOOD
            case SpaceControlUiSm.StateId.FOOD:
                switch (eventId)
                {
                    case SpaceControlUiSm.EventId.UP: this._FOOD_up(); break;
                    case SpaceControlUiSm.EventId.PG_UP: this._FOOD_pg_up(); break;
                    case SpaceControlUiSm.EventId.RIGHT: this._FOOD_right(); break;
                    case SpaceControlUiSm.EventId.DOWN: this._FOOD_down(); break;
                    case SpaceControlUiSm.EventId.ESC: this._MENU_esc(); break; // First ancestor handler for this event
                    case SpaceControlUiSm.EventId.PG_DOWN: this._MAIN_MENU_INNER_pg_down(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: SYSTEM_INFO
            case SpaceControlUiSm.StateId.SYSTEM_INFO:
                switch (eventId)
                {
                    case SpaceControlUiSm.EventId.DOWN: this._SYSTEM_INFO_down(); break;
                    case SpaceControlUiSm.EventId.PG_DOWN: this._SYSTEM_INFO_pg_down(); break;
                    case SpaceControlUiSm.EventId.RIGHT: this._SYSTEM_INFO_right(); break;
                    case SpaceControlUiSm.EventId.UP: this._SYSTEM_INFO_up(); break;
                    case SpaceControlUiSm.EventId.ESC: this._MENU_esc(); break; // First ancestor handler for this event
                    case SpaceControlUiSm.EventId.PG_UP: this._MAIN_MENU_INNER_pg_up(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: SPLASH_SCREEN
            case SpaceControlUiSm.StateId.SPLASH_SCREEN:
                switch (eventId)
                {
                    case SpaceControlUiSm.EventId.RIGHT: this._SPLASH_SCREEN_right(); break;
                }
                break;
        }
        
    }
    
    // This function is used when StateSmith doesn't know what the active leaf state is at
    // compile time due to sub states or when multiple states need to be exited.
    _exitUpToStateHandler(desiredState)
    {
        while (this.stateId != desiredState)
        {
            switch (this.stateId)
            {
                case SpaceControlUiSm.StateId.DONE: this._DONE_exit(); break;
                
                case SpaceControlUiSm.StateId.MENU: this._MENU_exit(); break;
                
                case SpaceControlUiSm.StateId.ESC_CATCHER_1: this._ESC_CATCHER_1_exit(); break;
                
                case SpaceControlUiSm.StateId.DRINK_MENU: this._DRINK_MENU_exit(); break;
                
                case SpaceControlUiSm.StateId.FOOD_MENU: this._FOOD_MENU_exit(); break;
                
                case SpaceControlUiSm.StateId.EAT_BURRITO: this._EAT_BURRITO_exit(); break;
                
                case SpaceControlUiSm.StateId.EAT_MRE: this._EAT_MRE_exit(); break;
                
                case SpaceControlUiSm.StateId.EAT_SLUDGE: this._EAT_SLUDGE_exit(); break;
                
                case SpaceControlUiSm.StateId.EVENT_EATER_2: this._EVENT_EATER_2_exit(); break;
                
                case SpaceControlUiSm.StateId.COOKING_FOOD: this._COOKING_FOOD_exit(); break;
                
                case SpaceControlUiSm.StateId.COOKING_FOOD1: this._COOKING_FOOD1_exit(); break;
                
                case SpaceControlUiSm.StateId.SYSTEM_INFO_MENU: this._SYSTEM_INFO_MENU_exit(); break;
                
                case SpaceControlUiSm.StateId.BURRITO_COUNT: this._BURRITO_COUNT_exit(); break;
                
                case SpaceControlUiSm.StateId.DISTANCE: this._DISTANCE_exit(); break;
                
                case SpaceControlUiSm.StateId.SELF_DESTRUCT: this._SELF_DESTRUCT_exit(); break;
                
                case SpaceControlUiSm.StateId.SD_1: this._SD_1_exit(); break;
                
                case SpaceControlUiSm.StateId.SELF_DESTRUCT_OPTION: this._SELF_DESTRUCT_OPTION_exit(); break;
                
                case SpaceControlUiSm.StateId.MAIN_MENU_INNER: this._MAIN_MENU_INNER_exit(); break;
                
                case SpaceControlUiSm.StateId.DRINK: this._DRINK_exit(); break;
                
                case SpaceControlUiSm.StateId.FOOD: this._FOOD_exit(); break;
                
                case SpaceControlUiSm.StateId.SYSTEM_INFO: this._SYSTEM_INFO_exit(); break;
                
                case SpaceControlUiSm.StateId.SPLASH_SCREEN: this._SPLASH_SCREEN_exit(); break;
                
                default: return;  // Just to be safe. Prevents infinite loop if state ID memory is somehow corrupted.
            }
        }
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ROOT
    ////////////////////////////////////////////////////////////////////////////////
    
    _ROOT_enter()
    {
        this.stateId = SpaceControlUiSm.StateId.ROOT;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state DONE
    ////////////////////////////////////////////////////////////////////////////////
    
    _DONE_enter()
    {
        this.stateId = SpaceControlUiSm.StateId.DONE;
        
        // DONE behavior
        // uml: enter / { this.tracer?.enterState('DONE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('DONE');`
            this.tracer?.enterState('DONE');
        } // end of behavior for DONE
        
        // DONE behavior
        // uml: enter / { this.tracer?.logActionCode("ShowDoneScreen();"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("ShowDoneScreen();");`
            this.tracer?.logActionCode("ShowDoneScreen();");
        } // end of behavior for DONE
    }
    
    _DONE_exit()
    {
        // DONE behavior
        // uml: exit / { this.tracer?.exitState('DONE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('DONE');`
            this.tracer?.exitState('DONE');
        } // end of behavior for DONE
        
        this.stateId = SpaceControlUiSm.StateId.ROOT;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state MENU
    ////////////////////////////////////////////////////////////////////////////////
    
    _MENU_enter()
    {
        this.stateId = SpaceControlUiSm.StateId.MENU;
        
        // MENU behavior
        // uml: enter / { this.tracer?.enterState('MENU'); }
        {
            // Step 1: execute action `this.tracer?.enterState('MENU');`
            this.tracer?.enterState('MENU');
        } // end of behavior for MENU
        
        // MENU behavior
        // uml: enter / { this.tracer?.logActionCode("display.SetMenuMode(true);"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("display.SetMenuMode(true);");`
            this.tracer?.logActionCode("display.SetMenuMode(true);");
        } // end of behavior for MENU
    }
    
    _MENU_exit()
    {
        // MENU behavior
        // uml: exit / { this.tracer?.exitState('MENU'); }
        {
            // Step 1: execute action `this.tracer?.exitState('MENU');`
            this.tracer?.exitState('MENU');
        } // end of behavior for MENU
        
        this.stateId = SpaceControlUiSm.StateId.ROOT;
    }
    
    _MENU_esc()
    {
        // MENU behavior
        // uml: ESC / { this.tracer?.edgeTransition('edge2'); } TransitionTo(DONE)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this._exitUpToStateHandler(SpaceControlUiSm.StateId.ROOT);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge2');`.
            this.tracer?.edgeTransition('edge2');
            
            // Step 3: Enter/move towards transition target `DONE`.
            this._DONE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for MENU
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ESC_CATCHER_1
    ////////////////////////////////////////////////////////////////////////////////
    
    _ESC_CATCHER_1_enter()
    {
        this.stateId = SpaceControlUiSm.StateId.ESC_CATCHER_1;
        
        // ESC_CATCHER_1 behavior
        // uml: enter / { this.tracer?.enterState('ESC_CATCHER_1'); }
        {
            // Step 1: execute action `this.tracer?.enterState('ESC_CATCHER_1');`
            this.tracer?.enterState('ESC_CATCHER_1');
        } // end of behavior for ESC_CATCHER_1
    }
    
    _ESC_CATCHER_1_exit()
    {
        // ESC_CATCHER_1 behavior
        // uml: exit / { this.tracer?.exitState('ESC_CATCHER_1'); }
        {
            // Step 1: execute action `this.tracer?.exitState('ESC_CATCHER_1');`
            this.tracer?.exitState('ESC_CATCHER_1');
        } // end of behavior for ESC_CATCHER_1
        
        this.stateId = SpaceControlUiSm.StateId.MENU;
    }
    
    _ESC_CATCHER_1_esc()
    {
        let consume_event = false;
        
        // ESC_CATCHER_1 behavior
        // uml: ESC / { this.tracer?.edgeTransition('edge13'); } TransitionTo(MAIN_MENU_INNER)
        {
            // Step 1: Exit states until we reach `MENU` state (Least Common Ancestor for transition).
            this._exitUpToStateHandler(SpaceControlUiSm.StateId.MENU);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge13');`.
            this.tracer?.edgeTransition('edge13');
            
            // Step 3: Enter/move towards transition target `MAIN_MENU_INNER`.
            this._MAIN_MENU_INNER_enter();
            
            // Finish transition by calling pseudo state transition function.
            this._MAIN_MENU_INNER_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for ESC_CATCHER_1
        
        // Check if event has been consumed before calling ancestor handler.
        if (!consume_event)
        {
            this._MENU_esc();
        }
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state DRINK_MENU
    ////////////////////////////////////////////////////////////////////////////////
    
    _DRINK_MENU_enter()
    {
        this.stateId = SpaceControlUiSm.StateId.DRINK_MENU;
        
        // DRINK_MENU behavior
        // uml: enter / { this.tracer?.enterState('DRINK_MENU'); }
        {
            // Step 1: execute action `this.tracer?.enterState('DRINK_MENU');`
            this.tracer?.enterState('DRINK_MENU');
        } // end of behavior for DRINK_MENU
        
        // DRINK_MENU behavior
        // uml: enter / { this.tracer?.logActionCode("MenuHeader(\"Coffee System Offline\");\nMenuOption(\"Activate self destruct?\");"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("MenuHeader(\"Coffee System Offline\");\nMenuOption(\"Activate self destruct?\");");`
            this.tracer?.logActionCode("MenuHeader(\"Coffee System Offline\");\nMenuOption(\"Activate self destruct?\");");
        } // end of behavior for DRINK_MENU
    }
    
    _DRINK_MENU_exit()
    {
        // DRINK_MENU behavior
        // uml: exit / { this.tracer?.exitState('DRINK_MENU'); }
        {
            // Step 1: execute action `this.tracer?.exitState('DRINK_MENU');`
            this.tracer?.exitState('DRINK_MENU');
        } // end of behavior for DRINK_MENU
        
        this.stateId = SpaceControlUiSm.StateId.ESC_CATCHER_1;
    }
    
    _DRINK_MENU_left()
    {
        // DRINK_MENU behavior
        // uml: LEFT / { this.tracer?.edgeTransition('edge14'); } TransitionTo(DRINK)
        {
            // Step 1: Exit states until we reach `MENU` state (Least Common Ancestor for transition).
            this._exitUpToStateHandler(SpaceControlUiSm.StateId.MENU);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge14');`.
            this.tracer?.edgeTransition('edge14');
            
            // Step 3: Enter/move towards transition target `DRINK`.
            this._MAIN_MENU_INNER_enter();
            this._DRINK_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for DRINK_MENU
        
        // No ancestor handles this event.
    }
    
    _DRINK_MENU_right()
    {
        // DRINK_MENU behavior
        // uml: RIGHT / { this.tracer?.edgeTransition('edge15'); } TransitionTo(SYSTEM_INFO_MENU.<EntryPoint>(self_destruct))
        {
            // Step 1: Exit states until we reach `ESC_CATCHER_1` state (Least Common Ancestor for transition).
            this._DRINK_MENU_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge15');`.
            this.tracer?.edgeTransition('edge15');
            
            // Step 3: Enter/move towards transition target `SYSTEM_INFO_MENU.<EntryPoint>(self_destruct)`.
            this._SYSTEM_INFO_MENU_enter();
            // SYSTEM_INFO_MENU.<EntryPoint>(self_destruct) is a pseudo state and cannot have an `enter` trigger.
            
            // SYSTEM_INFO_MENU.<EntryPoint>(self_destruct) behavior
            // uml: / { this.tracer?.edgeTransition('edge37'); } TransitionTo(SELF_DESTRUCT)
            {
                // Step 1: Exit states until we reach `SYSTEM_INFO_MENU` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.edgeTransition('edge37');`.
                this.tracer?.edgeTransition('edge37');
                
                // Step 3: Enter/move towards transition target `SELF_DESTRUCT`.
                this._SELF_DESTRUCT_enter();
                
                // Finish transition by calling pseudo state transition function.
                this._SELF_DESTRUCT_InitialState_transition();
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for SYSTEM_INFO_MENU.<EntryPoint>(self_destruct)
        } // end of behavior for DRINK_MENU
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state FOOD_MENU
    ////////////////////////////////////////////////////////////////////////////////
    
    _FOOD_MENU_enter()
    {
        this.stateId = SpaceControlUiSm.StateId.FOOD_MENU;
        
        // FOOD_MENU behavior
        // uml: enter / { this.tracer?.enterState('FOOD_MENU'); }
        {
            // Step 1: execute action `this.tracer?.enterState('FOOD_MENU');`
            this.tracer?.enterState('FOOD_MENU');
        } // end of behavior for FOOD_MENU
        
        // FOOD_MENU behavior
        // uml: enter / { this.tracer?.logActionCode("MenuHeader(\"Food Menu\");"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("MenuHeader(\"Food Menu\");");`
            this.tracer?.logActionCode("MenuHeader(\"Food Menu\");");
        } // end of behavior for FOOD_MENU
    }
    
    _FOOD_MENU_exit()
    {
        // FOOD_MENU behavior
        // uml: exit / { this.tracer?.exitState('FOOD_MENU'); }
        {
            // Step 1: execute action `this.tracer?.exitState('FOOD_MENU');`
            this.tracer?.exitState('FOOD_MENU');
        } // end of behavior for FOOD_MENU
        
        this.stateId = SpaceControlUiSm.StateId.ESC_CATCHER_1;
    }
    
    _FOOD_MENU_left()
    {
        // FOOD_MENU behavior
        // uml: LEFT / { this.tracer?.edgeTransition('edge16'); } TransitionTo(FOOD)
        {
            // Step 1: Exit states until we reach `MENU` state (Least Common Ancestor for transition).
            this._exitUpToStateHandler(SpaceControlUiSm.StateId.MENU);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge16');`.
            this.tracer?.edgeTransition('edge16');
            
            // Step 3: Enter/move towards transition target `FOOD`.
            this._MAIN_MENU_INNER_enter();
            this._FOOD_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for FOOD_MENU
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state EAT_BURRITO
    ////////////////////////////////////////////////////////////////////////////////
    
    _EAT_BURRITO_enter()
    {
        this.stateId = SpaceControlUiSm.StateId.EAT_BURRITO;
        
        // EAT_BURRITO behavior
        // uml: enter / { this.tracer?.enterState('EAT_BURRITO'); }
        {
            // Step 1: execute action `this.tracer?.enterState('EAT_BURRITO');`
            this.tracer?.enterState('EAT_BURRITO');
        } // end of behavior for EAT_BURRITO
        
        // EAT_BURRITO behavior
        // uml: enter / { this.tracer?.logActionCode("MenuOption(\"Big Fat Burrito\");"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("MenuOption(\"Big Fat Burrito\");");`
            this.tracer?.logActionCode("MenuOption(\"Big Fat Burrito\");");
        } // end of behavior for EAT_BURRITO
    }
    
    _EAT_BURRITO_exit()
    {
        // EAT_BURRITO behavior
        // uml: exit / { this.tracer?.exitState('EAT_BURRITO'); }
        {
            // Step 1: execute action `this.tracer?.exitState('EAT_BURRITO');`
            this.tracer?.exitState('EAT_BURRITO');
        } // end of behavior for EAT_BURRITO
        
        this.stateId = SpaceControlUiSm.StateId.FOOD_MENU;
    }
    
    _EAT_BURRITO_down()
    {
        // EAT_BURRITO behavior
        // uml: DOWN / { this.tracer?.edgeTransition('edge17'); } TransitionTo(EAT_SLUDGE)
        {
            // Step 1: Exit states until we reach `FOOD_MENU` state (Least Common Ancestor for transition).
            this._EAT_BURRITO_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge17');`.
            this.tracer?.edgeTransition('edge17');
            
            // Step 3: Enter/move towards transition target `EAT_SLUDGE`.
            this._EAT_SLUDGE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for EAT_BURRITO
        
        // No ancestor handles this event.
    }
    
    _EAT_BURRITO_right()
    {
        // EAT_BURRITO behavior
        // uml: RIGHT / { this.tracer?.logActionCode("burritoCount--;");this.tracer?.edgeTransition('edge18'); } TransitionTo(COOKING_FOOD)
        {
            // Step 1: Exit states until we reach `FOOD_MENU` state (Least Common Ancestor for transition).
            this._EAT_BURRITO_exit();
            
            // Step 2: Transition action: `this.tracer?.logActionCode("burritoCount--;");this.tracer?.edgeTransition('edge18');`.
            this.tracer?.logActionCode("burritoCount--;");this.tracer?.edgeTransition('edge18');
            
            // Step 3: Enter/move towards transition target `COOKING_FOOD`.
            this._EVENT_EATER_2_enter();
            this._COOKING_FOOD_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for EAT_BURRITO
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state EAT_MRE
    ////////////////////////////////////////////////////////////////////////////////
    
    _EAT_MRE_enter()
    {
        this.stateId = SpaceControlUiSm.StateId.EAT_MRE;
        
        // EAT_MRE behavior
        // uml: enter / { this.tracer?.enterState('EAT_MRE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('EAT_MRE');`
            this.tracer?.enterState('EAT_MRE');
        } // end of behavior for EAT_MRE
        
        // EAT_MRE behavior
        // uml: enter / { this.tracer?.logActionCode("MenuOption(\"MRE\");"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("MenuOption(\"MRE\");");`
            this.tracer?.logActionCode("MenuOption(\"MRE\");");
        } // end of behavior for EAT_MRE
    }
    
    _EAT_MRE_exit()
    {
        // EAT_MRE behavior
        // uml: exit / { this.tracer?.exitState('EAT_MRE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('EAT_MRE');`
            this.tracer?.exitState('EAT_MRE');
        } // end of behavior for EAT_MRE
        
        this.stateId = SpaceControlUiSm.StateId.FOOD_MENU;
    }
    
    _EAT_MRE_right()
    {
        // EAT_MRE behavior
        // uml: RIGHT / { this.tracer?.edgeTransition('edge24'); } TransitionTo(COOKING_FOOD)
        {
            // Step 1: Exit states until we reach `FOOD_MENU` state (Least Common Ancestor for transition).
            this._EAT_MRE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge24');`.
            this.tracer?.edgeTransition('edge24');
            
            // Step 3: Enter/move towards transition target `COOKING_FOOD`.
            this._EVENT_EATER_2_enter();
            this._COOKING_FOOD_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for EAT_MRE
        
        // No ancestor handles this event.
    }
    
    _EAT_MRE_up()
    {
        // EAT_MRE behavior
        // uml: UP / { this.tracer?.edgeTransition('edge23'); } TransitionTo(EAT_SLUDGE)
        {
            // Step 1: Exit states until we reach `FOOD_MENU` state (Least Common Ancestor for transition).
            this._EAT_MRE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge23');`.
            this.tracer?.edgeTransition('edge23');
            
            // Step 3: Enter/move towards transition target `EAT_SLUDGE`.
            this._EAT_SLUDGE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for EAT_MRE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state EAT_SLUDGE
    ////////////////////////////////////////////////////////////////////////////////
    
    _EAT_SLUDGE_enter()
    {
        this.stateId = SpaceControlUiSm.StateId.EAT_SLUDGE;
        
        // EAT_SLUDGE behavior
        // uml: enter / { this.tracer?.enterState('EAT_SLUDGE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('EAT_SLUDGE');`
            this.tracer?.enterState('EAT_SLUDGE');
        } // end of behavior for EAT_SLUDGE
        
        // EAT_SLUDGE behavior
        // uml: enter / { this.tracer?.logActionCode("MenuOption(\"Nutrient Mush\");"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("MenuOption(\"Nutrient Mush\");");`
            this.tracer?.logActionCode("MenuOption(\"Nutrient Mush\");");
        } // end of behavior for EAT_SLUDGE
    }
    
    _EAT_SLUDGE_exit()
    {
        // EAT_SLUDGE behavior
        // uml: exit / { this.tracer?.exitState('EAT_SLUDGE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('EAT_SLUDGE');`
            this.tracer?.exitState('EAT_SLUDGE');
        } // end of behavior for EAT_SLUDGE
        
        this.stateId = SpaceControlUiSm.StateId.FOOD_MENU;
    }
    
    _EAT_SLUDGE_down()
    {
        // EAT_SLUDGE behavior
        // uml: DOWN / { this.tracer?.edgeTransition('edge20'); } TransitionTo(EAT_MRE)
        {
            // Step 1: Exit states until we reach `FOOD_MENU` state (Least Common Ancestor for transition).
            this._EAT_SLUDGE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge20');`.
            this.tracer?.edgeTransition('edge20');
            
            // Step 3: Enter/move towards transition target `EAT_MRE`.
            this._EAT_MRE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for EAT_SLUDGE
        
        // No ancestor handles this event.
    }
    
    _EAT_SLUDGE_right()
    {
        // EAT_SLUDGE behavior
        // uml: RIGHT / { this.tracer?.edgeTransition('edge22'); } TransitionTo(COOKING_FOOD1)
        {
            // Step 1: Exit states until we reach `FOOD_MENU` state (Least Common Ancestor for transition).
            this._EAT_SLUDGE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge22');`.
            this.tracer?.edgeTransition('edge22');
            
            // Step 3: Enter/move towards transition target `COOKING_FOOD1`.
            this._EVENT_EATER_2_enter();
            this._COOKING_FOOD1_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for EAT_SLUDGE
        
        // No ancestor handles this event.
    }
    
    _EAT_SLUDGE_up()
    {
        // EAT_SLUDGE behavior
        // uml: UP / { this.tracer?.edgeTransition('edge21'); } TransitionTo(EAT_BURRITO)
        {
            // Step 1: Exit states until we reach `FOOD_MENU` state (Least Common Ancestor for transition).
            this._EAT_SLUDGE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge21');`.
            this.tracer?.edgeTransition('edge21');
            
            // Step 3: Enter/move towards transition target `EAT_BURRITO`.
            this._EAT_BURRITO_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for EAT_SLUDGE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state EVENT_EATER_2
    ////////////////////////////////////////////////////////////////////////////////
    
    _EVENT_EATER_2_enter()
    {
        this.stateId = SpaceControlUiSm.StateId.EVENT_EATER_2;
        
        // EVENT_EATER_2 behavior
        // uml: enter / { this.tracer?.enterState('EVENT_EATER_2'); }
        {
            // Step 1: execute action `this.tracer?.enterState('EVENT_EATER_2');`
            this.tracer?.enterState('EVENT_EATER_2');
        } // end of behavior for EVENT_EATER_2
    }
    
    _EVENT_EATER_2_exit()
    {
        // EVENT_EATER_2 behavior
        // uml: exit / { this.tracer?.exitState('EVENT_EATER_2'); }
        {
            // Step 1: execute action `this.tracer?.exitState('EVENT_EATER_2');`
            this.tracer?.exitState('EVENT_EATER_2');
        } // end of behavior for EVENT_EATER_2
        
        this.stateId = SpaceControlUiSm.StateId.FOOD_MENU;
    }
    
    _EVENT_EATER_2_esc()
    {
        let consume_event = false;
        
        // EVENT_EATER_2 behavior
        // uml: (LEFT, ESC)
        {
            // Consume event `esc`.
            consume_event = true;
            // Step 1: execute action ``
        } // end of behavior for EVENT_EATER_2
        
        // Check if event has been consumed before calling ancestor handler.
        if (!consume_event)
        {
            this._ESC_CATCHER_1_esc();
        }
    }
    
    _EVENT_EATER_2_left()
    {
        let consume_event = false;
        
        // EVENT_EATER_2 behavior
        // uml: (LEFT, ESC)
        {
            // Consume event `left`.
            consume_event = true;
            // Step 1: execute action ``
        } // end of behavior for EVENT_EATER_2
        
        // Check if event has been consumed before calling ancestor handler.
        if (!consume_event)
        {
            this._FOOD_MENU_left();
        }
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state COOKING_FOOD
    ////////////////////////////////////////////////////////////////////////////////
    
    _COOKING_FOOD_enter()
    {
        this.stateId = SpaceControlUiSm.StateId.COOKING_FOOD;
        
        // COOKING_FOOD behavior
        // uml: enter / { this.tracer?.enterState('COOKING_FOOD'); }
        {
            // Step 1: execute action `this.tracer?.enterState('COOKING_FOOD');`
            this.tracer?.enterState('COOKING_FOOD');
        } // end of behavior for COOKING_FOOD
        
        // COOKING_FOOD behavior
        // uml: enter / { this.tracer?.logActionCode("t1Restart();\nMenuHeader(\"Cooking Food\");\nMenuOption(\"...\");"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("t1Restart();\nMenuHeader(\"Cooking Food\");\nMenuOption(\"...\");");`
            this.tracer?.logActionCode("t1Restart();\nMenuHeader(\"Cooking Food\");\nMenuOption(\"...\");");
        } // end of behavior for COOKING_FOOD
    }
    
    _COOKING_FOOD_exit()
    {
        // COOKING_FOOD behavior
        // uml: exit / { this.tracer?.exitState('COOKING_FOOD'); }
        {
            // Step 1: execute action `this.tracer?.exitState('COOKING_FOOD');`
            this.tracer?.exitState('COOKING_FOOD');
        } // end of behavior for COOKING_FOOD
        
        this.stateId = SpaceControlUiSm.StateId.EVENT_EATER_2;
    }
    
    _COOKING_FOOD_do()
    {
        // COOKING_FOOD behavior
        // uml: do [this.tracer?.logGuardCodeEvaluation("t1After( 3.5 s )") || this.evaluateGuard('COOKING_FOOD', "do [t1After( 3.5 s )] TransitionTo(FOOD_MENU.<ExitPoint>(food_selected))")] / { this.tracer?.edgeTransition('edge27'); } TransitionTo(FOOD_MENU.<ExitPoint>(food_selected))
        if (this.tracer?.logGuardCodeEvaluation("t1After( 3.5 s )") || this.evaluateGuard('COOKING_FOOD', "do [t1After( 3.5 s )] TransitionTo(FOOD_MENU.<ExitPoint>(food_selected))"))
        {
            // Step 1: Exit states until we reach `FOOD_MENU` state (Least Common Ancestor for transition).
            this._exitUpToStateHandler(SpaceControlUiSm.StateId.FOOD_MENU);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge27');`.
            this.tracer?.edgeTransition('edge27');
            
            // Step 3: Enter/move towards transition target `FOOD_MENU.<ExitPoint>(food_selected)`.
            // FOOD_MENU.<ExitPoint>(food_selected) is a pseudo state and cannot have an `enter` trigger.
            
            // FOOD_MENU.<ExitPoint>(food_selected) behavior
            // uml: / { this.tracer?.edgeTransition('edge25'); } TransitionTo(FOOD)
            {
                // Step 1: Exit states until we reach `MENU` state (Least Common Ancestor for transition).
                this._exitUpToStateHandler(SpaceControlUiSm.StateId.MENU);
                
                // Step 2: Transition action: `this.tracer?.edgeTransition('edge25');`.
                this.tracer?.edgeTransition('edge25');
                
                // Step 3: Enter/move towards transition target `FOOD`.
                this._MAIN_MENU_INNER_enter();
                this._FOOD_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for FOOD_MENU.<ExitPoint>(food_selected)
        } // end of behavior for COOKING_FOOD
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state COOKING_FOOD1
    ////////////////////////////////////////////////////////////////////////////////
    
    _COOKING_FOOD1_enter()
    {
        this.stateId = SpaceControlUiSm.StateId.COOKING_FOOD1;
        
        // COOKING_FOOD1 behavior
        // uml: enter / { this.tracer?.enterState('COOKING_FOOD1'); }
        {
            // Step 1: execute action `this.tracer?.enterState('COOKING_FOOD1');`
            this.tracer?.enterState('COOKING_FOOD1');
        } // end of behavior for COOKING_FOOD1
        
        // COOKING_FOOD1 behavior
        // uml: enter / { this.tracer?.logActionCode("t1Restart();"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("t1Restart();");`
            this.tracer?.logActionCode("t1Restart();");
        } // end of behavior for COOKING_FOOD1
        
        // COOKING_FOOD1 behavior
        // uml: enter / { this.tracer?.logActionCode("MenuHeader(\"Mush...\");"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("MenuHeader(\"Mush...\");");`
            this.tracer?.logActionCode("MenuHeader(\"Mush...\");");
        } // end of behavior for COOKING_FOOD1
        
        // COOKING_FOOD1 behavior
        // uml: enter / { this.tracer?.logActionCode("MenuOption(\"Gross...\");"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("MenuOption(\"Gross...\");");`
            this.tracer?.logActionCode("MenuOption(\"Gross...\");");
        } // end of behavior for COOKING_FOOD1
    }
    
    _COOKING_FOOD1_exit()
    {
        // COOKING_FOOD1 behavior
        // uml: exit / { this.tracer?.exitState('COOKING_FOOD1'); }
        {
            // Step 1: execute action `this.tracer?.exitState('COOKING_FOOD1');`
            this.tracer?.exitState('COOKING_FOOD1');
        } // end of behavior for COOKING_FOOD1
        
        this.stateId = SpaceControlUiSm.StateId.EVENT_EATER_2;
    }
    
    _COOKING_FOOD1_do()
    {
        // COOKING_FOOD1 behavior
        // uml: do [this.tracer?.logGuardCodeEvaluation("t1After( 1s )") || this.evaluateGuard('COOKING_FOOD1', "do [t1After( 1s )] TransitionTo(COOKING_FOOD)")] / { this.tracer?.edgeTransition('edge26'); } TransitionTo(COOKING_FOOD)
        if (this.tracer?.logGuardCodeEvaluation("t1After( 1s )") || this.evaluateGuard('COOKING_FOOD1', "do [t1After( 1s )] TransitionTo(COOKING_FOOD)"))
        {
            // Step 1: Exit states until we reach `EVENT_EATER_2` state (Least Common Ancestor for transition).
            this._COOKING_FOOD1_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge26');`.
            this.tracer?.edgeTransition('edge26');
            
            // Step 3: Enter/move towards transition target `COOKING_FOOD`.
            this._COOKING_FOOD_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for COOKING_FOOD1
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state SYSTEM_INFO_MENU
    ////////////////////////////////////////////////////////////////////////////////
    
    _SYSTEM_INFO_MENU_enter()
    {
        this.stateId = SpaceControlUiSm.StateId.SYSTEM_INFO_MENU;
        
        // SYSTEM_INFO_MENU behavior
        // uml: enter / { this.tracer?.enterState('SYSTEM_INFO_MENU'); }
        {
            // Step 1: execute action `this.tracer?.enterState('SYSTEM_INFO_MENU');`
            this.tracer?.enterState('SYSTEM_INFO_MENU');
        } // end of behavior for SYSTEM_INFO_MENU
    }
    
    _SYSTEM_INFO_MENU_exit()
    {
        // SYSTEM_INFO_MENU behavior
        // uml: exit / { this.tracer?.exitState('SYSTEM_INFO_MENU'); }
        {
            // Step 1: execute action `this.tracer?.exitState('SYSTEM_INFO_MENU');`
            this.tracer?.exitState('SYSTEM_INFO_MENU');
        } // end of behavior for SYSTEM_INFO_MENU
        
        this.stateId = SpaceControlUiSm.StateId.ESC_CATCHER_1;
    }
    
    _SYSTEM_INFO_MENU_left()
    {
        // SYSTEM_INFO_MENU behavior
        // uml: LEFT / { this.tracer?.edgeTransition('edge28'); } TransitionTo(SYSTEM_INFO)
        {
            // Step 1: Exit states until we reach `MENU` state (Least Common Ancestor for transition).
            this._exitUpToStateHandler(SpaceControlUiSm.StateId.MENU);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge28');`.
            this.tracer?.edgeTransition('edge28');
            
            // Step 3: Enter/move towards transition target `SYSTEM_INFO`.
            this._MAIN_MENU_INNER_enter();
            this._SYSTEM_INFO_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for SYSTEM_INFO_MENU
        
        // No ancestor handles this event.
    }
    
    _SYSTEM_INFO_MENU_pg_down()
    {
        // SYSTEM_INFO_MENU behavior
        // uml: PG_DOWN / { this.tracer?.edgeTransition('edge29'); } TransitionTo(SELF_DESTRUCT_OPTION)
        {
            // Step 1: Exit states until we reach `SYSTEM_INFO_MENU` state (Least Common Ancestor for transition).
            this._exitUpToStateHandler(SpaceControlUiSm.StateId.SYSTEM_INFO_MENU);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge29');`.
            this.tracer?.edgeTransition('edge29');
            
            // Step 3: Enter/move towards transition target `SELF_DESTRUCT_OPTION`.
            this._SELF_DESTRUCT_OPTION_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for SYSTEM_INFO_MENU
        
        // No ancestor handles this event.
    }
    
    _SYSTEM_INFO_MENU_pg_up()
    {
        // SYSTEM_INFO_MENU behavior
        // uml: PG_UP / { this.tracer?.edgeTransition('edge30'); } TransitionTo(DISTANCE)
        {
            // Step 1: Exit states until we reach `SYSTEM_INFO_MENU` state (Least Common Ancestor for transition).
            this._exitUpToStateHandler(SpaceControlUiSm.StateId.SYSTEM_INFO_MENU);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge30');`.
            this.tracer?.edgeTransition('edge30');
            
            // Step 3: Enter/move towards transition target `DISTANCE`.
            this._DISTANCE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for SYSTEM_INFO_MENU
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state BURRITO_COUNT
    ////////////////////////////////////////////////////////////////////////////////
    
    _BURRITO_COUNT_enter()
    {
        this.stateId = SpaceControlUiSm.StateId.BURRITO_COUNT;
        
        // BURRITO_COUNT behavior
        // uml: enter / { this.tracer?.enterState('BURRITO_COUNT'); }
        {
            // Step 1: execute action `this.tracer?.enterState('BURRITO_COUNT');`
            this.tracer?.enterState('BURRITO_COUNT');
        } // end of behavior for BURRITO_COUNT
        
        // BURRITO_COUNT behavior
        // uml: enter / { this.tracer?.logActionCode("MenuOption(\"Burrito count: \" + burritoCount);"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("MenuOption(\"Burrito count: \" + burritoCount);");`
            this.tracer?.logActionCode("MenuOption(\"Burrito count: \" + burritoCount);");
        } // end of behavior for BURRITO_COUNT
    }
    
    _BURRITO_COUNT_exit()
    {
        // BURRITO_COUNT behavior
        // uml: exit / { this.tracer?.exitState('BURRITO_COUNT'); }
        {
            // Step 1: execute action `this.tracer?.exitState('BURRITO_COUNT');`
            this.tracer?.exitState('BURRITO_COUNT');
        } // end of behavior for BURRITO_COUNT
        
        this.stateId = SpaceControlUiSm.StateId.SYSTEM_INFO_MENU;
    }
    
    _BURRITO_COUNT_down()
    {
        // BURRITO_COUNT behavior
        // uml: DOWN / { this.tracer?.edgeTransition('edge31'); } TransitionTo(SELF_DESTRUCT_OPTION)
        {
            // Step 1: Exit states until we reach `SYSTEM_INFO_MENU` state (Least Common Ancestor for transition).
            this._BURRITO_COUNT_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge31');`.
            this.tracer?.edgeTransition('edge31');
            
            // Step 3: Enter/move towards transition target `SELF_DESTRUCT_OPTION`.
            this._SELF_DESTRUCT_OPTION_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for BURRITO_COUNT
        
        // No ancestor handles this event.
    }
    
    _BURRITO_COUNT_up()
    {
        // BURRITO_COUNT behavior
        // uml: UP / { this.tracer?.edgeTransition('edge32'); } TransitionTo(DISTANCE)
        {
            // Step 1: Exit states until we reach `SYSTEM_INFO_MENU` state (Least Common Ancestor for transition).
            this._BURRITO_COUNT_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge32');`.
            this.tracer?.edgeTransition('edge32');
            
            // Step 3: Enter/move towards transition target `DISTANCE`.
            this._DISTANCE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for BURRITO_COUNT
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state DISTANCE
    ////////////////////////////////////////////////////////////////////////////////
    
    _DISTANCE_enter()
    {
        this.stateId = SpaceControlUiSm.StateId.DISTANCE;
        
        // DISTANCE behavior
        // uml: enter / { this.tracer?.enterState('DISTANCE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('DISTANCE');`
            this.tracer?.enterState('DISTANCE');
        } // end of behavior for DISTANCE
        
        // DISTANCE behavior
        // uml: enter / { this.tracer?.logActionCode("MenuOption(\"Distance to Tau Ceti: \" + distance); "); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("MenuOption(\"Distance to Tau Ceti: \" + distance); ");`
            this.tracer?.logActionCode("MenuOption(\"Distance to Tau Ceti: \" + distance); ");
        } // end of behavior for DISTANCE
    }
    
    _DISTANCE_exit()
    {
        // DISTANCE behavior
        // uml: exit / { this.tracer?.exitState('DISTANCE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('DISTANCE');`
            this.tracer?.exitState('DISTANCE');
        } // end of behavior for DISTANCE
        
        this.stateId = SpaceControlUiSm.StateId.SYSTEM_INFO_MENU;
    }
    
    _DISTANCE_down()
    {
        // DISTANCE behavior
        // uml: DOWN / { this.tracer?.edgeTransition('edge33'); } TransitionTo(BURRITO_COUNT)
        {
            // Step 1: Exit states until we reach `SYSTEM_INFO_MENU` state (Least Common Ancestor for transition).
            this._DISTANCE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge33');`.
            this.tracer?.edgeTransition('edge33');
            
            // Step 3: Enter/move towards transition target `BURRITO_COUNT`.
            this._BURRITO_COUNT_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for DISTANCE
        
        // No ancestor handles this event.
    }
    
    _DISTANCE_pg_up()
    {
        let consume_event = false;
        
        // DISTANCE behavior
        // uml: (UP, PG_UP) / { this.tracer?.logActionCode("Beep();"); }
        {
            // Consume event `pg_up`.
            consume_event = true;
            // Step 1: execute action `this.tracer?.logActionCode("Beep();");`
            this.tracer?.logActionCode("Beep();");
        } // end of behavior for DISTANCE
        
        // Check if event has been consumed before calling ancestor handler.
        if (!consume_event)
        {
            this._SYSTEM_INFO_MENU_pg_up();
        }
    }
    
    _DISTANCE_up()
    {
        // DISTANCE behavior
        // uml: (UP, PG_UP) / { this.tracer?.logActionCode("Beep();"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("Beep();");`
            this.tracer?.logActionCode("Beep();");
        } // end of behavior for DISTANCE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state SELF_DESTRUCT
    ////////////////////////////////////////////////////////////////////////////////
    
    _SELF_DESTRUCT_enter()
    {
        this.stateId = SpaceControlUiSm.StateId.SELF_DESTRUCT;
        
        // SELF_DESTRUCT behavior
        // uml: enter / { this.tracer?.enterState('SELF_DESTRUCT'); }
        {
            // Step 1: execute action `this.tracer?.enterState('SELF_DESTRUCT');`
            this.tracer?.enterState('SELF_DESTRUCT');
        } // end of behavior for SELF_DESTRUCT
        
        // SELF_DESTRUCT behavior
        // uml: enter / { this.tracer?.logActionCode("StartSelfDestructTimer();"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("StartSelfDestructTimer();");`
            this.tracer?.logActionCode("StartSelfDestructTimer();");
        } // end of behavior for SELF_DESTRUCT
    }
    
    _SELF_DESTRUCT_exit()
    {
        // SELF_DESTRUCT behavior
        // uml: exit / { this.tracer?.exitState('SELF_DESTRUCT'); }
        {
            // Step 1: execute action `this.tracer?.exitState('SELF_DESTRUCT');`
            this.tracer?.exitState('SELF_DESTRUCT');
        } // end of behavior for SELF_DESTRUCT
        
        this.stateId = SpaceControlUiSm.StateId.SYSTEM_INFO_MENU;
    }
    
    _SELF_DESTRUCT_left()
    {
        let consume_event = false;
        
        // SELF_DESTRUCT behavior
        // uml: LEFT / { this.tracer?.logActionCode("Beep();"); }
        {
            // Consume event `left`.
            consume_event = true;
            // Step 1: execute action `this.tracer?.logActionCode("Beep();");`
            this.tracer?.logActionCode("Beep();");
        } // end of behavior for SELF_DESTRUCT
        
        // Check if event has been consumed before calling ancestor handler.
        if (!consume_event)
        {
            this._SYSTEM_INFO_MENU_left();
        }
    }
    
    _SELF_DESTRUCT_InitialState_transition()
    {
        // SELF_DESTRUCT.<InitialState> behavior
        // uml: / { this.tracer?.edgeTransition('edge39'); } TransitionTo(SD_1)
        {
            // Step 1: Exit states until we reach `SELF_DESTRUCT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge39');`.
            this.tracer?.edgeTransition('edge39');
            
            // Step 3: Enter/move towards transition target `SD_1`.
            this._SD_1_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for SELF_DESTRUCT.<InitialState>
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state SD_1
    ////////////////////////////////////////////////////////////////////////////////
    
    _SD_1_enter()
    {
        this.stateId = SpaceControlUiSm.StateId.SD_1;
        
        // SD_1 behavior
        // uml: enter / { this.tracer?.enterState('SD_1'); }
        {
            // Step 1: execute action `this.tracer?.enterState('SD_1');`
            this.tracer?.enterState('SD_1');
        } // end of behavior for SD_1
        
        // SD_1 behavior
        // uml: enter / { this.tracer?.logActionCode("Beep();"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("Beep();");`
            this.tracer?.logActionCode("Beep();");
        } // end of behavior for SD_1
        
        // SD_1 behavior
        // uml: enter / { this.tracer?.logActionCode("t1.Restart();"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("t1.Restart();");`
            this.tracer?.logActionCode("t1.Restart();");
        } // end of behavior for SD_1
        
        // SD_1 behavior
        // uml: enter / { this.tracer?.logActionCode("MenuHeader($\"SELF DESTRUCT IN \" + SelfDestructSeconds);"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("MenuHeader($\"SELF DESTRUCT IN \" + SelfDestructSeconds);");`
            this.tracer?.logActionCode("MenuHeader($\"SELF DESTRUCT IN \" + SelfDestructSeconds);");
        } // end of behavior for SD_1
    }
    
    _SD_1_exit()
    {
        // SD_1 behavior
        // uml: exit / { this.tracer?.exitState('SD_1'); }
        {
            // Step 1: execute action `this.tracer?.exitState('SD_1');`
            this.tracer?.exitState('SD_1');
        } // end of behavior for SD_1
        
        this.stateId = SpaceControlUiSm.StateId.SELF_DESTRUCT;
    }
    
    _SD_1_do()
    {
        // SD_1 behavior
        // uml: DO [this.tracer?.logGuardCodeEvaluation("SelfDestructSeconds <= 0") || this.evaluateGuard('SD_1', "DO [SelfDestructSeconds <= 0] / { SelfDestruct(); }")] / { this.tracer?.logActionCode("SelfDestruct();"); }
        if (this.tracer?.logGuardCodeEvaluation("SelfDestructSeconds <= 0") || this.evaluateGuard('SD_1', "DO [SelfDestructSeconds <= 0] / { SelfDestruct(); }"))
        {
            // Step 1: execute action `this.tracer?.logActionCode("SelfDestruct();");`
            this.tracer?.logActionCode("SelfDestruct();");
        } // end of behavior for SD_1
        
        // SD_1 behavior
        // uml: do [this.tracer?.logGuardCodeEvaluation("t1.Elapsed.Seconds >= 1") || this.evaluateGuard('SD_1', "do [t1.Elapsed.Seconds >= 1] TransitionTo(SD_1)")] / { this.tracer?.edgeTransition('edge38'); } TransitionTo(SD_1)
        if (this.tracer?.logGuardCodeEvaluation("t1.Elapsed.Seconds >= 1") || this.evaluateGuard('SD_1', "do [t1.Elapsed.Seconds >= 1] TransitionTo(SD_1)"))
        {
            // Step 1: Exit states until we reach `SELF_DESTRUCT` state (Least Common Ancestor for transition).
            this._SD_1_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge38');`.
            this.tracer?.edgeTransition('edge38');
            
            // Step 3: Enter/move towards transition target `SD_1`.
            this._SD_1_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for SD_1
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state SELF_DESTRUCT_OPTION
    ////////////////////////////////////////////////////////////////////////////////
    
    _SELF_DESTRUCT_OPTION_enter()
    {
        this.stateId = SpaceControlUiSm.StateId.SELF_DESTRUCT_OPTION;
        
        // SELF_DESTRUCT_OPTION behavior
        // uml: enter / { this.tracer?.enterState('SELF_DESTRUCT_OPTION'); }
        {
            // Step 1: execute action `this.tracer?.enterState('SELF_DESTRUCT_OPTION');`
            this.tracer?.enterState('SELF_DESTRUCT_OPTION');
        } // end of behavior for SELF_DESTRUCT_OPTION
        
        // SELF_DESTRUCT_OPTION behavior
        // uml: enter / { this.tracer?.logActionCode("count = 0;\nMenuOption(\"Self Destruct?\");"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("count = 0;\nMenuOption(\"Self Destruct?\");");`
            this.tracer?.logActionCode("count = 0;\nMenuOption(\"Self Destruct?\");");
        } // end of behavior for SELF_DESTRUCT_OPTION
    }
    
    _SELF_DESTRUCT_OPTION_exit()
    {
        // SELF_DESTRUCT_OPTION behavior
        // uml: exit / { this.tracer?.exitState('SELF_DESTRUCT_OPTION'); }
        {
            // Step 1: execute action `this.tracer?.exitState('SELF_DESTRUCT_OPTION');`
            this.tracer?.exitState('SELF_DESTRUCT_OPTION');
        } // end of behavior for SELF_DESTRUCT_OPTION
        
        this.stateId = SpaceControlUiSm.StateId.SYSTEM_INFO_MENU;
    }
    
    _SELF_DESTRUCT_OPTION_down()
    {
        // SELF_DESTRUCT_OPTION behavior
        // uml: (DOWN, PG_DOWN) / { this.tracer?.logActionCode("Beep();"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("Beep();");`
            this.tracer?.logActionCode("Beep();");
        } // end of behavior for SELF_DESTRUCT_OPTION
        
        // No ancestor handles this event.
    }
    
    _SELF_DESTRUCT_OPTION_pg_down()
    {
        let consume_event = false;
        
        // SELF_DESTRUCT_OPTION behavior
        // uml: (DOWN, PG_DOWN) / { this.tracer?.logActionCode("Beep();"); }
        {
            // Consume event `pg_down`.
            consume_event = true;
            // Step 1: execute action `this.tracer?.logActionCode("Beep();");`
            this.tracer?.logActionCode("Beep();");
        } // end of behavior for SELF_DESTRUCT_OPTION
        
        // Check if event has been consumed before calling ancestor handler.
        if (!consume_event)
        {
            this._SYSTEM_INFO_MENU_pg_down();
        }
    }
    
    _SELF_DESTRUCT_OPTION_right()
    {
        // SELF_DESTRUCT_OPTION behavior
        // uml: 1. RIGHT / { this.tracer?.logActionCode("count++; Beep();"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("count++; Beep();");`
            this.tracer?.logActionCode("count++; Beep();");
        } // end of behavior for SELF_DESTRUCT_OPTION
        
        // SELF_DESTRUCT_OPTION behavior
        // uml: RIGHT [this.tracer?.logGuardCodeEvaluation("count >= 5") || this.evaluateGuard('SELF_DESTRUCT_OPTION', "RIGHT [count >= 5] TransitionTo(SELF_DESTRUCT)")] / { this.tracer?.edgeTransition('edge35'); } TransitionTo(SELF_DESTRUCT)
        if (this.tracer?.logGuardCodeEvaluation("count >= 5") || this.evaluateGuard('SELF_DESTRUCT_OPTION', "RIGHT [count >= 5] TransitionTo(SELF_DESTRUCT)"))
        {
            // Step 1: Exit states until we reach `SYSTEM_INFO_MENU` state (Least Common Ancestor for transition).
            this._SELF_DESTRUCT_OPTION_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge35');`.
            this.tracer?.edgeTransition('edge35');
            
            // Step 3: Enter/move towards transition target `SELF_DESTRUCT`.
            this._SELF_DESTRUCT_enter();
            
            // Finish transition by calling pseudo state transition function.
            this._SELF_DESTRUCT_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for SELF_DESTRUCT_OPTION
        
        // No ancestor handles this event.
    }
    
    _SELF_DESTRUCT_OPTION_up()
    {
        // SELF_DESTRUCT_OPTION behavior
        // uml: UP / { this.tracer?.edgeTransition('edge34'); } TransitionTo(BURRITO_COUNT)
        {
            // Step 1: Exit states until we reach `SYSTEM_INFO_MENU` state (Least Common Ancestor for transition).
            this._SELF_DESTRUCT_OPTION_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge34');`.
            this.tracer?.edgeTransition('edge34');
            
            // Step 3: Enter/move towards transition target `BURRITO_COUNT`.
            this._BURRITO_COUNT_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for SELF_DESTRUCT_OPTION
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state MAIN_MENU_INNER
    ////////////////////////////////////////////////////////////////////////////////
    
    _MAIN_MENU_INNER_enter()
    {
        this.stateId = SpaceControlUiSm.StateId.MAIN_MENU_INNER;
        
        // MAIN_MENU_INNER behavior
        // uml: enter / { this.tracer?.enterState('MAIN_MENU_INNER'); }
        {
            // Step 1: execute action `this.tracer?.enterState('MAIN_MENU_INNER');`
            this.tracer?.enterState('MAIN_MENU_INNER');
        } // end of behavior for MAIN_MENU_INNER
        
        // MAIN_MENU_INNER behavior
        // uml: enter / { this.tracer?.logActionCode("MenuHeader(\"Main Menu\");"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("MenuHeader(\"Main Menu\");");`
            this.tracer?.logActionCode("MenuHeader(\"Main Menu\");");
        } // end of behavior for MAIN_MENU_INNER
    }
    
    _MAIN_MENU_INNER_exit()
    {
        // MAIN_MENU_INNER behavior
        // uml: exit / { this.tracer?.exitState('MAIN_MENU_INNER'); }
        {
            // Step 1: execute action `this.tracer?.exitState('MAIN_MENU_INNER');`
            this.tracer?.exitState('MAIN_MENU_INNER');
        } // end of behavior for MAIN_MENU_INNER
        
        this.stateId = SpaceControlUiSm.StateId.MENU;
    }
    
    _MAIN_MENU_INNER_pg_down()
    {
        // MAIN_MENU_INNER behavior
        // uml: PG_DOWN / { this.tracer?.edgeTransition('edge3'); } TransitionTo(SYSTEM_INFO)
        {
            // Step 1: Exit states until we reach `MAIN_MENU_INNER` state (Least Common Ancestor for transition).
            this._exitUpToStateHandler(SpaceControlUiSm.StateId.MAIN_MENU_INNER);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge3');`.
            this.tracer?.edgeTransition('edge3');
            
            // Step 3: Enter/move towards transition target `SYSTEM_INFO`.
            this._SYSTEM_INFO_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for MAIN_MENU_INNER
        
        // No ancestor handles this event.
    }
    
    _MAIN_MENU_INNER_pg_up()
    {
        // MAIN_MENU_INNER behavior
        // uml: PG_UP / { this.tracer?.edgeTransition('edge4'); } TransitionTo(FOOD)
        {
            // Step 1: Exit states until we reach `MAIN_MENU_INNER` state (Least Common Ancestor for transition).
            this._exitUpToStateHandler(SpaceControlUiSm.StateId.MAIN_MENU_INNER);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge4');`.
            this.tracer?.edgeTransition('edge4');
            
            // Step 3: Enter/move towards transition target `FOOD`.
            this._FOOD_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for MAIN_MENU_INNER
        
        // No ancestor handles this event.
    }
    
    _MAIN_MENU_INNER_InitialState_transition()
    {
        // MAIN_MENU_INNER.<InitialState> behavior
        // uml: / { this.tracer?.edgeTransition('edge5'); } TransitionTo(FOOD)
        {
            // Step 1: Exit states until we reach `MAIN_MENU_INNER` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge5');`.
            this.tracer?.edgeTransition('edge5');
            
            // Step 3: Enter/move towards transition target `FOOD`.
            this._FOOD_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for MAIN_MENU_INNER.<InitialState>
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state DRINK
    ////////////////////////////////////////////////////////////////////////////////
    
    _DRINK_enter()
    {
        this.stateId = SpaceControlUiSm.StateId.DRINK;
        
        // DRINK behavior
        // uml: enter / { this.tracer?.enterState('DRINK'); }
        {
            // Step 1: execute action `this.tracer?.enterState('DRINK');`
            this.tracer?.enterState('DRINK');
        } // end of behavior for DRINK
        
        // DRINK behavior
        // uml: enter / { this.tracer?.logActionCode("MenuOption(\"Select Drink\");"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("MenuOption(\"Select Drink\");");`
            this.tracer?.logActionCode("MenuOption(\"Select Drink\");");
        } // end of behavior for DRINK
    }
    
    _DRINK_exit()
    {
        // DRINK behavior
        // uml: exit / { this.tracer?.exitState('DRINK'); }
        {
            // Step 1: execute action `this.tracer?.exitState('DRINK');`
            this.tracer?.exitState('DRINK');
        } // end of behavior for DRINK
        
        this.stateId = SpaceControlUiSm.StateId.MAIN_MENU_INNER;
    }
    
    _DRINK_down()
    {
        // DRINK behavior
        // uml: DOWN / { this.tracer?.edgeTransition('edge6'); } TransitionTo(SYSTEM_INFO)
        {
            // Step 1: Exit states until we reach `MAIN_MENU_INNER` state (Least Common Ancestor for transition).
            this._DRINK_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge6');`.
            this.tracer?.edgeTransition('edge6');
            
            // Step 3: Enter/move towards transition target `SYSTEM_INFO`.
            this._SYSTEM_INFO_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for DRINK
        
        // No ancestor handles this event.
    }
    
    _DRINK_right()
    {
        // DRINK behavior
        // uml: RIGHT / { this.tracer?.edgeTransition('edge8'); } TransitionTo(DRINK_MENU)
        {
            // Step 1: Exit states until we reach `MENU` state (Least Common Ancestor for transition).
            this._exitUpToStateHandler(SpaceControlUiSm.StateId.MENU);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge8');`.
            this.tracer?.edgeTransition('edge8');
            
            // Step 3: Enter/move towards transition target `DRINK_MENU`.
            this._ESC_CATCHER_1_enter();
            this._DRINK_MENU_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for DRINK
        
        // No ancestor handles this event.
    }
    
    _DRINK_up()
    {
        // DRINK behavior
        // uml: UP / { this.tracer?.edgeTransition('edge7'); } TransitionTo(FOOD)
        {
            // Step 1: Exit states until we reach `MAIN_MENU_INNER` state (Least Common Ancestor for transition).
            this._DRINK_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge7');`.
            this.tracer?.edgeTransition('edge7');
            
            // Step 3: Enter/move towards transition target `FOOD`.
            this._FOOD_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for DRINK
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state FOOD
    ////////////////////////////////////////////////////////////////////////////////
    
    _FOOD_enter()
    {
        this.stateId = SpaceControlUiSm.StateId.FOOD;
        
        // FOOD behavior
        // uml: enter / { this.tracer?.enterState('FOOD'); }
        {
            // Step 1: execute action `this.tracer?.enterState('FOOD');`
            this.tracer?.enterState('FOOD');
        } // end of behavior for FOOD
        
        // FOOD behavior
        // uml: enter / { this.tracer?.logActionCode("MenuOption(\"Select Food\"); "); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("MenuOption(\"Select Food\"); ");`
            this.tracer?.logActionCode("MenuOption(\"Select Food\"); ");
        } // end of behavior for FOOD
    }
    
    _FOOD_exit()
    {
        // FOOD behavior
        // uml: exit / { this.tracer?.exitState('FOOD'); }
        {
            // Step 1: execute action `this.tracer?.exitState('FOOD');`
            this.tracer?.exitState('FOOD');
        } // end of behavior for FOOD
        
        this.stateId = SpaceControlUiSm.StateId.MAIN_MENU_INNER;
    }
    
    _FOOD_down()
    {
        // FOOD behavior
        // uml: DOWN / { this.tracer?.edgeTransition('edge10'); } TransitionTo(DRINK)
        {
            // Step 1: Exit states until we reach `MAIN_MENU_INNER` state (Least Common Ancestor for transition).
            this._FOOD_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge10');`.
            this.tracer?.edgeTransition('edge10');
            
            // Step 3: Enter/move towards transition target `DRINK`.
            this._DRINK_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for FOOD
        
        // No ancestor handles this event.
    }
    
    _FOOD_pg_up()
    {
        let consume_event = false;
        
        // FOOD behavior
        // uml: (UP, PG_UP) / { this.tracer?.logActionCode("Beep();"); }
        {
            // Consume event `pg_up`.
            consume_event = true;
            // Step 1: execute action `this.tracer?.logActionCode("Beep();");`
            this.tracer?.logActionCode("Beep();");
        } // end of behavior for FOOD
        
        // Check if event has been consumed before calling ancestor handler.
        if (!consume_event)
        {
            this._MAIN_MENU_INNER_pg_up();
        }
    }
    
    _FOOD_right()
    {
        // FOOD behavior
        // uml: RIGHT / { this.tracer?.edgeTransition('edge9'); } TransitionTo(FOOD_MENU)
        {
            // Step 1: Exit states until we reach `MENU` state (Least Common Ancestor for transition).
            this._exitUpToStateHandler(SpaceControlUiSm.StateId.MENU);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge9');`.
            this.tracer?.edgeTransition('edge9');
            
            // Step 3: Enter/move towards transition target `FOOD_MENU`.
            this._ESC_CATCHER_1_enter();
            this._FOOD_MENU_enter();
            
            // FOOD_MENU.<InitialState> behavior
            // uml: / { this.tracer?.edgeTransition('edge19'); } TransitionTo(EAT_BURRITO)
            {
                // Step 1: Exit states until we reach `FOOD_MENU` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.edgeTransition('edge19');`.
                this.tracer?.edgeTransition('edge19');
                
                // Step 3: Enter/move towards transition target `EAT_BURRITO`.
                this._EAT_BURRITO_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for FOOD_MENU.<InitialState>
        } // end of behavior for FOOD
        
        // No ancestor handles this event.
    }
    
    _FOOD_up()
    {
        // FOOD behavior
        // uml: (UP, PG_UP) / { this.tracer?.logActionCode("Beep();"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("Beep();");`
            this.tracer?.logActionCode("Beep();");
        } // end of behavior for FOOD
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state SYSTEM_INFO
    ////////////////////////////////////////////////////////////////////////////////
    
    _SYSTEM_INFO_enter()
    {
        this.stateId = SpaceControlUiSm.StateId.SYSTEM_INFO;
        
        // SYSTEM_INFO behavior
        // uml: enter / { this.tracer?.enterState('SYSTEM_INFO'); }
        {
            // Step 1: execute action `this.tracer?.enterState('SYSTEM_INFO');`
            this.tracer?.enterState('SYSTEM_INFO');
        } // end of behavior for SYSTEM_INFO
        
        // SYSTEM_INFO behavior
        // uml: enter / { this.tracer?.logActionCode("MenuOption(\"System Info\");"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("MenuOption(\"System Info\");");`
            this.tracer?.logActionCode("MenuOption(\"System Info\");");
        } // end of behavior for SYSTEM_INFO
    }
    
    _SYSTEM_INFO_exit()
    {
        // SYSTEM_INFO behavior
        // uml: exit / { this.tracer?.exitState('SYSTEM_INFO'); }
        {
            // Step 1: execute action `this.tracer?.exitState('SYSTEM_INFO');`
            this.tracer?.exitState('SYSTEM_INFO');
        } // end of behavior for SYSTEM_INFO
        
        this.stateId = SpaceControlUiSm.StateId.MAIN_MENU_INNER;
    }
    
    _SYSTEM_INFO_down()
    {
        // SYSTEM_INFO behavior
        // uml: (DOWN, PG_DOWN) / { this.tracer?.logActionCode("Beep();"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("Beep();");`
            this.tracer?.logActionCode("Beep();");
        } // end of behavior for SYSTEM_INFO
        
        // No ancestor handles this event.
    }
    
    _SYSTEM_INFO_pg_down()
    {
        let consume_event = false;
        
        // SYSTEM_INFO behavior
        // uml: (DOWN, PG_DOWN) / { this.tracer?.logActionCode("Beep();"); }
        {
            // Consume event `pg_down`.
            consume_event = true;
            // Step 1: execute action `this.tracer?.logActionCode("Beep();");`
            this.tracer?.logActionCode("Beep();");
        } // end of behavior for SYSTEM_INFO
        
        // Check if event has been consumed before calling ancestor handler.
        if (!consume_event)
        {
            this._MAIN_MENU_INNER_pg_down();
        }
    }
    
    _SYSTEM_INFO_right()
    {
        // SYSTEM_INFO behavior
        // uml: RIGHT / { this.tracer?.edgeTransition('edge11'); } TransitionTo(SYSTEM_INFO_MENU)
        {
            // Step 1: Exit states until we reach `MENU` state (Least Common Ancestor for transition).
            this._exitUpToStateHandler(SpaceControlUiSm.StateId.MENU);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge11');`.
            this.tracer?.edgeTransition('edge11');
            
            // Step 3: Enter/move towards transition target `SYSTEM_INFO_MENU`.
            this._ESC_CATCHER_1_enter();
            this._SYSTEM_INFO_MENU_enter();
            
            // SYSTEM_INFO_MENU.<InitialState> behavior
            // uml: / { this.tracer?.logActionCode("MenuHeader(\"System Info\");");this.tracer?.edgeTransition('edge36'); } TransitionTo(DISTANCE)
            {
                // Step 1: Exit states until we reach `SYSTEM_INFO_MENU` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.logActionCode("MenuHeader(\"System Info\");");this.tracer?.edgeTransition('edge36');`.
                this.tracer?.logActionCode("MenuHeader(\"System Info\");");this.tracer?.edgeTransition('edge36');
                
                // Step 3: Enter/move towards transition target `DISTANCE`.
                this._DISTANCE_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for SYSTEM_INFO_MENU.<InitialState>
        } // end of behavior for SYSTEM_INFO
        
        // No ancestor handles this event.
    }
    
    _SYSTEM_INFO_up()
    {
        // SYSTEM_INFO behavior
        // uml: UP / { this.tracer?.edgeTransition('edge12'); } TransitionTo(DRINK)
        {
            // Step 1: Exit states until we reach `MAIN_MENU_INNER` state (Least Common Ancestor for transition).
            this._SYSTEM_INFO_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge12');`.
            this.tracer?.edgeTransition('edge12');
            
            // Step 3: Enter/move towards transition target `DRINK`.
            this._DRINK_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for SYSTEM_INFO
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state SPLASH_SCREEN
    ////////////////////////////////////////////////////////////////////////////////
    
    _SPLASH_SCREEN_enter()
    {
        this.stateId = SpaceControlUiSm.StateId.SPLASH_SCREEN;
        
        // SPLASH_SCREEN behavior
        // uml: enter / { this.tracer?.enterState('SPLASH_SCREEN'); }
        {
            // Step 1: execute action `this.tracer?.enterState('SPLASH_SCREEN');`
            this.tracer?.enterState('SPLASH_SCREEN');
        } // end of behavior for SPLASH_SCREEN
        
        // SPLASH_SCREEN behavior
        // uml: enter / { this.tracer?.logActionCode("ShowSplashScreen();"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("ShowSplashScreen();");`
            this.tracer?.logActionCode("ShowSplashScreen();");
        } // end of behavior for SPLASH_SCREEN
    }
    
    _SPLASH_SCREEN_exit()
    {
        // SPLASH_SCREEN behavior
        // uml: exit / { this.tracer?.exitState('SPLASH_SCREEN'); }
        {
            // Step 1: execute action `this.tracer?.exitState('SPLASH_SCREEN');`
            this.tracer?.exitState('SPLASH_SCREEN');
        } // end of behavior for SPLASH_SCREEN
        
        this.stateId = SpaceControlUiSm.StateId.ROOT;
    }
    
    _SPLASH_SCREEN_right()
    {
        // SPLASH_SCREEN behavior
        // uml: RIGHT / { this.tracer?.edgeTransition('edge1'); } TransitionTo(MENU)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this._SPLASH_SCREEN_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge1');`.
            this.tracer?.edgeTransition('edge1');
            
            // Step 3: Enter/move towards transition target `MENU`.
            this._MENU_enter();
            
            // MENU.<InitialState> behavior
            // uml: / { this.tracer?.edgeTransition('edge40'); } TransitionTo(MAIN_MENU_INNER)
            {
                // Step 1: Exit states until we reach `MENU` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.edgeTransition('edge40');`.
                this.tracer?.edgeTransition('edge40');
                
                // Step 3: Enter/move towards transition target `MAIN_MENU_INNER`.
                this._MAIN_MENU_INNER_enter();
                
                // Finish transition by calling pseudo state transition function.
                this._MAIN_MENU_INNER_InitialState_transition();
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for MENU.<InitialState>
        } // end of behavior for SPLASH_SCREEN
        
        // No ancestor handles this event.
    }
    
    // Thread safe.
    static stateIdToString(id)
    {
        switch (id)
        {
            case SpaceControlUiSm.StateId.ROOT: return "ROOT";
            case SpaceControlUiSm.StateId.DONE: return "DONE";
            case SpaceControlUiSm.StateId.MENU: return "MENU";
            case SpaceControlUiSm.StateId.ESC_CATCHER_1: return "ESC_CATCHER_1";
            case SpaceControlUiSm.StateId.DRINK_MENU: return "DRINK_MENU";
            case SpaceControlUiSm.StateId.FOOD_MENU: return "FOOD_MENU";
            case SpaceControlUiSm.StateId.EAT_BURRITO: return "EAT_BURRITO";
            case SpaceControlUiSm.StateId.EAT_MRE: return "EAT_MRE";
            case SpaceControlUiSm.StateId.EAT_SLUDGE: return "EAT_SLUDGE";
            case SpaceControlUiSm.StateId.EVENT_EATER_2: return "EVENT_EATER_2";
            case SpaceControlUiSm.StateId.COOKING_FOOD: return "COOKING_FOOD";
            case SpaceControlUiSm.StateId.COOKING_FOOD1: return "COOKING_FOOD1";
            case SpaceControlUiSm.StateId.SYSTEM_INFO_MENU: return "SYSTEM_INFO_MENU";
            case SpaceControlUiSm.StateId.BURRITO_COUNT: return "BURRITO_COUNT";
            case SpaceControlUiSm.StateId.DISTANCE: return "DISTANCE";
            case SpaceControlUiSm.StateId.SELF_DESTRUCT: return "SELF_DESTRUCT";
            case SpaceControlUiSm.StateId.SD_1: return "SD_1";
            case SpaceControlUiSm.StateId.SELF_DESTRUCT_OPTION: return "SELF_DESTRUCT_OPTION";
            case SpaceControlUiSm.StateId.MAIN_MENU_INNER: return "MAIN_MENU_INNER";
            case SpaceControlUiSm.StateId.DRINK: return "DRINK";
            case SpaceControlUiSm.StateId.FOOD: return "FOOD";
            case SpaceControlUiSm.StateId.SYSTEM_INFO: return "SYSTEM_INFO";
            case SpaceControlUiSm.StateId.SPLASH_SCREEN: return "SPLASH_SCREEN";
            default: return "?";
        }
    }
    
    // Thread safe.
    static eventIdToString(id)
    {
        switch (id)
        {
            case SpaceControlUiSm.EventId.DO: return "DO";
            case SpaceControlUiSm.EventId.DOWN: return "DOWN";
            case SpaceControlUiSm.EventId.ESC: return "ESC";
            case SpaceControlUiSm.EventId.LEFT: return "LEFT";
            case SpaceControlUiSm.EventId.PG_DOWN: return "PG_DOWN";
            case SpaceControlUiSm.EventId.PG_UP: return "PG_UP";
            case SpaceControlUiSm.EventId.RIGHT: return "RIGHT";
            case SpaceControlUiSm.EventId.UP: return "UP";
            default: return "?";
        }
    }
}

</script>

    <script type='module'>
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        import svgPanZoom from 'https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/+esm' ;
        mermaid.initialize({ startOnLoad: false });
        await mermaid.run();

        // svg-pan-zoom doesn't like the mermaid viewbox
        document.querySelector('svg').removeAttribute('viewBox');
        document.querySelector('svg').setAttribute('width', '100%');
        document.querySelector('svg').setAttribute('height', '100%');
        document.querySelector('svg').style['max-width'] = '';

        // don't scale the arrow when we scale the transition edge
        document.querySelectorAll('g defs marker[id$=barbEnd]').forEach(marker => {
            marker.setAttribute('markerUnits', 'userSpaceOnUse');
        });

        // https://github.com/StateSmith/StateSmith/issues/404
        // https://github.com/StateSmith/StateSmith/issues/294
        // rewrite $initial_state to a black circle
        document.querySelectorAll(`g[data-id*='(InitialState)']`).forEach(g=> {
          g.innerHTML = `<circle transform='translate(0,3)' height='14' width='14' r='14' class='state - start'></circle>`;
        })

        var panZoom = window.panZoom = svgPanZoom(document.querySelector('svg'), {
            zoomEnabled: true,
            dblClickZoomEnabled: false, // double click zoom gets in the way of quickly clicking on edge events
            controlIconsEnabled: true,
            fit: true,
            center: true
        });

        const diagramEventNamesArray = ['do', 'DOWN', 'ESC', 'LEFT', 'PG_DOWN', 'PG_UP', 'RIGHT', 'UP', ];

        // Mapping from state to available events
        const stateEventsMapping = {
  "SPLASH_SCREEN": [
    "RIGHT"
  ],
  "DONE": [],
  "MENU": [
    "ESC"
  ],
  "MAIN_MENU_INNER": [
    "ESC",
    "PG_DOWN",
    "PG_UP"
  ],
  "DRINK": [
    "DOWN",
    "ESC",
    "PG_DOWN",
    "PG_UP",
    "RIGHT",
    "UP"
  ],
  "FOOD": [
    "DOWN",
    "ESC",
    "PG_DOWN",
    "PG_UP",
    "RIGHT",
    "UP"
  ],
  "SYSTEM_INFO": [
    "DOWN",
    "ESC",
    "PG_DOWN",
    "PG_UP",
    "RIGHT",
    "UP"
  ],
  "ESC_CATCHER_1": [
    "ESC"
  ],
  "DRINK_MENU": [
    "ESC",
    "LEFT",
    "RIGHT"
  ],
  "FOOD_MENU": [
    "ESC",
    "LEFT"
  ],
  "EAT_BURRITO": [
    "DOWN",
    "ESC",
    "LEFT",
    "RIGHT"
  ],
  "EAT_SLUDGE": [
    "DOWN",
    "ESC",
    "LEFT",
    "RIGHT",
    "UP"
  ],
  "EAT_MRE": [
    "ESC",
    "LEFT",
    "RIGHT",
    "UP"
  ],
  "EVENT_EATER_2": [
    "ESC",
    "LEFT"
  ],
  "COOKING_FOOD1": [
    "do",
    "ESC",
    "LEFT"
  ],
  "COOKING_FOOD": [
    "do",
    "ESC",
    "LEFT"
  ],
  "SYSTEM_INFO_MENU": [
    "ESC",
    "LEFT",
    "PG_DOWN",
    "PG_UP"
  ],
  "BURRITO_COUNT": [
    "DOWN",
    "ESC",
    "LEFT",
    "PG_DOWN",
    "PG_UP",
    "UP"
  ],
  "DISTANCE": [
    "DOWN",
    "ESC",
    "LEFT",
    "PG_DOWN",
    "PG_UP",
    "UP"
  ],
  "SELF_DESTRUCT_OPTION": [
    "DOWN",
    "ESC",
    "LEFT",
    "PG_DOWN",
    "PG_UP",
    "RIGHT",
    "UP"
  ],
  "SELF_DESTRUCT": [
    "ESC",
    "LEFT",
    "PG_DOWN",
    "PG_UP"
  ],
  "SD_1": [
    "DO",
    "ESC",
    "LEFT",
    "PG_DOWN",
    "PG_UP"
  ]
};

        // https://github.com/StateSmith/StateSmith/issues/522
        const stateEdgeMapping = {
  "SPLASH_SCREEN": [
    1
  ],
  "DONE": [],
  "MENU": [
    2
  ],
  "MAIN_MENU_INNER": [
    2,
    3,
    4
  ],
  "DRINK": [
    2,
    3,
    4,
    6,
    7,
    8
  ],
  "FOOD": [
    2,
    3,
    4,
    9,
    10
  ],
  "SYSTEM_INFO": [
    2,
    3,
    4,
    11,
    12
  ],
  "ESC_CATCHER_1": [
    13
  ],
  "DRINK_MENU": [
    13,
    14,
    15
  ],
  "FOOD_MENU": [
    13,
    16
  ],
  "EAT_BURRITO": [
    13,
    16,
    17,
    18
  ],
  "EAT_SLUDGE": [
    13,
    16,
    20,
    21,
    22
  ],
  "EAT_MRE": [
    13,
    16,
    23,
    24
  ],
  "EVENT_EATER_2": [
    13,
    16
  ],
  "COOKING_FOOD1": [
    13,
    16,
    26
  ],
  "COOKING_FOOD": [
    13,
    16,
    27
  ],
  "SYSTEM_INFO_MENU": [
    13,
    28,
    29,
    30
  ],
  "BURRITO_COUNT": [
    13,
    28,
    29,
    30,
    31,
    32
  ],
  "DISTANCE": [
    13,
    28,
    29,
    30,
    33
  ],
  "SELF_DESTRUCT_OPTION": [
    13,
    28,
    29,
    30,
    34,
    35
  ],
  "SELF_DESTRUCT": [
    13,
    28,
    29,
    30
  ],
  "SD_1": [
    13,
    28,
    29,
    30,
    38
  ]
};

        // Get page element references
        const leftPane = document.querySelector('.main');
        const rightPane = document.querySelector('.sidebar');
        const gutter = document.querySelector('.gutter');

        // Function to resize panes
        function resizer(e) {          
          window.addEventListener('mousemove', mousemove);
          window.addEventListener('mouseup', mouseup);          
          let prevX = e.x;
          const rightPanel = rightPane.getBoundingClientRect();
                    
          function mousemove(e) {
            let newX = prevX - e.x;
            rightPane.style.width = rightPanel.width + newX + 'px';
            window.panZoom.resize();
            window.panZoom.fit();
            window.panZoom.center();
          }
          
          function mouseup() {
            window.removeEventListener('mousemove', mousemove);
            window.removeEventListener('mouseup', mouseup);
          }                  
        }

        // Add mouse down event listener for the resizer
        gutter.addEventListener('mousedown', resizer);



        //------------------- drop down functionality start -------------------
        const dropdownButton = document.getElementById('settings-dropdown-button');
        const dropdownDiv = document.getElementById('myDropdown');

        dropdownButton.addEventListener('click', toggleDropdown);

        document.getElementById('clear-button').addEventListener('click', function() {
          const tbody = document.querySelector('#event-logs tbody');
          tbody.innerHTML = '';
        });

        /* When the user clicks on the button, 
        toggle between hiding and showing the dropdown content */
        function toggleDropdown(event) {
          dropdownDiv.classList.toggle('show');
          event.stopPropagation(); // Prevent click from causing the window click handler to close the dropdown
        }

        // Close the dropdown if the user clicks outside of it
        window.onclick = function(event) {
          const isClickedOutsideDropdownDiv = !dropdownDiv.contains(event.target);

          if (isClickedOutsideDropdownDiv) {
            dropdownDiv.classList.remove('show');
          }
        }

        // Close the dropdown if the user presses Escape
        document.addEventListener('keydown', function(event) {
          if (event.key === 'Escape') {
            dropdownDiv.classList.remove('show');
          }
        });

        // Set the state of the timestamp checkbox
        document.getElementById('savedSetting_timestamps').addEventListener('change', function() {
          if(this.checked) {
            document.querySelector('table.console').classList.add('timestamps');
          } else {
            document.querySelector('table.console').classList.remove('timestamps');
          }
        });

        // Set up hide irrelevant events checkbox state and event listener
        document.getElementById('savedSetting_hideIrrelevantEvents').addEventListener('change', function() {
          // When checkbox state changes, only update button visibility, not availability
          updateButtonVisibility();
        });

        // store and restore checkbox states using localStorage.
        // DO AFTER event listeners are set up, so that restored state will trigger the change event and apply the setting.
        const dropdownCheckboxes = document.querySelectorAll(`.dropdown-content input[type='checkbox']`);
        dropdownCheckboxes.forEach(checkbox => {

          if (checkbox.id.startsWith('savedSetting_') === false)
          {
            console.log(`Skipping checkbox with id '${checkbox.id}' for localStorage state saving/restoring because it does not start with 'savedSetting_'.`, checkbox);
            return;
          }

          // append a note to the checkbox title that the state is saved in localStorage
          checkbox.parentElement.title += '\nThis setting is saved in localStorage and will persist across page reloads.';

          // Restore state from localStorage
          const savedState = localStorage.getItem(checkbox.id);
          if (savedState !== null) {
            checkbox.checked = (savedState === 'true');
            checkbox.dispatchEvent(new Event('change')); // Trigger change event to apply the setting
            console.log(`Restored checkbox value for '${checkbox.id}' to '${checkbox.checked}'`, checkbox);
          }

          // Save state to localStorage on change
          checkbox.addEventListener('change', function() {
            localStorage.setItem(checkbox.id, this.checked);
            console.log(`Saved checkbox value for '${checkbox.id}' to '${this.checked}'`, checkbox);
          });
        });

        //------------------- drop down functionality end -------------------



        // Convert a date to a string in the format HH:MM:SS.sss
        function formatTime(date) {
            return date.getHours().toString().padStart(2, '0') + ':' +
                date.getMinutes().toString().padStart(2, '0') + ':' +
                date.getSeconds().toString().padStart(2, '0') + '.' +
                date.getMilliseconds().toString().padStart(3, '0');
        }

        // Add a row to the history table.
        function addEventLogRow(time, event, html = false) {
            var row = document.createElement('tr');
            var timeCell = document.createElement('td');
            timeCell.innerText = formatTime(time);
            timeCell.classList.add('timestamp');
            var eventCell = document.createElement('td');

            if(html) {
              eventCell.innerHTML = event;
            } else {
              eventCell.innerText = event;
            }

            row.appendChild(timeCell);
            row.appendChild(eventCell);
            document.querySelector('#event-logs tbody').appendChild(row);
        }

        var sm = new SpaceControlUiSm();
        window.StateSmith_sm = sm; // expose to global scope so people can interact with it from the console if they want to.

        // prompt the user to evaluate guards manually
        sm.evaluateGuard = (vertexName, behaviorUml) => {
            return confirm(`Evaluate guard for\n${vertexName} behavior:\n${behaviorUml}.\n\nPress 'OK' to evaluate guard as true and 'Cancel' to evaluate it as false.`);
        }; 

        const highlightedEdges = new Set();
        function highlightEdge(edgeId) {
            var edge = document.getElementById(edgeId);
            if (edge) {
              edge.classList.add('active');
              highlightedEdges.add(edge);
            }
        }

        function clearHighlightedEdges() {
            for (const edge of highlightedEdges) {
              edge.classList.remove('active');
              const showOldTraversal = false;
              if (showOldTraversal) {
                  // shows that the edge was traversed. Optional, but kinda nice.
                  edge.style.stroke = 'green';
              }
            }
            highlightedEdges.clear();
        }

        function clearHighlightedStates() {
            document.querySelectorAll('g[id].active').forEach(e => e.classList.remove('active'));
        }

        // Function to update event button states (availability and visibility)
        function updateEventButtonStates(currentStateDiagramName) {
            const availableEvents = stateEventsMapping[currentStateDiagramName] || [];

            diagramEventNamesArray.forEach(eventName => {
                const button = document.getElementById('button_' + eventName);
                if (button) {
                    const hasEventHandler = availableEvents.includes(eventName);

                    let title = `Dispatch event '${eventName}' to the state machine.`;

                    if (hasEventHandler) {
                        button.classList.remove('hasNoEventHandler');
                    } else {
                        button.classList.add('hasNoEventHandler');
                        title += '\nThere is no handler for this event in the current state.\nDispatching is valid, but will have no effect on the state machine.';
                    }

                    title += '\nThere is a âš™ï¸ setting to disable these tooltips.';

                    const showTooltips = document.getElementById('savedSetting_showEventButtonTooltips').checked
                    if (showTooltips) {
                        button.title = title;
                    } else {
                        button.removeAttribute('title');
                    }
                }
            });
            
            // Update visibility based on checkbox state
            updateButtonVisibility();
        }

        // Function to update button visibility based on Hide Unused checkbox
        function updateButtonVisibility() {
            const hideIrrelevantEvents = document.getElementById('savedSetting_hideIrrelevantEvents').checked;
            
            diagramEventNamesArray.forEach(eventName => {
                const button = document.getElementById('button_' + eventName);
                if (button) {
                    // Toggle hidden class based on checkbox state and button has no event handler
                    button.classList.toggle('hidden', hideIrrelevantEvents && button.classList.contains('hasNoEventHandler'));
                }
            });
        }

        // https://github.com/StateSmith/StateSmith/issues/522
        function updateEdgeAvailability(currentStateDiagramName) {
            const availableEdges = stateEdgeMapping[currentStateDiagramName] || [];

            document.querySelectorAll('.transition.available').forEach(element => {
              element.classList.remove('available');
            });

            availableEdges.forEach(edgeId => {
                var domId = `edge${edgeId}`;
                var edge = document.getElementById(domId);
                if (edge) {
                  edge.classList.add('available');
                }
            });
        }

        // The simulator uses a tracer callback to perform operations such as 
        // state highlighting and logging.
        sm.tracer = {
            enterState: (mermaidName) => {
                var e = document.querySelector('g[data-id=' + mermaidName + ']') || document.querySelector('g[id=' + mermaidName + ']');

                if(e) {
                  e.classList.add('active');
                  panOnScreen(e);
                } else {
                  console.warn(`Could not find mermaid element to highlight for state '${mermaidName}'.`);
                }

                if (document.getElementById('savedSetting_verboseEnter').checked) {
                    sm.tracer.log(`âž¡ï¸ Entered <span class='identifier'>${mermaidName}</span>`, true);
                }
                
                updateEventButtonStates(mermaidName);
                updateEdgeAvailability(mermaidName);
            },
            exitState: (mermaidName) => {
                document.querySelector('g[data-id=' + mermaidName + ']')?.classList.remove('active');
                document.querySelector('g[id=' + mermaidName + ']')?.classList.remove('active');

                if (document.getElementById('savedSetting_verboseExit').checked) {
                    sm.tracer.log(`â†©ï¸ Exited <span class='identifier'>${mermaidName}</span>`, true);
                }
            },
            edgeTransition: (edgeId) => {
                highlightEdge(edgeId);
            },
            logHistoryVarUpdate: (varName, newValue) => {
                if (document.getElementById('savedSetting_verboseHistory').checked) {
                    sm.tracer.log(`ðŸ•‘ HistoryVar(<span class='identifier'>${varName}</span>) = <span class='identifier'>${newValue}</span>`, true);
                }
            },
            logHistoryTransition: (description) => {
                sm.tracer.log(`ðŸ•‘ History: ${description}.`);
            },
            logGuardCodeEvaluation: (guardCode) => {
                sm.tracer.log(`<span title='Guard code manually evaluated by user for simulation.'>ðŸ›¡ï¸ Guard: <code>[ ${guardCode} ]</code></span>`, true);
            },
            logActionCode: (actionCode) => {
                sm.tracer.log(`<span title='Your actual state machine will run this action code.'>âš¡ Action: <code>${actionCode}</code></span>`, true);
            },
            log: (message, html=false) => {
                addEventLogRow(new Date(), message, html);
            }
        };

        // https://github.com/StateSmith/StateSmith/issues/519
        function forceStateChange(stateNameAnyCase)
        {
          const stateName = stateNameAnyCase.toUpperCase();

          // get ID from stateName
          const stateId = SpaceControlUiSm.StateId[stateName];
          if (stateId === undefined) {
            console.error(`Invalid state name '${stateNameAnyCase}' passed to forceStateChange.`);
            console.log('Valid state names are (in any case):', Object.keys(SpaceControlUiSm.StateId).slice(1)); // slice(1) to remove ROOT from the list of valid states since it cannot be forced to.
            return;
          }

          // note! This and other ROOT code assumes that it is the first state. This is a fairly safe assumption, but if that ever changes this code will need to be updated.
          if (Object.keys(SpaceControlUiSm.StateId)[0] !== 'ROOT') {
            console.warn(`ROOT not found. This should happen. Please open a bug:`, 'https://github.com/StateSmith/StateSmith/issues/new');
          }

          if (stateId === 0) {
            console.error(`Cannot force state to state machine ROOT.`,);
            return;
          }

          let mermaidElement = null;

          // we now need the mermaid state element for the state of interest
          document.querySelectorAll('g[data-id],g[id]').forEach(e => {
            const lowerName = stateNameAnyCase.toLowerCase();
            const matchesLeafState = e.getAttribute('data-id') && e.getAttribute('data-id').toLowerCase() === lowerName;
            const matchesCompoundState = e.getAttribute('id').toLowerCase() === lowerName;

            if (matchesCompoundState || matchesLeafState) {
              mermaidElement = e;
            }
          });

          if (!mermaidElement) {
            console.error(`Could not find mermaid element for state name '${stateNameAnyCase}'. This is unexpected as we already found matching state id. Please open a bug:`, 'https://github.com/StateSmith/StateSmith/issues/new');
            return;
          }

          // force the state change. NOTE! This will only work with Algorithm Balanced2. See https://github.com/StateSmith/StateSmith/wiki/Algorithms.
          sm.stateId = stateId;
          
          // remove the active class from all states, then add it to the forced state.
          clearHighlightedStates();
          // mermaidElement.classList.add('active'); // done by state enter below

          sm.tracer.log(`<span class='dispatched'><a href='https://github.com/StateSmith/StateSmith/issues/519' target='_blank' title='May have impacts! Click for details.'><span class='forced-state'>FORCED STATE</span> to <span class='identifier'>${stateNameAnyCase}</span></span></a>`, true);

          // execute state's enter function
          const enterFunction = sm['_' + stateName + '_enter'];
          if (enterFunction) {
            enterFunction.call(sm); // need to call with sm as 'this' context so that it can update the state machine state and do other things that require access to 'this'.
          } else {
            console.warn(`No enter function found for state '${stateName}'. This is unexpected. Please open a bug:`, 'https://github.com/StateSmith/StateSmith/issues/new');
          }            

          panOnScreen(mermaidElement);
          
          let mermaidStateName;
          
          if (mermaidElement.getAttribute('data-id')) {
            mermaidStateName = mermaidElement.getAttribute('data-id');
          } else {
             mermaidStateName = mermaidElement.getAttribute('id');
          }
          updateEventButtonStates(mermaidStateName);
          clearHighlightedEdges();

          console.log(`Forced state to ${stateNameAnyCase}. See https://github.com/StateSmith/StateSmith/issues/519`);
        }

        // https://github.com/StateSmith/StateSmith/issues/519
        {
          // find simple state node labels
          // Make sure to test with simple states that are just a state name, and ones that have addition labels for non-transition behaviors.
          document.querySelectorAll('g.statediagram-state[data-id] g.label > foreignObject:first-of-type .nodeLabel').forEach(nodeLabel => {
            // confirm that node label matches an actual state. This weeds out pseudo states like `$H`, `$HC`, `$entry_pt`, ...
            const stateName = nodeLabel.textContent.toUpperCase();
            const stateId = SpaceControlUiSm.StateId[stateName];
            if (stateId === undefined) {
              return;
            }

            nodeLabel.classList.add('clickableDiagramElement');
          });

          // find composite state node labels
          document.querySelectorAll('g.statediagram-state[id].statediagram-cluster .nodeLabel').forEach(nodeLabel => {
            nodeLabel.classList.add('clickableDiagramElement');
          });

          // allow clicking states to force state machine to that state.
          document.querySelectorAll('.clickableDiagramElement').forEach(nodeLabel => {
            const stateElement = nodeLabel.closest('g.statediagram-state[id]');

            if (!stateElement)
            {
              console.warn('Open bug ticket? Failed finding statediagram-state for', nodeLabel);
            }

            nodeLabel.addEventListener('click', (event) => {

              if (savedSetting_requireCtrlForForceState.checked && !event.ctrlKey) {
                  // if the setting to require ctrl key is enabled, and the ctrl key is not pressed, do not force state.
                  return;
              }

              let stateName = null;

              // this is a bit hacky. Composite states have their name in the 'id' attribute, while simple states have their name in the 'data-id' attribute. We need to check both to support both types of states.
              if (stateElement.classList.contains('statediagram-cluster')) {
                stateName = stateElement.getAttribute('id');
              } else {
                stateName = stateElement.getAttribute('data-id');
              }

              forceStateChange(stateName);
            });
          });
        }

        // export forceStateChange to global scope so it can be called from the console for testing purposes.
        window.StateSmith_forceStateChange = forceStateChange;

        // Wire up the buttons that dispatch events for the state machine.
        diagramEventNamesArray.forEach(diagramEventName => {
            var button = document.createElement('button');
            button.id = 'button_' + diagramEventName;
            button.className = 'event-button';
            button.innerText = diagramEventName;
            button.addEventListener('click', () => {

                // allow dispatching events even if they have no handler in current state to aid in learning
                // https://github.com/StateSmith/StateSmith/issues/497
                const alwaysAllowEventDispatch = true;

                if (alwaysAllowEventDispatch || !button.classList.contains('hasNoEventHandler')) {
                    clearHighlightedEdges();
                    sm.tracer?.log(`<span class='dispatched'><span class='event-id'>${diagramEventName}</span> DISPATCHED</span>`, true);
                    const fsmEventName = diagramEventName.toUpperCase();
                    sm.dispatchEvent(SpaceControlUiSm.EventId[fsmEventName]); 
                }
            });
            document.getElementById(`buttons`).appendChild(button);
        });

        // clicking on edge label will try to send event
        // https://github.com/StateSmith/StateSmith/issues/521
        // DO AFTER buttons exist as we rely on them.
        {
          document.querySelectorAll('g span.edgeLabel').forEach(edgeLabelElement => {
            const edgeLabel = edgeLabelElement.textContent.trim();

            if (!edgeLabel)
            {
              return;
            }

            // ignore any decimal numbers at start, then look for first word which should be event name.
            // This allows for edge labels like: 
            //    `1. INCREASE [count >= 3] / { count++; }` and 
            //    `1.1. MY_EVENT`
            // See https://github.com/StateSmith/StateSmith/wiki/Behaviors
            const eventRegex = /^(?:\d+\.)?(?:\d+\.\s+)?(\w+)\b/;
            const match = edgeLabel.match(eventRegex);
            if (!match) {
              console.log(`Could not parse event name from edge label. This is normal for certain edges. Edge label text was: '${edgeLabel}'.`, edgeLabelElement);
              return;
            }

            const eventName = match[1];
            const button = document.getElementById('button_' + eventName);
            if (!button)
            {
              console.log(`No event button found for event name '${eventName}'. This is normal for certain edges.`, edgeLabelElement);
              return;
            }

            edgeLabelElement.classList.add('clickableDiagramElement');

            edgeLabelElement.addEventListener('click', (event) => {
              button.click();
            });
          });
        }

        sm.tracer?.log(`<span class='dispatched'>START</span>`, true);
        sm.start(); // This will cause `updateEventButtonStates()` to be called.

        function panOnScreen(element) {
            if (!element) return;

            // NOTE! There's some hacks here to prevent multiple rapid calls to panOnScreen.
            // If one transition causes 3 state enters, and each state entry calls panOnScreen, the screen often goes blank.
            // I would guess caused by window.panZoom.panBy()
            // So we put in a little delay hack in here and cancel any pending panning action.

            window.ss_lastPanActionHandle = window.ss_lastPanActionHandle || null;

            if (window.ss_lastPanActionHandle) {
                clearTimeout(window.ss_lastPanActionHandle);
                window.ss_lastPanActionHandle = null;
            }

            window.ss_lastPanActionHandle = setTimeout(() => {
                var bounds = element.getBoundingClientRect();
                if (bounds.x < 0 || bounds.y < 0) {
                    var x = Math.max(0, -bounds.x + 20);
                    var y = Math.max(0, -bounds.y + 20);
                    window.panZoom.panBy({ x: x, y: y });
                }
                var panebounds = document.querySelector('svg').getBoundingClientRect();
                if (bounds.x > panebounds.width || bounds.y > panebounds.height) {
                    var x = Math.min(0, panebounds.width - bounds.x - bounds.width - 20);
                    var y = Math.min(0, panebounds.height - bounds.y - bounds.height - 20);
                    window.panZoom.panBy({ x: x, y: y });
                }
            }, 1);
        }
    </script>


  </body>
</html>
