<!-- 
  -- This file was generated by StateSmith.
  -- It serves as an example of how to use the generated state machine in a web page.
  -- It also serves as an interactive console that you can use to validate the
  -- state machine's behavior.
  --
  -- Using BeadSorter.js generally looks like:
  --   var sm = new BeadSorter();
  --   sm.start();
  --
  -- And then using sm.dispatchEvent() to dispatch events to the state machine.
  -->
<html>
  <head>
    <link rel='icon' type='image/png' href='https://statesmith.github.io/favicon.png'>
    <link rel='stylesheet' href='https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined'>
    <style>
      body {
        display: flex;
        flex-direction: row;
        margin: 0px;
      }

      /* Fix for mermaid content requiring scroll bars https://github.com/StateSmith/StateSmith/issues/288 */
      pre.mermaid {
        margin: 0px;
      }

      .wrapper {
        height: 100vh;
        width: 100vw;
        display: flex;
      }

      .pane {
        padding: 1em;
        min-width: 200px;
      }

      .titlebar-icon {
        font-family: 'Material Symbols Outlined', sans-serif;
        font-size: 16px;
        color: #777;
        border-radius: 5px;
      }

      .gutter {
        width: 10px;
        height: 100%;
        background: #ccc;
        position: absolute;
        top: 0;
        left: 0;
        cursor: col-resize;
      }

      .main {
        flex: 1;
        overflow: auto;
        padding: 10px;
      }

      .sidebar {
        width: 300px;
        padding-top: 0px;
        position: relative;
        background-color: #f0f0f0;
        border-left: 1px solid #ccc;
        display: flex;
        flex-direction: column;
      }

      #buttons {
        display: flex;
        flex-direction: column;
      }

      .titlebar {
        background-color: #ddd;
        border-bottom: 1px solid #ccc;
        font-weight: bold;
        padding: 5px;
        display: flex;
      }

      .console {
        border-collapse: collapse;
        margin-top: 10px;
        width: 100%;
      }

      table.console td.timestamp {
        display: none;
      }

      table.console.timestamps td.timestamp {
        display: table-cell;
      }

      table.console td {
          color: rgba(0, 0, 0, 0.7);
      }

      table.console td .dispatched {
          font-weight: bold;
          color: rgba(0, 0, 0, 1);
      }

      table.console tr:has(+tr td .dispatched) {
          border-bottom: 0px;
      }

      table.console tr:has(+tr td .dispatched) td {
          padding-bottom: 25px;
      }

      .console th {
        background-color: #f0f0f0;
        border-bottom: 1px solid #ccc;
        font-weight: normal;
        padding: 5px;
        text-align: left;
      }

      .console tbody {
        font-family: monospace;
      }

      .console tr {
        border-bottom: 1px solid #ccc;
      }

      .console td {
        padding: 5px;
      }
  
      .console td.timestamp {
        font-size: small;
      }

      .history {
        margin-top: 30px;       
        display: flex;
        overflow: auto;    
        flex-direction: column-reverse;
      }

      .console tr:last-child td {
        border-bottom: none;
      }

      .dispatched {
        font-weight: bold;
      }

      .dispatched > .trigger {
        border: 1px solid #000;
        border-radius: 4px;
        padding: 2px 10px 2px 10px;
      }

      button {
        margin: 5px;
      }

      .dropbtn {
        border: none;
        cursor: pointer;
      }

      .dropbtn:hover, .dropbtn:focus {
        background-color: #f1f1f1;
      }

      .dropdown {
        position: relative;
        display: inline-block;
        margin-left: auto;
      }

      .dropdown-content {
        display: none;
        position: absolute;
        right: 0;
        background-color: #f1f1f1;
        min-width: 160px;
        overflow: auto;
        box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
        z-index: 1;
      }

      .dropdown-content .dropdown-item {
        padding: 12px 16px;
        font-weight: normal;
      }

      .show {display: block;}

      .transition.active {
        stroke: #fff5ad !important;
        stroke-width: 5px !important;
        filter: drop-shadow( 3px 3px 2px rgba(0, 0, 0, .7));
      }

      .statediagram-state.active > * {
        fill: #fff5ad !important;
        stroke-width: 2px !important;
      }

    </style>
  </head>

  <body>
    <div class="wrapper">
    <div class="pane main">
        <pre class="mermaid">
stateDiagram

state Running {

        state TrainingMode {

                state ReadEmptySlot {

                        state "$initial_state" as ReadEmptySlot.(InitialState)

                        ReadEmptySlot__Dropoff

                        ReadEmptySlot__Dropoff : ReadEmptySlot__Dropoff

                        ReadEmptySlot__Dropoff : enter / #123; picker.moveToAndShimmy(DEG_DROPOFF)#59; #125;

                        ReadEmptySlot__Sensor

                        ReadEmptySlot__Sensor : ReadEmptySlot__Sensor

                        ReadEmptySlot__Sensor : enter / #123; picker.moveTo(DEG_SENSOR)#59;\nempties++#59;\nsorter.readColor()#59; #125;

                        state "$HC" as ReadEmptySlot.(HistoryContinue)

                }

                state ReadJammedSlot {

                        state "$initial_state" as ReadJammedSlot.(InitialState)

                        ReadJammedSlot__Dropoff

                        ReadJammedSlot__Dropoff : ReadJammedSlot__Dropoff

                        ReadJammedSlot__Dropoff : enter / #123; picker.moveToAndShimmy(DEG_DROPOFF)#59; #125;

                        Jammed

                        Jammed : Jammed

                        Jammed : enter / #123; picker.moveTo(DEG_JAMMED_READ)#59; #125;

                        ReadJammedSlot__Sensor

                        ReadJammedSlot__Sensor : ReadJammedSlot__Sensor

                        ReadJammedSlot__Sensor : enter / #123; jammies++#59;\nsorter.readColor()#59; #125;

                        state "$HC" as ReadJammedSlot.(HistoryContinue)

                }

                state ReadSlot {

                        state "$initial_state" as ReadSlot.(InitialState)

                        ReadSlot__Dropoff

                        ReadSlot__Dropoff : ReadSlot__Dropoff

                        ReadSlot__Dropoff : enter / #123; picker.moveToAndShimmy(DEG_DROPOFF)#59; #125;

                        TrainingMode__Pickup

                        TrainingMode__Pickup : TrainingMode__Pickup

                        TrainingMode__Pickup : enter / #123; picker.moveTo(DEG_PICKUP)#59; #125;

                        ReadSlot__Sensor

                        ReadSlot__Sensor : ReadSlot__Sensor

                        ReadSlot__Sensor : enter / #123; picker.shimmyAndMoveTo(DEG_SENSOR)#59;\nsorter.readColor()#59;\nsorter.runTraining()#59;\nsorter.shimmyAndMoveTo(DEFAULT_BIN)#59; #125;

                        state "$HC" as ReadSlot.(HistoryContinue)

                }

                TrainingMode__Start

                TrainingMode__Start : TrainingMode__Start

                TrainingMode__Start : enter / #123; modeDisplay.print("TRAINING")#59; #125;

                state "$initial_state" as TrainingMode.(InitialState)

                state "$HC" as TrainingMode.(HistoryContinue)

        }

        state SortingMode {

                SortingMode__Dropoff

                SortingMode__Dropoff : SortingMode__Dropoff

                SortingMode__Dropoff : enter / #123; picker.moveToAndShimmy(DEG_DROPOFF)#59; #125;

                SortingMode__Pickup

                SortingMode__Pickup : SortingMode__Pickup

                SortingMode__Pickup : enter / #123; picker.moveTo(DEG_PICKUP)#59; #125;

                state "$initial_state" as SortingMode.(InitialState)

                SortingMode__Start

                SortingMode__Start : SortingMode__Start

                SortingMode__Start : enter / #123; modeDisplay.clear()#59; #125;

                state "$HC" as SortingMode.(HistoryContinue)

                SortingMode__Sensor

                SortingMode__Sensor : SortingMode__Sensor

                SortingMode__Sensor : enter / #123; picker.shimmyAndMoveTo(DEG_SENSOR)#59;\nsorter.shimmyAndMoveTo(min(sorter.readColor(), DEFAULT_BIN))#59; #125;

        }

        state SetupCheck {

                state "$initial_state" as SetupCheck.(InitialState)

                Tour

                Tour : Tour

                Tour : enter / #123; tourBin = min(tourBin+1, DEFAULT_BIN)#59;\nsorter.moveTo(tourBin)#59; #125;

                SetupCheck__Start

                SetupCheck__Start : SetupCheck__Start

                SetupCheck__Start : enter / #123; modeDisplay.print("SETUP CHECK")#59;\nsorter.moveTo(0)#59;\npicker.moveTo(DEG_DROPOFF)#59;\npicker.moveTo(DEG_PICKUP)#59;\nt1Restart()#59; #125;

                state "$HC" as SetupCheck.(HistoryContinue)

                state AdjustServoOffsets {

                        DECREASE

                        DECREASE : DECREASE

                        DECREASE : enter / #123; picker.adjustOffset(-2)#59; #125;

                        INCREASE

                        INCREASE : INCREASE

                        INCREASE : enter / #123; picker.adjustOffset(2)#59; #125;

                        Wait

                        Wait : Wait

                        Wait : enter / #123; picker.displayOffset()#59; #125;

                        state "$initial_state" as AdjustServoOffsets.(InitialState)

                }

        }

        state "$initial_state" as Running.(InitialState)

        state "$H" as Running.(History)

}

Paused

Paused : Paused

state "$initial_state" as ROOT.(InitialState)

Running --> Paused : BUTTON0

ReadEmptySlot.(InitialState) --> ReadEmptySlot__Dropoff

ReadEmptySlot__Dropoff --> ReadEmptySlot__Sensor : do

ReadEmptySlot__Sensor --> ReadEmptySlot__Dropoff : do

ReadEmptySlot__Sensor --> ReadJammedSlot : 1. do [empties>=NUM_EMPTY_READS]

ReadJammedSlot.(InitialState) --> Jammed

ReadJammedSlot__Dropoff --> Jammed : do

ReadJammedSlot__Dropoff --> ReadSlot : 1. do [jammies>=NUM_JAMMED_READS]

Jammed --> ReadJammedSlot__Sensor : do

ReadJammedSlot__Sensor --> ReadJammedSlot__Dropoff : do

ReadSlot.(InitialState) --> TrainingMode__Pickup

ReadSlot__Dropoff --> TrainingMode__Pickup : do

ReadSlot__Dropoff --> SortingMode : 1. do [sorter.isTrainingDone()]

TrainingMode__Pickup --> ReadSlot__Sensor : do

ReadSlot__Sensor --> ReadSlot__Dropoff : do

TrainingMode__Start --> ReadEmptySlot : do

TrainingMode.(InitialState) --> TrainingMode__Start

SortingMode__Dropoff --> SortingMode__Pickup : do

SortingMode__Pickup --> SortingMode__Sensor : do

SortingMode.(InitialState) --> SortingMode__Start

SortingMode__Start --> SortingMode__Pickup : do

SortingMode__Sensor --> SortingMode__Dropoff : do

SetupCheck.(InitialState) --> SetupCheck__Start

Tour --> TrainingMode : 1. do [tourBin>=DEFAULT_BIN]

Tour --> Tour : do [true]

SetupCheck__Start --> Tour : do [t1After(3s)]

SetupCheck__Start --> AdjustServoOffsets : BUTTON2

AdjustServoOffsets --> SetupCheck__Start : BUTTON2

DECREASE --> Wait : do

INCREASE --> Wait : do

Wait --> DECREASE : BUTTON1

Wait --> INCREASE : BUTTON2

AdjustServoOffsets.(InitialState) --> Wait

Running.(InitialState) --> Running.(History)

Running.(History) --> SetupCheck

Paused --> Running : BUTTON0

ROOT.(InitialState) --> Running



        </pre>
    </div>

    <div class="pane sidebar">
        <div id="buttons">
            <div class="titlebar">Events            
              <div class='dropdown'>
                <span id='dropbtn' class='titlebar-icon dropbtn'>settings</span>
                <div id='myDropdown' class='dropdown-content'>
                  <div class='dropdown-item'>
                    <input type='checkbox' id='timestamps' name='timestamps' value='Timestamps'>
                    <label for='timestamps'>Timestamps</label>
                  </div>
                </div>
              </div>            
          </div>
        </div>

        <div class="history">
          <table class="console">
            <tbody>
            </tbody>
          </table>
        </div>

        <div class="gutter"></div>
    </div>
    </div>

<script>
// Autogenerated with StateSmith.
// Algorithm: Balanced2. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

// Generated state machine
class BeadSorter
{
// Null by default.
// May be overridden to override guard evaluation (eg. in a simulator)
evaluateGuard = null;
    static EventId = 
    {
        DO : 0, // The `do` event is special. State event handlers do not consume this event (ancestors all get it too) unless a transition occurs.
        BUTTON0 : 1,
        BUTTON1 : 2,
        BUTTON2 : 3,
    }
    static { Object.freeze(this.EventId); }
    
    static EventIdCount = 4;
    static { Object.freeze(this.EventIdCount); }
    
    static StateId = 
    {
        ROOT : 0,
        PAUSED : 1,
        RUNNING : 2,
        SETUPCHECK : 3,
        ADJUSTSERVOOFFSETS : 4,
        DECREASE : 5,
        INCREASE : 6,
        WAIT : 7,
        SETUPCHECK__START : 8,
        TOUR : 9,
        SORTINGMODE : 10,
        SORTINGMODE__DROPOFF : 11,
        SORTINGMODE__PICKUP : 12,
        SORTINGMODE__SENSOR : 13,
        SORTINGMODE__START : 14,
        TRAININGMODE : 15,
        READEMPTYSLOT : 16,
        READEMPTYSLOT__DROPOFF : 17,
        READEMPTYSLOT__SENSOR : 18,
        READJAMMEDSLOT : 19,
        JAMMED : 20,
        READJAMMEDSLOT__DROPOFF : 21,
        READJAMMEDSLOT__SENSOR : 22,
        READSLOT : 23,
        READSLOT__DROPOFF : 24,
        READSLOT__SENSOR : 25,
        TRAININGMODE__PICKUP : 26,
        TRAININGMODE__START : 27,
    }
    static { Object.freeze(this.StateId); }
    
    static StateIdCount = 28;
    static { Object.freeze(this.StateIdCount); }
    
    static Running_HistoryId = 
    {
        SETUPCHECK : 0, // default transition
        TRAININGMODE : 1,
        SORTINGMODE : 2,
        READEMPTYSLOT : 3,
        READJAMMEDSLOT : 4,
        READSLOT : 5,
        TRAININGMODE__START : 6,
        READEMPTYSLOT__DROPOFF : 7,
        READEMPTYSLOT__SENSOR : 8,
        READJAMMEDSLOT__DROPOFF : 9,
        JAMMED : 10,
        READJAMMEDSLOT__SENSOR : 11,
        READSLOT__DROPOFF : 12,
        TRAININGMODE__PICKUP : 13,
        READSLOT__SENSOR : 14,
        SORTINGMODE__DROPOFF : 15,
        SORTINGMODE__PICKUP : 16,
        SORTINGMODE__START : 17,
        SORTINGMODE__SENSOR : 18,
        TOUR : 19,
        SETUPCHECK__START : 20,
        ADJUSTSERVOOFFSETS : 21,
    }
    static { Object.freeze(this.Running_HistoryId); }

    
    // Used internally by state machine. Feel free to inspect, but don't modify.
    stateId;
    
    // Variables. Can be used for inputs, outputs, user variables...
    vars = {
        Running_history: undefined,
    };
    
    // Starts the state machine. Must be called before dispatching events. Not thread safe.
    start()
    {
        this.#ROOT_enter();
        // ROOT behavior
        // uml: TransitionTo(ROOT.<InitialState>)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
            // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.
            
            // ROOT.<InitialState> behavior
            // uml: / { this.tracer?.edgeTransition("edge36"); } TransitionTo(Running)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.edgeTransition("edge36");`.
                this.tracer?.edgeTransition("edge36");
                
                // Step 3: Enter/move towards transition target `Running`.
                this.#RUNNING_enter();
                
                // Finish transition by calling pseudo state transition function.
                this.#Running_InitialState_transition();
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for ROOT.<InitialState>
        } // end of behavior for ROOT
    }
    
    // Dispatches an event to the state machine. Not thread safe.
    // Note! This function assumes that the `eventId` parameter is valid.
    dispatchEvent(eventId)
    {
        switch (this.stateId)
        {
            // STATE: BeadSorter
            case BeadSorter.StateId.ROOT:
                switch (eventId)
                {
                    // Events not handled by this state:
                    case BeadSorter.EventId.BUTTON0: break;
                    case BeadSorter.EventId.DO: break;
                    case BeadSorter.EventId.BUTTON2: break;
                    case BeadSorter.EventId.BUTTON1: break;
                }
                break;
            
            // STATE: Paused
            case BeadSorter.StateId.PAUSED:
                switch (eventId)
                {
                    case BeadSorter.EventId.BUTTON0: this.#PAUSED_button0(); break;
                    // Events not handled by this state:
                    case BeadSorter.EventId.DO: break;
                    case BeadSorter.EventId.BUTTON2: break;
                    case BeadSorter.EventId.BUTTON1: break;
                }
                break;
            
            // STATE: Running
            case BeadSorter.StateId.RUNNING:
                switch (eventId)
                {
                    case BeadSorter.EventId.BUTTON0: this.#RUNNING_button0(); break;
                    // Events not handled by this state:
                    case BeadSorter.EventId.DO: break;
                    case BeadSorter.EventId.BUTTON2: break;
                    case BeadSorter.EventId.BUTTON1: break;
                }
                break;
            
            // STATE: SetupCheck
            case BeadSorter.StateId.SETUPCHECK:
                switch (eventId)
                {
                    // Events not handled by this state:
                    case BeadSorter.EventId.BUTTON0: this.#RUNNING_button0(); break; // First ancestor handler for this event
                    case BeadSorter.EventId.DO: break;
                    case BeadSorter.EventId.BUTTON2: break;
                    case BeadSorter.EventId.BUTTON1: break;
                }
                break;
            
            // STATE: AdjustServoOffsets
            case BeadSorter.StateId.ADJUSTSERVOOFFSETS:
                switch (eventId)
                {
                    case BeadSorter.EventId.BUTTON2: this.#ADJUSTSERVOOFFSETS_button2(); break;
                    // Events not handled by this state:
                    case BeadSorter.EventId.BUTTON0: this.#RUNNING_button0(); break; // First ancestor handler for this event
                    case BeadSorter.EventId.DO: break;
                    case BeadSorter.EventId.BUTTON1: break;
                }
                break;
            
            // STATE: DECREASE
            case BeadSorter.StateId.DECREASE:
                switch (eventId)
                {
                    case BeadSorter.EventId.DO: this.#DECREASE_do(); break;
                    // Events not handled by this state:
                    case BeadSorter.EventId.BUTTON0: this.#RUNNING_button0(); break; // First ancestor handler for this event
                    case BeadSorter.EventId.BUTTON2: this.#ADJUSTSERVOOFFSETS_button2(); break; // First ancestor handler for this event
                    case BeadSorter.EventId.BUTTON1: break;
                }
                break;
            
            // STATE: INCREASE
            case BeadSorter.StateId.INCREASE:
                switch (eventId)
                {
                    case BeadSorter.EventId.DO: this.#INCREASE_do(); break;
                    // Events not handled by this state:
                    case BeadSorter.EventId.BUTTON0: this.#RUNNING_button0(); break; // First ancestor handler for this event
                    case BeadSorter.EventId.BUTTON2: this.#ADJUSTSERVOOFFSETS_button2(); break; // First ancestor handler for this event
                    case BeadSorter.EventId.BUTTON1: break;
                }
                break;
            
            // STATE: Wait
            case BeadSorter.StateId.WAIT:
                switch (eventId)
                {
                    case BeadSorter.EventId.BUTTON1: this.#WAIT_button1(); break;
                    case BeadSorter.EventId.BUTTON2: this.#WAIT_button2(); break;
                    // Events not handled by this state:
                    case BeadSorter.EventId.BUTTON0: this.#RUNNING_button0(); break; // First ancestor handler for this event
                    case BeadSorter.EventId.DO: break;
                }
                break;
            
            // STATE: SetupCheck__Start
            case BeadSorter.StateId.SETUPCHECK__START:
                switch (eventId)
                {
                    case BeadSorter.EventId.DO: this.#SETUPCHECK__START_do(); break;
                    case BeadSorter.EventId.BUTTON2: this.#SETUPCHECK__START_button2(); break;
                    // Events not handled by this state:
                    case BeadSorter.EventId.BUTTON0: this.#RUNNING_button0(); break; // First ancestor handler for this event
                    case BeadSorter.EventId.BUTTON1: break;
                }
                break;
            
            // STATE: Tour
            case BeadSorter.StateId.TOUR:
                switch (eventId)
                {
                    case BeadSorter.EventId.DO: this.#TOUR_do(); break;
                    // Events not handled by this state:
                    case BeadSorter.EventId.BUTTON0: this.#RUNNING_button0(); break; // First ancestor handler for this event
                    case BeadSorter.EventId.BUTTON2: break;
                    case BeadSorter.EventId.BUTTON1: break;
                }
                break;
            
            // STATE: SortingMode
            case BeadSorter.StateId.SORTINGMODE:
                switch (eventId)
                {
                    // Events not handled by this state:
                    case BeadSorter.EventId.BUTTON0: this.#RUNNING_button0(); break; // First ancestor handler for this event
                    case BeadSorter.EventId.DO: break;
                    case BeadSorter.EventId.BUTTON2: break;
                    case BeadSorter.EventId.BUTTON1: break;
                }
                break;
            
            // STATE: SortingMode__Dropoff
            case BeadSorter.StateId.SORTINGMODE__DROPOFF:
                switch (eventId)
                {
                    case BeadSorter.EventId.DO: this.#SORTINGMODE__DROPOFF_do(); break;
                    // Events not handled by this state:
                    case BeadSorter.EventId.BUTTON0: this.#RUNNING_button0(); break; // First ancestor handler for this event
                    case BeadSorter.EventId.BUTTON2: break;
                    case BeadSorter.EventId.BUTTON1: break;
                }
                break;
            
            // STATE: SortingMode__Pickup
            case BeadSorter.StateId.SORTINGMODE__PICKUP:
                switch (eventId)
                {
                    case BeadSorter.EventId.DO: this.#SORTINGMODE__PICKUP_do(); break;
                    // Events not handled by this state:
                    case BeadSorter.EventId.BUTTON0: this.#RUNNING_button0(); break; // First ancestor handler for this event
                    case BeadSorter.EventId.BUTTON2: break;
                    case BeadSorter.EventId.BUTTON1: break;
                }
                break;
            
            // STATE: SortingMode__Sensor
            case BeadSorter.StateId.SORTINGMODE__SENSOR:
                switch (eventId)
                {
                    case BeadSorter.EventId.DO: this.#SORTINGMODE__SENSOR_do(); break;
                    // Events not handled by this state:
                    case BeadSorter.EventId.BUTTON0: this.#RUNNING_button0(); break; // First ancestor handler for this event
                    case BeadSorter.EventId.BUTTON2: break;
                    case BeadSorter.EventId.BUTTON1: break;
                }
                break;
            
            // STATE: SortingMode__Start
            case BeadSorter.StateId.SORTINGMODE__START:
                switch (eventId)
                {
                    case BeadSorter.EventId.DO: this.#SORTINGMODE__START_do(); break;
                    // Events not handled by this state:
                    case BeadSorter.EventId.BUTTON0: this.#RUNNING_button0(); break; // First ancestor handler for this event
                    case BeadSorter.EventId.BUTTON2: break;
                    case BeadSorter.EventId.BUTTON1: break;
                }
                break;
            
            // STATE: TrainingMode
            case BeadSorter.StateId.TRAININGMODE:
                switch (eventId)
                {
                    // Events not handled by this state:
                    case BeadSorter.EventId.BUTTON0: this.#RUNNING_button0(); break; // First ancestor handler for this event
                    case BeadSorter.EventId.DO: break;
                    case BeadSorter.EventId.BUTTON2: break;
                    case BeadSorter.EventId.BUTTON1: break;
                }
                break;
            
            // STATE: ReadEmptySlot
            case BeadSorter.StateId.READEMPTYSLOT:
                switch (eventId)
                {
                    // Events not handled by this state:
                    case BeadSorter.EventId.BUTTON0: this.#RUNNING_button0(); break; // First ancestor handler for this event
                    case BeadSorter.EventId.DO: break;
                    case BeadSorter.EventId.BUTTON2: break;
                    case BeadSorter.EventId.BUTTON1: break;
                }
                break;
            
            // STATE: ReadEmptySlot__Dropoff
            case BeadSorter.StateId.READEMPTYSLOT__DROPOFF:
                switch (eventId)
                {
                    case BeadSorter.EventId.DO: this.#READEMPTYSLOT__DROPOFF_do(); break;
                    // Events not handled by this state:
                    case BeadSorter.EventId.BUTTON0: this.#RUNNING_button0(); break; // First ancestor handler for this event
                    case BeadSorter.EventId.BUTTON2: break;
                    case BeadSorter.EventId.BUTTON1: break;
                }
                break;
            
            // STATE: ReadEmptySlot__Sensor
            case BeadSorter.StateId.READEMPTYSLOT__SENSOR:
                switch (eventId)
                {
                    case BeadSorter.EventId.DO: this.#READEMPTYSLOT__SENSOR_do(); break;
                    // Events not handled by this state:
                    case BeadSorter.EventId.BUTTON0: this.#RUNNING_button0(); break; // First ancestor handler for this event
                    case BeadSorter.EventId.BUTTON2: break;
                    case BeadSorter.EventId.BUTTON1: break;
                }
                break;
            
            // STATE: ReadJammedSlot
            case BeadSorter.StateId.READJAMMEDSLOT:
                switch (eventId)
                {
                    // Events not handled by this state:
                    case BeadSorter.EventId.BUTTON0: this.#RUNNING_button0(); break; // First ancestor handler for this event
                    case BeadSorter.EventId.DO: break;
                    case BeadSorter.EventId.BUTTON2: break;
                    case BeadSorter.EventId.BUTTON1: break;
                }
                break;
            
            // STATE: Jammed
            case BeadSorter.StateId.JAMMED:
                switch (eventId)
                {
                    case BeadSorter.EventId.DO: this.#JAMMED_do(); break;
                    // Events not handled by this state:
                    case BeadSorter.EventId.BUTTON0: this.#RUNNING_button0(); break; // First ancestor handler for this event
                    case BeadSorter.EventId.BUTTON2: break;
                    case BeadSorter.EventId.BUTTON1: break;
                }
                break;
            
            // STATE: ReadJammedSlot__Dropoff
            case BeadSorter.StateId.READJAMMEDSLOT__DROPOFF:
                switch (eventId)
                {
                    case BeadSorter.EventId.DO: this.#READJAMMEDSLOT__DROPOFF_do(); break;
                    // Events not handled by this state:
                    case BeadSorter.EventId.BUTTON0: this.#RUNNING_button0(); break; // First ancestor handler for this event
                    case BeadSorter.EventId.BUTTON2: break;
                    case BeadSorter.EventId.BUTTON1: break;
                }
                break;
            
            // STATE: ReadJammedSlot__Sensor
            case BeadSorter.StateId.READJAMMEDSLOT__SENSOR:
                switch (eventId)
                {
                    case BeadSorter.EventId.DO: this.#READJAMMEDSLOT__SENSOR_do(); break;
                    // Events not handled by this state:
                    case BeadSorter.EventId.BUTTON0: this.#RUNNING_button0(); break; // First ancestor handler for this event
                    case BeadSorter.EventId.BUTTON2: break;
                    case BeadSorter.EventId.BUTTON1: break;
                }
                break;
            
            // STATE: ReadSlot
            case BeadSorter.StateId.READSLOT:
                switch (eventId)
                {
                    // Events not handled by this state:
                    case BeadSorter.EventId.BUTTON0: this.#RUNNING_button0(); break; // First ancestor handler for this event
                    case BeadSorter.EventId.DO: break;
                    case BeadSorter.EventId.BUTTON2: break;
                    case BeadSorter.EventId.BUTTON1: break;
                }
                break;
            
            // STATE: ReadSlot__Dropoff
            case BeadSorter.StateId.READSLOT__DROPOFF:
                switch (eventId)
                {
                    case BeadSorter.EventId.DO: this.#READSLOT__DROPOFF_do(); break;
                    // Events not handled by this state:
                    case BeadSorter.EventId.BUTTON0: this.#RUNNING_button0(); break; // First ancestor handler for this event
                    case BeadSorter.EventId.BUTTON2: break;
                    case BeadSorter.EventId.BUTTON1: break;
                }
                break;
            
            // STATE: ReadSlot__Sensor
            case BeadSorter.StateId.READSLOT__SENSOR:
                switch (eventId)
                {
                    case BeadSorter.EventId.DO: this.#READSLOT__SENSOR_do(); break;
                    // Events not handled by this state:
                    case BeadSorter.EventId.BUTTON0: this.#RUNNING_button0(); break; // First ancestor handler for this event
                    case BeadSorter.EventId.BUTTON2: break;
                    case BeadSorter.EventId.BUTTON1: break;
                }
                break;
            
            // STATE: TrainingMode__Pickup
            case BeadSorter.StateId.TRAININGMODE__PICKUP:
                switch (eventId)
                {
                    case BeadSorter.EventId.DO: this.#TRAININGMODE__PICKUP_do(); break;
                    // Events not handled by this state:
                    case BeadSorter.EventId.BUTTON0: this.#RUNNING_button0(); break; // First ancestor handler for this event
                    case BeadSorter.EventId.BUTTON2: break;
                    case BeadSorter.EventId.BUTTON1: break;
                }
                break;
            
            // STATE: TrainingMode__Start
            case BeadSorter.StateId.TRAININGMODE__START:
                switch (eventId)
                {
                    case BeadSorter.EventId.DO: this.#TRAININGMODE__START_do(); break;
                    // Events not handled by this state:
                    case BeadSorter.EventId.BUTTON0: this.#RUNNING_button0(); break; // First ancestor handler for this event
                    case BeadSorter.EventId.BUTTON2: break;
                    case BeadSorter.EventId.BUTTON1: break;
                }
                break;
        }
        
    }
    
    // This function is used when StateSmith doesn't know what the active leaf state is at
    // compile time due to sub states or when multiple states need to be exited.
    #exitUpToStateHandler(desiredState)
    {
        while (this.stateId != desiredState)
        {
            switch (this.stateId)
            {
                case BeadSorter.StateId.PAUSED: this.#PAUSED_exit(); break;
                
                case BeadSorter.StateId.RUNNING: this.#RUNNING_exit(); break;
                
                case BeadSorter.StateId.SETUPCHECK: this.#SETUPCHECK_exit(); break;
                
                case BeadSorter.StateId.ADJUSTSERVOOFFSETS: this.#ADJUSTSERVOOFFSETS_exit(); break;
                
                case BeadSorter.StateId.DECREASE: this.#DECREASE_exit(); break;
                
                case BeadSorter.StateId.INCREASE: this.#INCREASE_exit(); break;
                
                case BeadSorter.StateId.WAIT: this.#WAIT_exit(); break;
                
                case BeadSorter.StateId.SETUPCHECK__START: this.#SETUPCHECK__START_exit(); break;
                
                case BeadSorter.StateId.TOUR: this.#TOUR_exit(); break;
                
                case BeadSorter.StateId.SORTINGMODE: this.#SORTINGMODE_exit(); break;
                
                case BeadSorter.StateId.SORTINGMODE__DROPOFF: this.#SORTINGMODE__DROPOFF_exit(); break;
                
                case BeadSorter.StateId.SORTINGMODE__PICKUP: this.#SORTINGMODE__PICKUP_exit(); break;
                
                case BeadSorter.StateId.SORTINGMODE__SENSOR: this.#SORTINGMODE__SENSOR_exit(); break;
                
                case BeadSorter.StateId.SORTINGMODE__START: this.#SORTINGMODE__START_exit(); break;
                
                case BeadSorter.StateId.TRAININGMODE: this.#TRAININGMODE_exit(); break;
                
                case BeadSorter.StateId.READEMPTYSLOT: this.#READEMPTYSLOT_exit(); break;
                
                case BeadSorter.StateId.READEMPTYSLOT__DROPOFF: this.#READEMPTYSLOT__DROPOFF_exit(); break;
                
                case BeadSorter.StateId.READEMPTYSLOT__SENSOR: this.#READEMPTYSLOT__SENSOR_exit(); break;
                
                case BeadSorter.StateId.READJAMMEDSLOT: this.#READJAMMEDSLOT_exit(); break;
                
                case BeadSorter.StateId.JAMMED: this.#JAMMED_exit(); break;
                
                case BeadSorter.StateId.READJAMMEDSLOT__DROPOFF: this.#READJAMMEDSLOT__DROPOFF_exit(); break;
                
                case BeadSorter.StateId.READJAMMEDSLOT__SENSOR: this.#READJAMMEDSLOT__SENSOR_exit(); break;
                
                case BeadSorter.StateId.READSLOT: this.#READSLOT_exit(); break;
                
                case BeadSorter.StateId.READSLOT__DROPOFF: this.#READSLOT__DROPOFF_exit(); break;
                
                case BeadSorter.StateId.READSLOT__SENSOR: this.#READSLOT__SENSOR_exit(); break;
                
                case BeadSorter.StateId.TRAININGMODE__PICKUP: this.#TRAININGMODE__PICKUP_exit(); break;
                
                case BeadSorter.StateId.TRAININGMODE__START: this.#TRAININGMODE__START_exit(); break;
                
                default: return;  // Just to be safe. Prevents infinite loop if state ID memory is somehow corrupted.
            }
        }
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ROOT
    ////////////////////////////////////////////////////////////////////////////////
    
    #ROOT_enter()
    {
        this.stateId = BeadSorter.StateId.ROOT;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state PAUSED
    ////////////////////////////////////////////////////////////////////////////////
    
    #PAUSED_enter()
    {
        this.stateId = BeadSorter.StateId.PAUSED;
        
        // Paused behavior
        // uml: enter / { this.tracer?.enterState('Paused'); }
        {
            // Step 1: execute action `this.tracer?.enterState('Paused');`
            this.tracer?.enterState('Paused');
        } // end of behavior for Paused
    }
    
    #PAUSED_exit()
    {
        // Paused behavior
        // uml: exit / { this.tracer?.exitState('Paused'); }
        {
            // Step 1: execute action `this.tracer?.exitState('Paused');`
            this.tracer?.exitState('Paused');
        } // end of behavior for Paused
        
        this.stateId = BeadSorter.StateId.ROOT;
    }
    
    #PAUSED_button0()
    {
        // Paused behavior
        // uml: BUTTON0 / { this.tracer?.edgeTransition("edge35"); } TransitionTo(Running)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#PAUSED_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge35");`.
            this.tracer?.edgeTransition("edge35");
            
            // Step 3: Enter/move towards transition target `Running`.
            this.#RUNNING_enter();
            
            // Finish transition by calling pseudo state transition function.
            this.#Running_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for Paused
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state RUNNING
    ////////////////////////////////////////////////////////////////////////////////
    
    #RUNNING_enter()
    {
        this.stateId = BeadSorter.StateId.RUNNING;
        
        // Running behavior
        // uml: enter / { this.tracer?.enterState('Running'); }
        {
            // Step 1: execute action `this.tracer?.enterState('Running');`
            this.tracer?.enterState('Running');
        } // end of behavior for Running
    }
    
    #RUNNING_exit()
    {
        // Running behavior
        // uml: exit / { this.tracer?.exitState('Running'); }
        {
            // Step 1: execute action `this.tracer?.exitState('Running');`
            this.tracer?.exitState('Running');
        } // end of behavior for Running
        
        this.stateId = BeadSorter.StateId.ROOT;
    }
    
    #RUNNING_button0()
    {
        // Running behavior
        // uml: BUTTON0 / { this.tracer?.edgeTransition("edge0"); } TransitionTo(Paused)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(BeadSorter.StateId.ROOT);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge0");`.
            this.tracer?.edgeTransition("edge0");
            
            // Step 3: Enter/move towards transition target `Paused`.
            this.#PAUSED_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Running
        
        // No ancestor handles this event.
    }
    
    #Running_InitialState_transition()
    {
        // Running.<InitialState> behavior
        // uml: / { this.tracer?.edgeTransition("edge33"); } TransitionTo(Running.<History>)
        {
            // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge33");`.
            this.tracer?.edgeTransition("edge33");
            
            // Step 3: Enter/move towards transition target `Running.<History>`.
            // Running.<History> is a pseudo state and cannot have an `enter` trigger.
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.TRAININGMODE)] / { this.tracer?.log("ðŸ•‘ History: transitioning to TrainingMode."); } TransitionTo(TrainingMode)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.TRAININGMODE)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.log("ðŸ•‘ History: transitioning to TrainingMode.");`.
                this.tracer?.log("ðŸ•‘ History: transitioning to TrainingMode.");
                
                // Step 3: Enter/move towards transition target `TrainingMode`.
                this.#TRAININGMODE_enter();
                
                // Finish transition by calling pseudo state transition function.
                this.#TrainingMode_InitialState_transition();
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.SORTINGMODE)] / { this.tracer?.log("ðŸ•‘ History: transitioning to SortingMode."); } TransitionTo(SortingMode)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.SORTINGMODE)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.log("ðŸ•‘ History: transitioning to SortingMode.");`.
                this.tracer?.log("ðŸ•‘ History: transitioning to SortingMode.");
                
                // Step 3: Enter/move towards transition target `SortingMode`.
                this.#SORTINGMODE_enter();
                
                // Finish transition by calling pseudo state transition function.
                this.#SortingMode_InitialState_transition();
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.READEMPTYSLOT)] / { this.tracer?.log("ðŸ•‘ History: transitioning to ReadEmptySlot."); } TransitionTo(ReadEmptySlot)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.READEMPTYSLOT)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.log("ðŸ•‘ History: transitioning to ReadEmptySlot.");`.
                this.tracer?.log("ðŸ•‘ History: transitioning to ReadEmptySlot.");
                
                // Step 3: Enter/move towards transition target `ReadEmptySlot`.
                this.#TRAININGMODE_enter();
                this.#READEMPTYSLOT_enter();
                
                // Finish transition by calling pseudo state transition function.
                this.#ReadEmptySlot_InitialState_transition();
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.READJAMMEDSLOT)] / { this.tracer?.log("ðŸ•‘ History: transitioning to ReadJammedSlot."); } TransitionTo(ReadJammedSlot)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.READJAMMEDSLOT)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.log("ðŸ•‘ History: transitioning to ReadJammedSlot.");`.
                this.tracer?.log("ðŸ•‘ History: transitioning to ReadJammedSlot.");
                
                // Step 3: Enter/move towards transition target `ReadJammedSlot`.
                this.#TRAININGMODE_enter();
                this.#READJAMMEDSLOT_enter();
                
                // Finish transition by calling pseudo state transition function.
                this.#ReadJammedSlot_InitialState_transition();
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.READSLOT)] / { this.tracer?.log("ðŸ•‘ History: transitioning to ReadSlot."); } TransitionTo(ReadSlot)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.READSLOT)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.log("ðŸ•‘ History: transitioning to ReadSlot.");`.
                this.tracer?.log("ðŸ•‘ History: transitioning to ReadSlot.");
                
                // Step 3: Enter/move towards transition target `ReadSlot`.
                this.#TRAININGMODE_enter();
                this.#READSLOT_enter();
                
                // Finish transition by calling pseudo state transition function.
                this.#ReadSlot_InitialState_transition();
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.TRAININGMODE__START)] / { this.tracer?.log("ðŸ•‘ History: transitioning to TrainingMode__Start."); } TransitionTo(TrainingMode__Start)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.TRAININGMODE__START)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.log("ðŸ•‘ History: transitioning to TrainingMode__Start.");`.
                this.tracer?.log("ðŸ•‘ History: transitioning to TrainingMode__Start.");
                
                // Step 3: Enter/move towards transition target `TrainingMode__Start`.
                this.#TRAININGMODE_enter();
                this.#TRAININGMODE__START_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.READEMPTYSLOT__DROPOFF)] / { this.tracer?.log("ðŸ•‘ History: transitioning to ReadEmptySlot__Dropoff."); } TransitionTo(ReadEmptySlot__Dropoff)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.READEMPTYSLOT__DROPOFF)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.log("ðŸ•‘ History: transitioning to ReadEmptySlot__Dropoff.");`.
                this.tracer?.log("ðŸ•‘ History: transitioning to ReadEmptySlot__Dropoff.");
                
                // Step 3: Enter/move towards transition target `ReadEmptySlot__Dropoff`.
                this.#TRAININGMODE_enter();
                this.#READEMPTYSLOT_enter();
                this.#READEMPTYSLOT__DROPOFF_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.READEMPTYSLOT__SENSOR)] / { this.tracer?.log("ðŸ•‘ History: transitioning to ReadEmptySlot__Sensor."); } TransitionTo(ReadEmptySlot__Sensor)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.READEMPTYSLOT__SENSOR)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.log("ðŸ•‘ History: transitioning to ReadEmptySlot__Sensor.");`.
                this.tracer?.log("ðŸ•‘ History: transitioning to ReadEmptySlot__Sensor.");
                
                // Step 3: Enter/move towards transition target `ReadEmptySlot__Sensor`.
                this.#TRAININGMODE_enter();
                this.#READEMPTYSLOT_enter();
                this.#READEMPTYSLOT__SENSOR_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.READJAMMEDSLOT__DROPOFF)] / { this.tracer?.log("ðŸ•‘ History: transitioning to ReadJammedSlot__Dropoff."); } TransitionTo(ReadJammedSlot__Dropoff)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.READJAMMEDSLOT__DROPOFF)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.log("ðŸ•‘ History: transitioning to ReadJammedSlot__Dropoff.");`.
                this.tracer?.log("ðŸ•‘ History: transitioning to ReadJammedSlot__Dropoff.");
                
                // Step 3: Enter/move towards transition target `ReadJammedSlot__Dropoff`.
                this.#TRAININGMODE_enter();
                this.#READJAMMEDSLOT_enter();
                this.#READJAMMEDSLOT__DROPOFF_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.JAMMED)] / { this.tracer?.log("ðŸ•‘ History: transitioning to Jammed."); } TransitionTo(Jammed)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.JAMMED)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.log("ðŸ•‘ History: transitioning to Jammed.");`.
                this.tracer?.log("ðŸ•‘ History: transitioning to Jammed.");
                
                // Step 3: Enter/move towards transition target `Jammed`.
                this.#TRAININGMODE_enter();
                this.#READJAMMEDSLOT_enter();
                this.#JAMMED_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.READJAMMEDSLOT__SENSOR)] / { this.tracer?.log("ðŸ•‘ History: transitioning to ReadJammedSlot__Sensor."); } TransitionTo(ReadJammedSlot__Sensor)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.READJAMMEDSLOT__SENSOR)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.log("ðŸ•‘ History: transitioning to ReadJammedSlot__Sensor.");`.
                this.tracer?.log("ðŸ•‘ History: transitioning to ReadJammedSlot__Sensor.");
                
                // Step 3: Enter/move towards transition target `ReadJammedSlot__Sensor`.
                this.#TRAININGMODE_enter();
                this.#READJAMMEDSLOT_enter();
                this.#READJAMMEDSLOT__SENSOR_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.READSLOT__DROPOFF)] / { this.tracer?.log("ðŸ•‘ History: transitioning to ReadSlot__Dropoff."); } TransitionTo(ReadSlot__Dropoff)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.READSLOT__DROPOFF)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.log("ðŸ•‘ History: transitioning to ReadSlot__Dropoff.");`.
                this.tracer?.log("ðŸ•‘ History: transitioning to ReadSlot__Dropoff.");
                
                // Step 3: Enter/move towards transition target `ReadSlot__Dropoff`.
                this.#TRAININGMODE_enter();
                this.#READSLOT_enter();
                this.#READSLOT__DROPOFF_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.TRAININGMODE__PICKUP)] / { this.tracer?.log("ðŸ•‘ History: transitioning to TrainingMode__Pickup."); } TransitionTo(TrainingMode__Pickup)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.TRAININGMODE__PICKUP)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.log("ðŸ•‘ History: transitioning to TrainingMode__Pickup.");`.
                this.tracer?.log("ðŸ•‘ History: transitioning to TrainingMode__Pickup.");
                
                // Step 3: Enter/move towards transition target `TrainingMode__Pickup`.
                this.#TRAININGMODE_enter();
                this.#READSLOT_enter();
                this.#TRAININGMODE__PICKUP_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.READSLOT__SENSOR)] / { this.tracer?.log("ðŸ•‘ History: transitioning to ReadSlot__Sensor."); } TransitionTo(ReadSlot__Sensor)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.READSLOT__SENSOR)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.log("ðŸ•‘ History: transitioning to ReadSlot__Sensor.");`.
                this.tracer?.log("ðŸ•‘ History: transitioning to ReadSlot__Sensor.");
                
                // Step 3: Enter/move towards transition target `ReadSlot__Sensor`.
                this.#TRAININGMODE_enter();
                this.#READSLOT_enter();
                this.#READSLOT__SENSOR_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.SORTINGMODE__DROPOFF)] / { this.tracer?.log("ðŸ•‘ History: transitioning to SortingMode__Dropoff."); } TransitionTo(SortingMode__Dropoff)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.SORTINGMODE__DROPOFF)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.log("ðŸ•‘ History: transitioning to SortingMode__Dropoff.");`.
                this.tracer?.log("ðŸ•‘ History: transitioning to SortingMode__Dropoff.");
                
                // Step 3: Enter/move towards transition target `SortingMode__Dropoff`.
                this.#SORTINGMODE_enter();
                this.#SORTINGMODE__DROPOFF_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.SORTINGMODE__PICKUP)] / { this.tracer?.log("ðŸ•‘ History: transitioning to SortingMode__Pickup."); } TransitionTo(SortingMode__Pickup)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.SORTINGMODE__PICKUP)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.log("ðŸ•‘ History: transitioning to SortingMode__Pickup.");`.
                this.tracer?.log("ðŸ•‘ History: transitioning to SortingMode__Pickup.");
                
                // Step 3: Enter/move towards transition target `SortingMode__Pickup`.
                this.#SORTINGMODE_enter();
                this.#SORTINGMODE__PICKUP_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.SORTINGMODE__START)] / { this.tracer?.log("ðŸ•‘ History: transitioning to SortingMode__Start."); } TransitionTo(SortingMode__Start)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.SORTINGMODE__START)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.log("ðŸ•‘ History: transitioning to SortingMode__Start.");`.
                this.tracer?.log("ðŸ•‘ History: transitioning to SortingMode__Start.");
                
                // Step 3: Enter/move towards transition target `SortingMode__Start`.
                this.#SORTINGMODE_enter();
                this.#SORTINGMODE__START_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.SORTINGMODE__SENSOR)] / { this.tracer?.log("ðŸ•‘ History: transitioning to SortingMode__Sensor."); } TransitionTo(SortingMode__Sensor)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.SORTINGMODE__SENSOR)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.log("ðŸ•‘ History: transitioning to SortingMode__Sensor.");`.
                this.tracer?.log("ðŸ•‘ History: transitioning to SortingMode__Sensor.");
                
                // Step 3: Enter/move towards transition target `SortingMode__Sensor`.
                this.#SORTINGMODE_enter();
                this.#SORTINGMODE__SENSOR_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.TOUR)] / { this.tracer?.log("ðŸ•‘ History: transitioning to Tour."); } TransitionTo(Tour)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.TOUR)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.log("ðŸ•‘ History: transitioning to Tour.");`.
                this.tracer?.log("ðŸ•‘ History: transitioning to Tour.");
                
                // Step 3: Enter/move towards transition target `Tour`.
                this.#SETUPCHECK_enter();
                this.#TOUR_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.SETUPCHECK__START)] / { this.tracer?.log("ðŸ•‘ History: transitioning to SetupCheck__Start."); } TransitionTo(SetupCheck__Start)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.SETUPCHECK__START)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.log("ðŸ•‘ History: transitioning to SetupCheck__Start.");`.
                this.tracer?.log("ðŸ•‘ History: transitioning to SetupCheck__Start.");
                
                // Step 3: Enter/move towards transition target `SetupCheck__Start`.
                this.#SETUPCHECK_enter();
                this.#SETUPCHECK__START_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.ADJUSTSERVOOFFSETS)] / { this.tracer?.log("ðŸ•‘ History: transitioning to AdjustServoOffsets."); } TransitionTo(AdjustServoOffsets)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.ADJUSTSERVOOFFSETS)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.log("ðŸ•‘ History: transitioning to AdjustServoOffsets.");`.
                this.tracer?.log("ðŸ•‘ History: transitioning to AdjustServoOffsets.");
                
                // Step 3: Enter/move towards transition target `AdjustServoOffsets`.
                this.#SETUPCHECK_enter();
                this.#ADJUSTSERVOOFFSETS_enter();
                
                // Finish transition by calling pseudo state transition function.
                this.#AdjustServoOffsets_InitialState_transition();
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: else / { this.tracer?.log("ðŸ•‘ History: default transition.");this.tracer?.edgeTransition("edge34"); } TransitionTo(SetupCheck)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.log("ðŸ•‘ History: default transition.");this.tracer?.edgeTransition("edge34");`.
                this.tracer?.log("ðŸ•‘ History: default transition.");this.tracer?.edgeTransition("edge34");
                
                // Step 3: Enter/move towards transition target `SetupCheck`.
                this.#SETUPCHECK_enter();
                
                // SetupCheck.<InitialState> behavior
                // uml: / { this.tracer?.edgeTransition("edge22"); } TransitionTo(SetupCheck__Start)
                {
                    // Step 1: Exit states until we reach `SetupCheck` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                    
                    // Step 2: Transition action: `this.tracer?.edgeTransition("edge22");`.
                    this.tracer?.edgeTransition("edge22");
                    
                    // Step 3: Enter/move towards transition target `SetupCheck__Start`.
                    this.#SETUPCHECK__START_enter();
                    
                    // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                    return;
                } // end of behavior for SetupCheck.<InitialState>
            } // end of behavior for Running.<History>
        } // end of behavior for Running.<InitialState>
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state SETUPCHECK
    ////////////////////////////////////////////////////////////////////////////////
    
    #SETUPCHECK_enter()
    {
        this.stateId = BeadSorter.StateId.SETUPCHECK;
        
        // SetupCheck behavior
        // uml: enter / { this.tracer?.enterState('SetupCheck'); }
        {
            // Step 1: execute action `this.tracer?.enterState('SetupCheck');`
            this.tracer?.enterState('SetupCheck');
        } // end of behavior for SetupCheck
        
        // SetupCheck behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.SETUPCHECK;) }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.SETUPCHECK;)`
            this.vars.Running_history = BeadSorter.Running_HistoryId.SETUPCHECK;
        } // end of behavior for SetupCheck
    }
    
    #SETUPCHECK_exit()
    {
        // SetupCheck behavior
        // uml: exit / { this.tracer?.exitState('SetupCheck'); }
        {
            // Step 1: execute action `this.tracer?.exitState('SetupCheck');`
            this.tracer?.exitState('SetupCheck');
        } // end of behavior for SetupCheck
        
        this.stateId = BeadSorter.StateId.RUNNING;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ADJUSTSERVOOFFSETS
    ////////////////////////////////////////////////////////////////////////////////
    
    #ADJUSTSERVOOFFSETS_enter()
    {
        this.stateId = BeadSorter.StateId.ADJUSTSERVOOFFSETS;
        
        // AdjustServoOffsets behavior
        // uml: enter / { this.tracer?.enterState('AdjustServoOffsets'); }
        {
            // Step 1: execute action `this.tracer?.enterState('AdjustServoOffsets');`
            this.tracer?.enterState('AdjustServoOffsets');
        } // end of behavior for AdjustServoOffsets
        
        // AdjustServoOffsets behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.ADJUSTSERVOOFFSETS;) }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.ADJUSTSERVOOFFSETS;)`
            this.vars.Running_history = BeadSorter.Running_HistoryId.ADJUSTSERVOOFFSETS;
        } // end of behavior for AdjustServoOffsets
    }
    
    #ADJUSTSERVOOFFSETS_exit()
    {
        // AdjustServoOffsets behavior
        // uml: exit / { this.tracer?.exitState('AdjustServoOffsets'); }
        {
            // Step 1: execute action `this.tracer?.exitState('AdjustServoOffsets');`
            this.tracer?.exitState('AdjustServoOffsets');
        } // end of behavior for AdjustServoOffsets
        
        this.stateId = BeadSorter.StateId.SETUPCHECK;
    }
    
    #ADJUSTSERVOOFFSETS_button2()
    {
        // AdjustServoOffsets behavior
        // uml: BUTTON2 / { this.tracer?.edgeTransition("edge27"); } TransitionTo(SetupCheck__Start)
        {
            // Step 1: Exit states until we reach `SetupCheck` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(BeadSorter.StateId.SETUPCHECK);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge27");`.
            this.tracer?.edgeTransition("edge27");
            
            // Step 3: Enter/move towards transition target `SetupCheck__Start`.
            this.#SETUPCHECK__START_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for AdjustServoOffsets
        
        // No ancestor handles this event.
    }
    
    #AdjustServoOffsets_InitialState_transition()
    {
        // AdjustServoOffsets.<InitialState> behavior
        // uml: / { this.tracer?.edgeTransition("edge32"); } TransitionTo(Wait)
        {
            // Step 1: Exit states until we reach `AdjustServoOffsets` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge32");`.
            this.tracer?.edgeTransition("edge32");
            
            // Step 3: Enter/move towards transition target `Wait`.
            this.#WAIT_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for AdjustServoOffsets.<InitialState>
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state DECREASE
    ////////////////////////////////////////////////////////////////////////////////
    
    #DECREASE_enter()
    {
        this.stateId = BeadSorter.StateId.DECREASE;
        
        // DECREASE behavior
        // uml: enter / { this.tracer?.enterState('DECREASE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('DECREASE');`
            this.tracer?.enterState('DECREASE');
        } // end of behavior for DECREASE
        
        // DECREASE behavior
        // uml: enter / { this.tracer?.log("âš¡ FSM would execute action: " + "picker.adjustOffset(-2);"); }
        {
            // Step 1: execute action `this.tracer?.log("âš¡ FSM would execute action: " + "picker.adjustOffset(-2);");`
            this.tracer?.log("âš¡ FSM would execute action: " + "picker.adjustOffset(-2);");
        } // end of behavior for DECREASE
    }
    
    #DECREASE_exit()
    {
        // DECREASE behavior
        // uml: exit / { this.tracer?.exitState('DECREASE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('DECREASE');`
            this.tracer?.exitState('DECREASE');
        } // end of behavior for DECREASE
        
        this.stateId = BeadSorter.StateId.ADJUSTSERVOOFFSETS;
    }
    
    #DECREASE_do()
    {
        // DECREASE behavior
        // uml: do / { this.tracer?.edgeTransition("edge28"); } TransitionTo(Wait)
        {
            // Step 1: Exit states until we reach `AdjustServoOffsets` state (Least Common Ancestor for transition).
            this.#DECREASE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge28");`.
            this.tracer?.edgeTransition("edge28");
            
            // Step 3: Enter/move towards transition target `Wait`.
            this.#WAIT_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for DECREASE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state INCREASE
    ////////////////////////////////////////////////////////////////////////////////
    
    #INCREASE_enter()
    {
        this.stateId = BeadSorter.StateId.INCREASE;
        
        // INCREASE behavior
        // uml: enter / { this.tracer?.enterState('INCREASE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('INCREASE');`
            this.tracer?.enterState('INCREASE');
        } // end of behavior for INCREASE
        
        // INCREASE behavior
        // uml: enter / { this.tracer?.log("âš¡ FSM would execute action: " + "picker.adjustOffset(2);"); }
        {
            // Step 1: execute action `this.tracer?.log("âš¡ FSM would execute action: " + "picker.adjustOffset(2);");`
            this.tracer?.log("âš¡ FSM would execute action: " + "picker.adjustOffset(2);");
        } // end of behavior for INCREASE
    }
    
    #INCREASE_exit()
    {
        // INCREASE behavior
        // uml: exit / { this.tracer?.exitState('INCREASE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('INCREASE');`
            this.tracer?.exitState('INCREASE');
        } // end of behavior for INCREASE
        
        this.stateId = BeadSorter.StateId.ADJUSTSERVOOFFSETS;
    }
    
    #INCREASE_do()
    {
        // INCREASE behavior
        // uml: do / { this.tracer?.edgeTransition("edge29"); } TransitionTo(Wait)
        {
            // Step 1: Exit states until we reach `AdjustServoOffsets` state (Least Common Ancestor for transition).
            this.#INCREASE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge29");`.
            this.tracer?.edgeTransition("edge29");
            
            // Step 3: Enter/move towards transition target `Wait`.
            this.#WAIT_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for INCREASE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state WAIT
    ////////////////////////////////////////////////////////////////////////////////
    
    #WAIT_enter()
    {
        this.stateId = BeadSorter.StateId.WAIT;
        
        // Wait behavior
        // uml: enter / { this.tracer?.enterState('Wait'); }
        {
            // Step 1: execute action `this.tracer?.enterState('Wait');`
            this.tracer?.enterState('Wait');
        } // end of behavior for Wait
        
        // Wait behavior
        // uml: enter / { this.tracer?.log("âš¡ FSM would execute action: " + "picker.displayOffset();"); }
        {
            // Step 1: execute action `this.tracer?.log("âš¡ FSM would execute action: " + "picker.displayOffset();");`
            this.tracer?.log("âš¡ FSM would execute action: " + "picker.displayOffset();");
        } // end of behavior for Wait
    }
    
    #WAIT_exit()
    {
        // Wait behavior
        // uml: exit / { this.tracer?.exitState('Wait'); }
        {
            // Step 1: execute action `this.tracer?.exitState('Wait');`
            this.tracer?.exitState('Wait');
        } // end of behavior for Wait
        
        this.stateId = BeadSorter.StateId.ADJUSTSERVOOFFSETS;
    }
    
    #WAIT_button1()
    {
        // Wait behavior
        // uml: BUTTON1 / { this.tracer?.edgeTransition("edge30"); } TransitionTo(DECREASE)
        {
            // Step 1: Exit states until we reach `AdjustServoOffsets` state (Least Common Ancestor for transition).
            this.#WAIT_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge30");`.
            this.tracer?.edgeTransition("edge30");
            
            // Step 3: Enter/move towards transition target `DECREASE`.
            this.#DECREASE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Wait
        
        // No ancestor handles this event.
    }
    
    #WAIT_button2()
    {
        let consume_event = false;
        
        // Wait behavior
        // uml: BUTTON2 / { this.tracer?.edgeTransition("edge31"); } TransitionTo(INCREASE)
        {
            // Step 1: Exit states until we reach `AdjustServoOffsets` state (Least Common Ancestor for transition).
            this.#WAIT_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge31");`.
            this.tracer?.edgeTransition("edge31");
            
            // Step 3: Enter/move towards transition target `INCREASE`.
            this.#INCREASE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Wait
        
        // Check if event has been consumed before calling ancestor handler.
        if (!consume_event)
        {
            this.#ADJUSTSERVOOFFSETS_button2();
        }
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state SETUPCHECK__START
    ////////////////////////////////////////////////////////////////////////////////
    
    #SETUPCHECK__START_enter()
    {
        this.stateId = BeadSorter.StateId.SETUPCHECK__START;
        
        // SetupCheck__Start behavior
        // uml: enter / { this.tracer?.enterState('SetupCheck__Start'); }
        {
            // Step 1: execute action `this.tracer?.enterState('SetupCheck__Start');`
            this.tracer?.enterState('SetupCheck__Start');
        } // end of behavior for SetupCheck__Start
        
        // SetupCheck__Start behavior
        // uml: enter / { this.tracer?.log("âš¡ FSM would execute action: " + "modeDisplay.print(\"SETUP CHECK\");\nsorter.moveTo(0);\npicker.moveTo(DEG_DROPOFF);\npicker.moveTo(DEG_PICKUP);\nt1Restart();"); }
        {
            // Step 1: execute action `this.tracer?.log("âš¡ FSM would execute action: " + "modeDisplay.print(\"SETUP CHECK\");\nsorter.moveTo(0);\npicker.moveTo(DEG_DROPOFF);\npicker.moveTo(DEG_PICKUP);\nt1Restart();");`
            this.tracer?.log("âš¡ FSM would execute action: " + "modeDisplay.print(\"SETUP CHECK\");\nsorter.moveTo(0);\npicker.moveTo(DEG_DROPOFF);\npicker.moveTo(DEG_PICKUP);\nt1Restart();");
        } // end of behavior for SetupCheck__Start
        
        // SetupCheck__Start behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.SETUPCHECK__START;) }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.SETUPCHECK__START;)`
            this.vars.Running_history = BeadSorter.Running_HistoryId.SETUPCHECK__START;
        } // end of behavior for SetupCheck__Start
    }
    
    #SETUPCHECK__START_exit()
    {
        // SetupCheck__Start behavior
        // uml: exit / { this.tracer?.exitState('SetupCheck__Start'); }
        {
            // Step 1: execute action `this.tracer?.exitState('SetupCheck__Start');`
            this.tracer?.exitState('SetupCheck__Start');
        } // end of behavior for SetupCheck__Start
        
        this.stateId = BeadSorter.StateId.SETUPCHECK;
    }
    
    #SETUPCHECK__START_button2()
    {
        // SetupCheck__Start behavior
        // uml: BUTTON2 / { this.tracer?.edgeTransition("edge26"); } TransitionTo(AdjustServoOffsets)
        {
            // Step 1: Exit states until we reach `SetupCheck` state (Least Common Ancestor for transition).
            this.#SETUPCHECK__START_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge26");`.
            this.tracer?.edgeTransition("edge26");
            
            // Step 3: Enter/move towards transition target `AdjustServoOffsets`.
            this.#ADJUSTSERVOOFFSETS_enter();
            
            // Finish transition by calling pseudo state transition function.
            this.#AdjustServoOffsets_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for SetupCheck__Start
        
        // No ancestor handles this event.
    }
    
    #SETUPCHECK__START_do()
    {
        // SetupCheck__Start behavior
        // uml: do [this.tracer?.log("ðŸ›¡ï¸ User evaluating guard: " + "t1After(3s)") || this.evaluateGuard("SetupCheck__Start","do [t1After(3s)] TransitionTo(Tour)")] / { this.tracer?.edgeTransition("edge25"); } TransitionTo(Tour)
        if (this.tracer?.log("ðŸ›¡ï¸ User evaluating guard: " + "t1After(3s)") || this.evaluateGuard("SetupCheck__Start","do [t1After(3s)] TransitionTo(Tour)"))
        {
            // Step 1: Exit states until we reach `SetupCheck` state (Least Common Ancestor for transition).
            this.#SETUPCHECK__START_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge25");`.
            this.tracer?.edgeTransition("edge25");
            
            // Step 3: Enter/move towards transition target `Tour`.
            this.#TOUR_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for SetupCheck__Start
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state TOUR
    ////////////////////////////////////////////////////////////////////////////////
    
    #TOUR_enter()
    {
        this.stateId = BeadSorter.StateId.TOUR;
        
        // Tour behavior
        // uml: enter / { this.tracer?.enterState('Tour'); }
        {
            // Step 1: execute action `this.tracer?.enterState('Tour');`
            this.tracer?.enterState('Tour');
        } // end of behavior for Tour
        
        // Tour behavior
        // uml: enter / { this.tracer?.log("âš¡ FSM would execute action: " + "tourBin = min(tourBin+1, DEFAULT_BIN);\nsorter.moveTo(tourBin);"); }
        {
            // Step 1: execute action `this.tracer?.log("âš¡ FSM would execute action: " + "tourBin = min(tourBin+1, DEFAULT_BIN);\nsorter.moveTo(tourBin);");`
            this.tracer?.log("âš¡ FSM would execute action: " + "tourBin = min(tourBin+1, DEFAULT_BIN);\nsorter.moveTo(tourBin);");
        } // end of behavior for Tour
        
        // Tour behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.TOUR;) }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.TOUR;)`
            this.vars.Running_history = BeadSorter.Running_HistoryId.TOUR;
        } // end of behavior for Tour
    }
    
    #TOUR_exit()
    {
        // Tour behavior
        // uml: exit / { this.tracer?.exitState('Tour'); }
        {
            // Step 1: execute action `this.tracer?.exitState('Tour');`
            this.tracer?.exitState('Tour');
        } // end of behavior for Tour
        
        this.stateId = BeadSorter.StateId.SETUPCHECK;
    }
    
    #TOUR_do()
    {
        // Tour behavior
        // uml: 1. do [this.tracer?.log("ðŸ›¡ï¸ User evaluating guard: " + "tourBin>=DEFAULT_BIN") || this.evaluateGuard("Tour","1. do [tourBin>=DEFAULT_BIN] TransitionTo(TrainingMode)")] / { this.tracer?.edgeTransition("edge23"); } TransitionTo(TrainingMode)
        if (this.tracer?.log("ðŸ›¡ï¸ User evaluating guard: " + "tourBin>=DEFAULT_BIN") || this.evaluateGuard("Tour","1. do [tourBin>=DEFAULT_BIN] TransitionTo(TrainingMode)"))
        {
            // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(BeadSorter.StateId.RUNNING);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge23");`.
            this.tracer?.edgeTransition("edge23");
            
            // Step 3: Enter/move towards transition target `TrainingMode`.
            this.#TRAININGMODE_enter();
            
            // Finish transition by calling pseudo state transition function.
            this.#TrainingMode_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for Tour
        
        // Tour behavior
        // uml: do [this.tracer?.log("ðŸ›¡ï¸ User evaluating guard: " + "true") || this.evaluateGuard("Tour","do [true] TransitionTo(Tour)")] / { this.tracer?.edgeTransition("edge24"); } TransitionTo(Tour)
        if (this.tracer?.log("ðŸ›¡ï¸ User evaluating guard: " + "true") || this.evaluateGuard("Tour","do [true] TransitionTo(Tour)"))
        {
            // Step 1: Exit states until we reach `SetupCheck` state (Least Common Ancestor for transition).
            this.#TOUR_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge24");`.
            this.tracer?.edgeTransition("edge24");
            
            // Step 3: Enter/move towards transition target `Tour`.
            this.#TOUR_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Tour
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state SORTINGMODE
    ////////////////////////////////////////////////////////////////////////////////
    
    #SORTINGMODE_enter()
    {
        this.stateId = BeadSorter.StateId.SORTINGMODE;
        
        // SortingMode behavior
        // uml: enter / { this.tracer?.enterState('SortingMode'); }
        {
            // Step 1: execute action `this.tracer?.enterState('SortingMode');`
            this.tracer?.enterState('SortingMode');
        } // end of behavior for SortingMode
        
        // SortingMode behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE;) }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE;)`
            this.vars.Running_history = BeadSorter.Running_HistoryId.SORTINGMODE;
        } // end of behavior for SortingMode
    }
    
    #SORTINGMODE_exit()
    {
        // SortingMode behavior
        // uml: exit / { this.tracer?.exitState('SortingMode'); }
        {
            // Step 1: execute action `this.tracer?.exitState('SortingMode');`
            this.tracer?.exitState('SortingMode');
        } // end of behavior for SortingMode
        
        this.stateId = BeadSorter.StateId.RUNNING;
    }
    
    #SortingMode_InitialState_transition()
    {
        // SortingMode.<InitialState> behavior
        // uml: / { this.tracer?.edgeTransition("edge19"); } TransitionTo(SortingMode__Start)
        {
            // Step 1: Exit states until we reach `SortingMode` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge19");`.
            this.tracer?.edgeTransition("edge19");
            
            // Step 3: Enter/move towards transition target `SortingMode__Start`.
            this.#SORTINGMODE__START_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for SortingMode.<InitialState>
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state SORTINGMODE__DROPOFF
    ////////////////////////////////////////////////////////////////////////////////
    
    #SORTINGMODE__DROPOFF_enter()
    {
        this.stateId = BeadSorter.StateId.SORTINGMODE__DROPOFF;
        
        // SortingMode__Dropoff behavior
        // uml: enter / { this.tracer?.enterState('SortingMode__Dropoff'); }
        {
            // Step 1: execute action `this.tracer?.enterState('SortingMode__Dropoff');`
            this.tracer?.enterState('SortingMode__Dropoff');
        } // end of behavior for SortingMode__Dropoff
        
        // SortingMode__Dropoff behavior
        // uml: enter / { this.tracer?.log("âš¡ FSM would execute action: " + "picker.moveToAndShimmy(DEG_DROPOFF);"); }
        {
            // Step 1: execute action `this.tracer?.log("âš¡ FSM would execute action: " + "picker.moveToAndShimmy(DEG_DROPOFF);");`
            this.tracer?.log("âš¡ FSM would execute action: " + "picker.moveToAndShimmy(DEG_DROPOFF);");
        } // end of behavior for SortingMode__Dropoff
        
        // SortingMode__Dropoff behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__DROPOFF;) }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__DROPOFF;)`
            this.vars.Running_history = BeadSorter.Running_HistoryId.SORTINGMODE__DROPOFF;
        } // end of behavior for SortingMode__Dropoff
    }
    
    #SORTINGMODE__DROPOFF_exit()
    {
        // SortingMode__Dropoff behavior
        // uml: exit / { this.tracer?.exitState('SortingMode__Dropoff'); }
        {
            // Step 1: execute action `this.tracer?.exitState('SortingMode__Dropoff');`
            this.tracer?.exitState('SortingMode__Dropoff');
        } // end of behavior for SortingMode__Dropoff
        
        this.stateId = BeadSorter.StateId.SORTINGMODE;
    }
    
    #SORTINGMODE__DROPOFF_do()
    {
        // SortingMode__Dropoff behavior
        // uml: do / { this.tracer?.edgeTransition("edge17"); } TransitionTo(SortingMode__Pickup)
        {
            // Step 1: Exit states until we reach `SortingMode` state (Least Common Ancestor for transition).
            this.#SORTINGMODE__DROPOFF_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge17");`.
            this.tracer?.edgeTransition("edge17");
            
            // Step 3: Enter/move towards transition target `SortingMode__Pickup`.
            this.#SORTINGMODE__PICKUP_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for SortingMode__Dropoff
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state SORTINGMODE__PICKUP
    ////////////////////////////////////////////////////////////////////////////////
    
    #SORTINGMODE__PICKUP_enter()
    {
        this.stateId = BeadSorter.StateId.SORTINGMODE__PICKUP;
        
        // SortingMode__Pickup behavior
        // uml: enter / { this.tracer?.enterState('SortingMode__Pickup'); }
        {
            // Step 1: execute action `this.tracer?.enterState('SortingMode__Pickup');`
            this.tracer?.enterState('SortingMode__Pickup');
        } // end of behavior for SortingMode__Pickup
        
        // SortingMode__Pickup behavior
        // uml: enter / { this.tracer?.log("âš¡ FSM would execute action: " + "picker.moveTo(DEG_PICKUP);"); }
        {
            // Step 1: execute action `this.tracer?.log("âš¡ FSM would execute action: " + "picker.moveTo(DEG_PICKUP);");`
            this.tracer?.log("âš¡ FSM would execute action: " + "picker.moveTo(DEG_PICKUP);");
        } // end of behavior for SortingMode__Pickup
        
        // SortingMode__Pickup behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__PICKUP;) }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__PICKUP;)`
            this.vars.Running_history = BeadSorter.Running_HistoryId.SORTINGMODE__PICKUP;
        } // end of behavior for SortingMode__Pickup
    }
    
    #SORTINGMODE__PICKUP_exit()
    {
        // SortingMode__Pickup behavior
        // uml: exit / { this.tracer?.exitState('SortingMode__Pickup'); }
        {
            // Step 1: execute action `this.tracer?.exitState('SortingMode__Pickup');`
            this.tracer?.exitState('SortingMode__Pickup');
        } // end of behavior for SortingMode__Pickup
        
        this.stateId = BeadSorter.StateId.SORTINGMODE;
    }
    
    #SORTINGMODE__PICKUP_do()
    {
        // SortingMode__Pickup behavior
        // uml: do / { this.tracer?.edgeTransition("edge18"); } TransitionTo(SortingMode__Sensor)
        {
            // Step 1: Exit states until we reach `SortingMode` state (Least Common Ancestor for transition).
            this.#SORTINGMODE__PICKUP_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge18");`.
            this.tracer?.edgeTransition("edge18");
            
            // Step 3: Enter/move towards transition target `SortingMode__Sensor`.
            this.#SORTINGMODE__SENSOR_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for SortingMode__Pickup
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state SORTINGMODE__SENSOR
    ////////////////////////////////////////////////////////////////////////////////
    
    #SORTINGMODE__SENSOR_enter()
    {
        this.stateId = BeadSorter.StateId.SORTINGMODE__SENSOR;
        
        // SortingMode__Sensor behavior
        // uml: enter / { this.tracer?.enterState('SortingMode__Sensor'); }
        {
            // Step 1: execute action `this.tracer?.enterState('SortingMode__Sensor');`
            this.tracer?.enterState('SortingMode__Sensor');
        } // end of behavior for SortingMode__Sensor
        
        // SortingMode__Sensor behavior
        // uml: enter / { this.tracer?.log("âš¡ FSM would execute action: " + "picker.shimmyAndMoveTo(DEG_SENSOR);\nsorter.shimmyAndMoveTo(min(sorter.readColor(), DEFAULT_BIN));"); }
        {
            // Step 1: execute action `this.tracer?.log("âš¡ FSM would execute action: " + "picker.shimmyAndMoveTo(DEG_SENSOR);\nsorter.shimmyAndMoveTo(min(sorter.readColor(), DEFAULT_BIN));");`
            this.tracer?.log("âš¡ FSM would execute action: " + "picker.shimmyAndMoveTo(DEG_SENSOR);\nsorter.shimmyAndMoveTo(min(sorter.readColor(), DEFAULT_BIN));");
        } // end of behavior for SortingMode__Sensor
        
        // SortingMode__Sensor behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__SENSOR;) }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__SENSOR;)`
            this.vars.Running_history = BeadSorter.Running_HistoryId.SORTINGMODE__SENSOR;
        } // end of behavior for SortingMode__Sensor
    }
    
    #SORTINGMODE__SENSOR_exit()
    {
        // SortingMode__Sensor behavior
        // uml: exit / { this.tracer?.exitState('SortingMode__Sensor'); }
        {
            // Step 1: execute action `this.tracer?.exitState('SortingMode__Sensor');`
            this.tracer?.exitState('SortingMode__Sensor');
        } // end of behavior for SortingMode__Sensor
        
        this.stateId = BeadSorter.StateId.SORTINGMODE;
    }
    
    #SORTINGMODE__SENSOR_do()
    {
        // SortingMode__Sensor behavior
        // uml: do / { this.tracer?.edgeTransition("edge21"); } TransitionTo(SortingMode__Dropoff)
        {
            // Step 1: Exit states until we reach `SortingMode` state (Least Common Ancestor for transition).
            this.#SORTINGMODE__SENSOR_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge21");`.
            this.tracer?.edgeTransition("edge21");
            
            // Step 3: Enter/move towards transition target `SortingMode__Dropoff`.
            this.#SORTINGMODE__DROPOFF_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for SortingMode__Sensor
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state SORTINGMODE__START
    ////////////////////////////////////////////////////////////////////////////////
    
    #SORTINGMODE__START_enter()
    {
        this.stateId = BeadSorter.StateId.SORTINGMODE__START;
        
        // SortingMode__Start behavior
        // uml: enter / { this.tracer?.enterState('SortingMode__Start'); }
        {
            // Step 1: execute action `this.tracer?.enterState('SortingMode__Start');`
            this.tracer?.enterState('SortingMode__Start');
        } // end of behavior for SortingMode__Start
        
        // SortingMode__Start behavior
        // uml: enter / { this.tracer?.log("âš¡ FSM would execute action: " + "modeDisplay.clear();"); }
        {
            // Step 1: execute action `this.tracer?.log("âš¡ FSM would execute action: " + "modeDisplay.clear();");`
            this.tracer?.log("âš¡ FSM would execute action: " + "modeDisplay.clear();");
        } // end of behavior for SortingMode__Start
        
        // SortingMode__Start behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__START;) }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__START;)`
            this.vars.Running_history = BeadSorter.Running_HistoryId.SORTINGMODE__START;
        } // end of behavior for SortingMode__Start
    }
    
    #SORTINGMODE__START_exit()
    {
        // SortingMode__Start behavior
        // uml: exit / { this.tracer?.exitState('SortingMode__Start'); }
        {
            // Step 1: execute action `this.tracer?.exitState('SortingMode__Start');`
            this.tracer?.exitState('SortingMode__Start');
        } // end of behavior for SortingMode__Start
        
        this.stateId = BeadSorter.StateId.SORTINGMODE;
    }
    
    #SORTINGMODE__START_do()
    {
        // SortingMode__Start behavior
        // uml: do / { this.tracer?.edgeTransition("edge20"); } TransitionTo(SortingMode__Pickup)
        {
            // Step 1: Exit states until we reach `SortingMode` state (Least Common Ancestor for transition).
            this.#SORTINGMODE__START_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge20");`.
            this.tracer?.edgeTransition("edge20");
            
            // Step 3: Enter/move towards transition target `SortingMode__Pickup`.
            this.#SORTINGMODE__PICKUP_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for SortingMode__Start
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state TRAININGMODE
    ////////////////////////////////////////////////////////////////////////////////
    
    #TRAININGMODE_enter()
    {
        this.stateId = BeadSorter.StateId.TRAININGMODE;
        
        // TrainingMode behavior
        // uml: enter / { this.tracer?.enterState('TrainingMode'); }
        {
            // Step 1: execute action `this.tracer?.enterState('TrainingMode');`
            this.tracer?.enterState('TrainingMode');
        } // end of behavior for TrainingMode
        
        // TrainingMode behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.TRAININGMODE;) }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.TRAININGMODE;)`
            this.vars.Running_history = BeadSorter.Running_HistoryId.TRAININGMODE;
        } // end of behavior for TrainingMode
    }
    
    #TRAININGMODE_exit()
    {
        // TrainingMode behavior
        // uml: exit / { this.tracer?.exitState('TrainingMode'); }
        {
            // Step 1: execute action `this.tracer?.exitState('TrainingMode');`
            this.tracer?.exitState('TrainingMode');
        } // end of behavior for TrainingMode
        
        this.stateId = BeadSorter.StateId.RUNNING;
    }
    
    #TrainingMode_InitialState_transition()
    {
        // TrainingMode.<InitialState> behavior
        // uml: / { this.tracer?.edgeTransition("edge16"); } TransitionTo(TrainingMode__Start)
        {
            // Step 1: Exit states until we reach `TrainingMode` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge16");`.
            this.tracer?.edgeTransition("edge16");
            
            // Step 3: Enter/move towards transition target `TrainingMode__Start`.
            this.#TRAININGMODE__START_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for TrainingMode.<InitialState>
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state READEMPTYSLOT
    ////////////////////////////////////////////////////////////////////////////////
    
    #READEMPTYSLOT_enter()
    {
        this.stateId = BeadSorter.StateId.READEMPTYSLOT;
        
        // ReadEmptySlot behavior
        // uml: enter / { this.tracer?.enterState('ReadEmptySlot'); }
        {
            // Step 1: execute action `this.tracer?.enterState('ReadEmptySlot');`
            this.tracer?.enterState('ReadEmptySlot');
        } // end of behavior for ReadEmptySlot
        
        // ReadEmptySlot behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.READEMPTYSLOT;) }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.READEMPTYSLOT;)`
            this.vars.Running_history = BeadSorter.Running_HistoryId.READEMPTYSLOT;
        } // end of behavior for ReadEmptySlot
    }
    
    #READEMPTYSLOT_exit()
    {
        // ReadEmptySlot behavior
        // uml: exit / { this.tracer?.exitState('ReadEmptySlot'); }
        {
            // Step 1: execute action `this.tracer?.exitState('ReadEmptySlot');`
            this.tracer?.exitState('ReadEmptySlot');
        } // end of behavior for ReadEmptySlot
        
        this.stateId = BeadSorter.StateId.TRAININGMODE;
    }
    
    #ReadEmptySlot_InitialState_transition()
    {
        // ReadEmptySlot.<InitialState> behavior
        // uml: / { this.tracer?.edgeTransition("edge1"); } TransitionTo(ReadEmptySlot__Dropoff)
        {
            // Step 1: Exit states until we reach `ReadEmptySlot` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge1");`.
            this.tracer?.edgeTransition("edge1");
            
            // Step 3: Enter/move towards transition target `ReadEmptySlot__Dropoff`.
            this.#READEMPTYSLOT__DROPOFF_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ReadEmptySlot.<InitialState>
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state READEMPTYSLOT__DROPOFF
    ////////////////////////////////////////////////////////////////////////////////
    
    #READEMPTYSLOT__DROPOFF_enter()
    {
        this.stateId = BeadSorter.StateId.READEMPTYSLOT__DROPOFF;
        
        // ReadEmptySlot__Dropoff behavior
        // uml: enter / { this.tracer?.enterState('ReadEmptySlot__Dropoff'); }
        {
            // Step 1: execute action `this.tracer?.enterState('ReadEmptySlot__Dropoff');`
            this.tracer?.enterState('ReadEmptySlot__Dropoff');
        } // end of behavior for ReadEmptySlot__Dropoff
        
        // ReadEmptySlot__Dropoff behavior
        // uml: enter / { this.tracer?.log("âš¡ FSM would execute action: " + "picker.moveToAndShimmy(DEG_DROPOFF);"); }
        {
            // Step 1: execute action `this.tracer?.log("âš¡ FSM would execute action: " + "picker.moveToAndShimmy(DEG_DROPOFF);");`
            this.tracer?.log("âš¡ FSM would execute action: " + "picker.moveToAndShimmy(DEG_DROPOFF);");
        } // end of behavior for ReadEmptySlot__Dropoff
        
        // ReadEmptySlot__Dropoff behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.READEMPTYSLOT__DROPOFF;) }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.READEMPTYSLOT__DROPOFF;)`
            this.vars.Running_history = BeadSorter.Running_HistoryId.READEMPTYSLOT__DROPOFF;
        } // end of behavior for ReadEmptySlot__Dropoff
    }
    
    #READEMPTYSLOT__DROPOFF_exit()
    {
        // ReadEmptySlot__Dropoff behavior
        // uml: exit / { this.tracer?.exitState('ReadEmptySlot__Dropoff'); }
        {
            // Step 1: execute action `this.tracer?.exitState('ReadEmptySlot__Dropoff');`
            this.tracer?.exitState('ReadEmptySlot__Dropoff');
        } // end of behavior for ReadEmptySlot__Dropoff
        
        this.stateId = BeadSorter.StateId.READEMPTYSLOT;
    }
    
    #READEMPTYSLOT__DROPOFF_do()
    {
        // ReadEmptySlot__Dropoff behavior
        // uml: do / { this.tracer?.edgeTransition("edge2"); } TransitionTo(ReadEmptySlot__Sensor)
        {
            // Step 1: Exit states until we reach `ReadEmptySlot` state (Least Common Ancestor for transition).
            this.#READEMPTYSLOT__DROPOFF_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge2");`.
            this.tracer?.edgeTransition("edge2");
            
            // Step 3: Enter/move towards transition target `ReadEmptySlot__Sensor`.
            this.#READEMPTYSLOT__SENSOR_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ReadEmptySlot__Dropoff
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state READEMPTYSLOT__SENSOR
    ////////////////////////////////////////////////////////////////////////////////
    
    #READEMPTYSLOT__SENSOR_enter()
    {
        this.stateId = BeadSorter.StateId.READEMPTYSLOT__SENSOR;
        
        // ReadEmptySlot__Sensor behavior
        // uml: enter / { this.tracer?.enterState('ReadEmptySlot__Sensor'); }
        {
            // Step 1: execute action `this.tracer?.enterState('ReadEmptySlot__Sensor');`
            this.tracer?.enterState('ReadEmptySlot__Sensor');
        } // end of behavior for ReadEmptySlot__Sensor
        
        // ReadEmptySlot__Sensor behavior
        // uml: enter / { this.tracer?.log("âš¡ FSM would execute action: " + "picker.moveTo(DEG_SENSOR);\nempties++;\nsorter.readColor();"); }
        {
            // Step 1: execute action `this.tracer?.log("âš¡ FSM would execute action: " + "picker.moveTo(DEG_SENSOR);\nempties++;\nsorter.readColor();");`
            this.tracer?.log("âš¡ FSM would execute action: " + "picker.moveTo(DEG_SENSOR);\nempties++;\nsorter.readColor();");
        } // end of behavior for ReadEmptySlot__Sensor
        
        // ReadEmptySlot__Sensor behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.READEMPTYSLOT__SENSOR;) }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.READEMPTYSLOT__SENSOR;)`
            this.vars.Running_history = BeadSorter.Running_HistoryId.READEMPTYSLOT__SENSOR;
        } // end of behavior for ReadEmptySlot__Sensor
    }
    
    #READEMPTYSLOT__SENSOR_exit()
    {
        // ReadEmptySlot__Sensor behavior
        // uml: exit / { this.tracer?.exitState('ReadEmptySlot__Sensor'); }
        {
            // Step 1: execute action `this.tracer?.exitState('ReadEmptySlot__Sensor');`
            this.tracer?.exitState('ReadEmptySlot__Sensor');
        } // end of behavior for ReadEmptySlot__Sensor
        
        this.stateId = BeadSorter.StateId.READEMPTYSLOT;
    }
    
    #READEMPTYSLOT__SENSOR_do()
    {
        // ReadEmptySlot__Sensor behavior
        // uml: 1. do [this.tracer?.log("ðŸ›¡ï¸ User evaluating guard: " + "empties>=NUM_EMPTY_READS") || this.evaluateGuard("ReadEmptySlot__Sensor","1. do [empties>=NUM_EMPTY_READS] TransitionTo(ReadJammedSlot)")] / { this.tracer?.edgeTransition("edge4"); } TransitionTo(ReadJammedSlot)
        if (this.tracer?.log("ðŸ›¡ï¸ User evaluating guard: " + "empties>=NUM_EMPTY_READS") || this.evaluateGuard("ReadEmptySlot__Sensor","1. do [empties>=NUM_EMPTY_READS] TransitionTo(ReadJammedSlot)"))
        {
            // Step 1: Exit states until we reach `TrainingMode` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(BeadSorter.StateId.TRAININGMODE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge4");`.
            this.tracer?.edgeTransition("edge4");
            
            // Step 3: Enter/move towards transition target `ReadJammedSlot`.
            this.#READJAMMEDSLOT_enter();
            
            // Finish transition by calling pseudo state transition function.
            this.#ReadJammedSlot_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for ReadEmptySlot__Sensor
        
        // ReadEmptySlot__Sensor behavior
        // uml: do / { this.tracer?.edgeTransition("edge3"); } TransitionTo(ReadEmptySlot__Dropoff)
        {
            // Step 1: Exit states until we reach `ReadEmptySlot` state (Least Common Ancestor for transition).
            this.#READEMPTYSLOT__SENSOR_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge3");`.
            this.tracer?.edgeTransition("edge3");
            
            // Step 3: Enter/move towards transition target `ReadEmptySlot__Dropoff`.
            this.#READEMPTYSLOT__DROPOFF_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ReadEmptySlot__Sensor
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state READJAMMEDSLOT
    ////////////////////////////////////////////////////////////////////////////////
    
    #READJAMMEDSLOT_enter()
    {
        this.stateId = BeadSorter.StateId.READJAMMEDSLOT;
        
        // ReadJammedSlot behavior
        // uml: enter / { this.tracer?.enterState('ReadJammedSlot'); }
        {
            // Step 1: execute action `this.tracer?.enterState('ReadJammedSlot');`
            this.tracer?.enterState('ReadJammedSlot');
        } // end of behavior for ReadJammedSlot
        
        // ReadJammedSlot behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.READJAMMEDSLOT;) }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.READJAMMEDSLOT;)`
            this.vars.Running_history = BeadSorter.Running_HistoryId.READJAMMEDSLOT;
        } // end of behavior for ReadJammedSlot
    }
    
    #READJAMMEDSLOT_exit()
    {
        // ReadJammedSlot behavior
        // uml: exit / { this.tracer?.exitState('ReadJammedSlot'); }
        {
            // Step 1: execute action `this.tracer?.exitState('ReadJammedSlot');`
            this.tracer?.exitState('ReadJammedSlot');
        } // end of behavior for ReadJammedSlot
        
        this.stateId = BeadSorter.StateId.TRAININGMODE;
    }
    
    #ReadJammedSlot_InitialState_transition()
    {
        // ReadJammedSlot.<InitialState> behavior
        // uml: / { this.tracer?.edgeTransition("edge5"); } TransitionTo(Jammed)
        {
            // Step 1: Exit states until we reach `ReadJammedSlot` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge5");`.
            this.tracer?.edgeTransition("edge5");
            
            // Step 3: Enter/move towards transition target `Jammed`.
            this.#JAMMED_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ReadJammedSlot.<InitialState>
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state JAMMED
    ////////////////////////////////////////////////////////////////////////////////
    
    #JAMMED_enter()
    {
        this.stateId = BeadSorter.StateId.JAMMED;
        
        // Jammed behavior
        // uml: enter / { this.tracer?.enterState('Jammed'); }
        {
            // Step 1: execute action `this.tracer?.enterState('Jammed');`
            this.tracer?.enterState('Jammed');
        } // end of behavior for Jammed
        
        // Jammed behavior
        // uml: enter / { this.tracer?.log("âš¡ FSM would execute action: " + "picker.moveTo(DEG_JAMMED_READ);"); }
        {
            // Step 1: execute action `this.tracer?.log("âš¡ FSM would execute action: " + "picker.moveTo(DEG_JAMMED_READ);");`
            this.tracer?.log("âš¡ FSM would execute action: " + "picker.moveTo(DEG_JAMMED_READ);");
        } // end of behavior for Jammed
        
        // Jammed behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.JAMMED;) }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.JAMMED;)`
            this.vars.Running_history = BeadSorter.Running_HistoryId.JAMMED;
        } // end of behavior for Jammed
    }
    
    #JAMMED_exit()
    {
        // Jammed behavior
        // uml: exit / { this.tracer?.exitState('Jammed'); }
        {
            // Step 1: execute action `this.tracer?.exitState('Jammed');`
            this.tracer?.exitState('Jammed');
        } // end of behavior for Jammed
        
        this.stateId = BeadSorter.StateId.READJAMMEDSLOT;
    }
    
    #JAMMED_do()
    {
        // Jammed behavior
        // uml: do / { this.tracer?.edgeTransition("edge8"); } TransitionTo(ReadJammedSlot__Sensor)
        {
            // Step 1: Exit states until we reach `ReadJammedSlot` state (Least Common Ancestor for transition).
            this.#JAMMED_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge8");`.
            this.tracer?.edgeTransition("edge8");
            
            // Step 3: Enter/move towards transition target `ReadJammedSlot__Sensor`.
            this.#READJAMMEDSLOT__SENSOR_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Jammed
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state READJAMMEDSLOT__DROPOFF
    ////////////////////////////////////////////////////////////////////////////////
    
    #READJAMMEDSLOT__DROPOFF_enter()
    {
        this.stateId = BeadSorter.StateId.READJAMMEDSLOT__DROPOFF;
        
        // ReadJammedSlot__Dropoff behavior
        // uml: enter / { this.tracer?.enterState('ReadJammedSlot__Dropoff'); }
        {
            // Step 1: execute action `this.tracer?.enterState('ReadJammedSlot__Dropoff');`
            this.tracer?.enterState('ReadJammedSlot__Dropoff');
        } // end of behavior for ReadJammedSlot__Dropoff
        
        // ReadJammedSlot__Dropoff behavior
        // uml: enter / { this.tracer?.log("âš¡ FSM would execute action: " + "picker.moveToAndShimmy(DEG_DROPOFF);"); }
        {
            // Step 1: execute action `this.tracer?.log("âš¡ FSM would execute action: " + "picker.moveToAndShimmy(DEG_DROPOFF);");`
            this.tracer?.log("âš¡ FSM would execute action: " + "picker.moveToAndShimmy(DEG_DROPOFF);");
        } // end of behavior for ReadJammedSlot__Dropoff
        
        // ReadJammedSlot__Dropoff behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.READJAMMEDSLOT__DROPOFF;) }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.READJAMMEDSLOT__DROPOFF;)`
            this.vars.Running_history = BeadSorter.Running_HistoryId.READJAMMEDSLOT__DROPOFF;
        } // end of behavior for ReadJammedSlot__Dropoff
    }
    
    #READJAMMEDSLOT__DROPOFF_exit()
    {
        // ReadJammedSlot__Dropoff behavior
        // uml: exit / { this.tracer?.exitState('ReadJammedSlot__Dropoff'); }
        {
            // Step 1: execute action `this.tracer?.exitState('ReadJammedSlot__Dropoff');`
            this.tracer?.exitState('ReadJammedSlot__Dropoff');
        } // end of behavior for ReadJammedSlot__Dropoff
        
        this.stateId = BeadSorter.StateId.READJAMMEDSLOT;
    }
    
    #READJAMMEDSLOT__DROPOFF_do()
    {
        // ReadJammedSlot__Dropoff behavior
        // uml: 1. do [this.tracer?.log("ðŸ›¡ï¸ User evaluating guard: " + "jammies>=NUM_JAMMED_READS") || this.evaluateGuard("ReadJammedSlot__Dropoff","1. do [jammies>=NUM_JAMMED_READS] TransitionTo(ReadSlot)")] / { this.tracer?.edgeTransition("edge7"); } TransitionTo(ReadSlot)
        if (this.tracer?.log("ðŸ›¡ï¸ User evaluating guard: " + "jammies>=NUM_JAMMED_READS") || this.evaluateGuard("ReadJammedSlot__Dropoff","1. do [jammies>=NUM_JAMMED_READS] TransitionTo(ReadSlot)"))
        {
            // Step 1: Exit states until we reach `TrainingMode` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(BeadSorter.StateId.TRAININGMODE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge7");`.
            this.tracer?.edgeTransition("edge7");
            
            // Step 3: Enter/move towards transition target `ReadSlot`.
            this.#READSLOT_enter();
            
            // Finish transition by calling pseudo state transition function.
            this.#ReadSlot_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for ReadJammedSlot__Dropoff
        
        // ReadJammedSlot__Dropoff behavior
        // uml: do / { this.tracer?.edgeTransition("edge6"); } TransitionTo(Jammed)
        {
            // Step 1: Exit states until we reach `ReadJammedSlot` state (Least Common Ancestor for transition).
            this.#READJAMMEDSLOT__DROPOFF_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge6");`.
            this.tracer?.edgeTransition("edge6");
            
            // Step 3: Enter/move towards transition target `Jammed`.
            this.#JAMMED_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ReadJammedSlot__Dropoff
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state READJAMMEDSLOT__SENSOR
    ////////////////////////////////////////////////////////////////////////////////
    
    #READJAMMEDSLOT__SENSOR_enter()
    {
        this.stateId = BeadSorter.StateId.READJAMMEDSLOT__SENSOR;
        
        // ReadJammedSlot__Sensor behavior
        // uml: enter / { this.tracer?.enterState('ReadJammedSlot__Sensor'); }
        {
            // Step 1: execute action `this.tracer?.enterState('ReadJammedSlot__Sensor');`
            this.tracer?.enterState('ReadJammedSlot__Sensor');
        } // end of behavior for ReadJammedSlot__Sensor
        
        // ReadJammedSlot__Sensor behavior
        // uml: enter / { this.tracer?.log("âš¡ FSM would execute action: " + "jammies++;\nsorter.readColor();"); }
        {
            // Step 1: execute action `this.tracer?.log("âš¡ FSM would execute action: " + "jammies++;\nsorter.readColor();");`
            this.tracer?.log("âš¡ FSM would execute action: " + "jammies++;\nsorter.readColor();");
        } // end of behavior for ReadJammedSlot__Sensor
        
        // ReadJammedSlot__Sensor behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.READJAMMEDSLOT__SENSOR;) }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.READJAMMEDSLOT__SENSOR;)`
            this.vars.Running_history = BeadSorter.Running_HistoryId.READJAMMEDSLOT__SENSOR;
        } // end of behavior for ReadJammedSlot__Sensor
    }
    
    #READJAMMEDSLOT__SENSOR_exit()
    {
        // ReadJammedSlot__Sensor behavior
        // uml: exit / { this.tracer?.exitState('ReadJammedSlot__Sensor'); }
        {
            // Step 1: execute action `this.tracer?.exitState('ReadJammedSlot__Sensor');`
            this.tracer?.exitState('ReadJammedSlot__Sensor');
        } // end of behavior for ReadJammedSlot__Sensor
        
        this.stateId = BeadSorter.StateId.READJAMMEDSLOT;
    }
    
    #READJAMMEDSLOT__SENSOR_do()
    {
        // ReadJammedSlot__Sensor behavior
        // uml: do / { this.tracer?.edgeTransition("edge9"); } TransitionTo(ReadJammedSlot__Dropoff)
        {
            // Step 1: Exit states until we reach `ReadJammedSlot` state (Least Common Ancestor for transition).
            this.#READJAMMEDSLOT__SENSOR_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge9");`.
            this.tracer?.edgeTransition("edge9");
            
            // Step 3: Enter/move towards transition target `ReadJammedSlot__Dropoff`.
            this.#READJAMMEDSLOT__DROPOFF_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ReadJammedSlot__Sensor
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state READSLOT
    ////////////////////////////////////////////////////////////////////////////////
    
    #READSLOT_enter()
    {
        this.stateId = BeadSorter.StateId.READSLOT;
        
        // ReadSlot behavior
        // uml: enter / { this.tracer?.enterState('ReadSlot'); }
        {
            // Step 1: execute action `this.tracer?.enterState('ReadSlot');`
            this.tracer?.enterState('ReadSlot');
        } // end of behavior for ReadSlot
        
        // ReadSlot behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.READSLOT;) }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.READSLOT;)`
            this.vars.Running_history = BeadSorter.Running_HistoryId.READSLOT;
        } // end of behavior for ReadSlot
    }
    
    #READSLOT_exit()
    {
        // ReadSlot behavior
        // uml: exit / { this.tracer?.exitState('ReadSlot'); }
        {
            // Step 1: execute action `this.tracer?.exitState('ReadSlot');`
            this.tracer?.exitState('ReadSlot');
        } // end of behavior for ReadSlot
        
        this.stateId = BeadSorter.StateId.TRAININGMODE;
    }
    
    #ReadSlot_InitialState_transition()
    {
        // ReadSlot.<InitialState> behavior
        // uml: / { this.tracer?.edgeTransition("edge10"); } TransitionTo(TrainingMode__Pickup)
        {
            // Step 1: Exit states until we reach `ReadSlot` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge10");`.
            this.tracer?.edgeTransition("edge10");
            
            // Step 3: Enter/move towards transition target `TrainingMode__Pickup`.
            this.#TRAININGMODE__PICKUP_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ReadSlot.<InitialState>
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state READSLOT__DROPOFF
    ////////////////////////////////////////////////////////////////////////////////
    
    #READSLOT__DROPOFF_enter()
    {
        this.stateId = BeadSorter.StateId.READSLOT__DROPOFF;
        
        // ReadSlot__Dropoff behavior
        // uml: enter / { this.tracer?.enterState('ReadSlot__Dropoff'); }
        {
            // Step 1: execute action `this.tracer?.enterState('ReadSlot__Dropoff');`
            this.tracer?.enterState('ReadSlot__Dropoff');
        } // end of behavior for ReadSlot__Dropoff
        
        // ReadSlot__Dropoff behavior
        // uml: enter / { this.tracer?.log("âš¡ FSM would execute action: " + "picker.moveToAndShimmy(DEG_DROPOFF);"); }
        {
            // Step 1: execute action `this.tracer?.log("âš¡ FSM would execute action: " + "picker.moveToAndShimmy(DEG_DROPOFF);");`
            this.tracer?.log("âš¡ FSM would execute action: " + "picker.moveToAndShimmy(DEG_DROPOFF);");
        } // end of behavior for ReadSlot__Dropoff
        
        // ReadSlot__Dropoff behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.READSLOT__DROPOFF;) }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.READSLOT__DROPOFF;)`
            this.vars.Running_history = BeadSorter.Running_HistoryId.READSLOT__DROPOFF;
        } // end of behavior for ReadSlot__Dropoff
    }
    
    #READSLOT__DROPOFF_exit()
    {
        // ReadSlot__Dropoff behavior
        // uml: exit / { this.tracer?.exitState('ReadSlot__Dropoff'); }
        {
            // Step 1: execute action `this.tracer?.exitState('ReadSlot__Dropoff');`
            this.tracer?.exitState('ReadSlot__Dropoff');
        } // end of behavior for ReadSlot__Dropoff
        
        this.stateId = BeadSorter.StateId.READSLOT;
    }
    
    #READSLOT__DROPOFF_do()
    {
        // ReadSlot__Dropoff behavior
        // uml: 1. do [this.tracer?.log("ðŸ›¡ï¸ User evaluating guard: " + "sorter.isTrainingDone()") || this.evaluateGuard("ReadSlot__Dropoff","1. do [sorter.isTrainingDone()] TransitionTo(SortingMode)")] / { this.tracer?.edgeTransition("edge12"); } TransitionTo(SortingMode)
        if (this.tracer?.log("ðŸ›¡ï¸ User evaluating guard: " + "sorter.isTrainingDone()") || this.evaluateGuard("ReadSlot__Dropoff","1. do [sorter.isTrainingDone()] TransitionTo(SortingMode)"))
        {
            // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(BeadSorter.StateId.RUNNING);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge12");`.
            this.tracer?.edgeTransition("edge12");
            
            // Step 3: Enter/move towards transition target `SortingMode`.
            this.#SORTINGMODE_enter();
            
            // Finish transition by calling pseudo state transition function.
            this.#SortingMode_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for ReadSlot__Dropoff
        
        // ReadSlot__Dropoff behavior
        // uml: do / { this.tracer?.edgeTransition("edge11"); } TransitionTo(TrainingMode__Pickup)
        {
            // Step 1: Exit states until we reach `ReadSlot` state (Least Common Ancestor for transition).
            this.#READSLOT__DROPOFF_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge11");`.
            this.tracer?.edgeTransition("edge11");
            
            // Step 3: Enter/move towards transition target `TrainingMode__Pickup`.
            this.#TRAININGMODE__PICKUP_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ReadSlot__Dropoff
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state READSLOT__SENSOR
    ////////////////////////////////////////////////////////////////////////////////
    
    #READSLOT__SENSOR_enter()
    {
        this.stateId = BeadSorter.StateId.READSLOT__SENSOR;
        
        // ReadSlot__Sensor behavior
        // uml: enter / { this.tracer?.enterState('ReadSlot__Sensor'); }
        {
            // Step 1: execute action `this.tracer?.enterState('ReadSlot__Sensor');`
            this.tracer?.enterState('ReadSlot__Sensor');
        } // end of behavior for ReadSlot__Sensor
        
        // ReadSlot__Sensor behavior
        // uml: enter / { this.tracer?.log("âš¡ FSM would execute action: " + "picker.shimmyAndMoveTo(DEG_SENSOR);\nsorter.readColor();\nsorter.runTraining();\nsorter.shimmyAndMoveTo(DEFAULT_BIN);"); }
        {
            // Step 1: execute action `this.tracer?.log("âš¡ FSM would execute action: " + "picker.shimmyAndMoveTo(DEG_SENSOR);\nsorter.readColor();\nsorter.runTraining();\nsorter.shimmyAndMoveTo(DEFAULT_BIN);");`
            this.tracer?.log("âš¡ FSM would execute action: " + "picker.shimmyAndMoveTo(DEG_SENSOR);\nsorter.readColor();\nsorter.runTraining();\nsorter.shimmyAndMoveTo(DEFAULT_BIN);");
        } // end of behavior for ReadSlot__Sensor
        
        // ReadSlot__Sensor behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.READSLOT__SENSOR;) }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.READSLOT__SENSOR;)`
            this.vars.Running_history = BeadSorter.Running_HistoryId.READSLOT__SENSOR;
        } // end of behavior for ReadSlot__Sensor
    }
    
    #READSLOT__SENSOR_exit()
    {
        // ReadSlot__Sensor behavior
        // uml: exit / { this.tracer?.exitState('ReadSlot__Sensor'); }
        {
            // Step 1: execute action `this.tracer?.exitState('ReadSlot__Sensor');`
            this.tracer?.exitState('ReadSlot__Sensor');
        } // end of behavior for ReadSlot__Sensor
        
        this.stateId = BeadSorter.StateId.READSLOT;
    }
    
    #READSLOT__SENSOR_do()
    {
        // ReadSlot__Sensor behavior
        // uml: do / { this.tracer?.edgeTransition("edge14"); } TransitionTo(ReadSlot__Dropoff)
        {
            // Step 1: Exit states until we reach `ReadSlot` state (Least Common Ancestor for transition).
            this.#READSLOT__SENSOR_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge14");`.
            this.tracer?.edgeTransition("edge14");
            
            // Step 3: Enter/move towards transition target `ReadSlot__Dropoff`.
            this.#READSLOT__DROPOFF_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ReadSlot__Sensor
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state TRAININGMODE__PICKUP
    ////////////////////////////////////////////////////////////////////////////////
    
    #TRAININGMODE__PICKUP_enter()
    {
        this.stateId = BeadSorter.StateId.TRAININGMODE__PICKUP;
        
        // TrainingMode__Pickup behavior
        // uml: enter / { this.tracer?.enterState('TrainingMode__Pickup'); }
        {
            // Step 1: execute action `this.tracer?.enterState('TrainingMode__Pickup');`
            this.tracer?.enterState('TrainingMode__Pickup');
        } // end of behavior for TrainingMode__Pickup
        
        // TrainingMode__Pickup behavior
        // uml: enter / { this.tracer?.log("âš¡ FSM would execute action: " + "picker.moveTo(DEG_PICKUP);"); }
        {
            // Step 1: execute action `this.tracer?.log("âš¡ FSM would execute action: " + "picker.moveTo(DEG_PICKUP);");`
            this.tracer?.log("âš¡ FSM would execute action: " + "picker.moveTo(DEG_PICKUP);");
        } // end of behavior for TrainingMode__Pickup
        
        // TrainingMode__Pickup behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.TRAININGMODE__PICKUP;) }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.TRAININGMODE__PICKUP;)`
            this.vars.Running_history = BeadSorter.Running_HistoryId.TRAININGMODE__PICKUP;
        } // end of behavior for TrainingMode__Pickup
    }
    
    #TRAININGMODE__PICKUP_exit()
    {
        // TrainingMode__Pickup behavior
        // uml: exit / { this.tracer?.exitState('TrainingMode__Pickup'); }
        {
            // Step 1: execute action `this.tracer?.exitState('TrainingMode__Pickup');`
            this.tracer?.exitState('TrainingMode__Pickup');
        } // end of behavior for TrainingMode__Pickup
        
        this.stateId = BeadSorter.StateId.READSLOT;
    }
    
    #TRAININGMODE__PICKUP_do()
    {
        // TrainingMode__Pickup behavior
        // uml: do / { this.tracer?.edgeTransition("edge13"); } TransitionTo(ReadSlot__Sensor)
        {
            // Step 1: Exit states until we reach `ReadSlot` state (Least Common Ancestor for transition).
            this.#TRAININGMODE__PICKUP_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge13");`.
            this.tracer?.edgeTransition("edge13");
            
            // Step 3: Enter/move towards transition target `ReadSlot__Sensor`.
            this.#READSLOT__SENSOR_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for TrainingMode__Pickup
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state TRAININGMODE__START
    ////////////////////////////////////////////////////////////////////////////////
    
    #TRAININGMODE__START_enter()
    {
        this.stateId = BeadSorter.StateId.TRAININGMODE__START;
        
        // TrainingMode__Start behavior
        // uml: enter / { this.tracer?.enterState('TrainingMode__Start'); }
        {
            // Step 1: execute action `this.tracer?.enterState('TrainingMode__Start');`
            this.tracer?.enterState('TrainingMode__Start');
        } // end of behavior for TrainingMode__Start
        
        // TrainingMode__Start behavior
        // uml: enter / { this.tracer?.log("âš¡ FSM would execute action: " + "modeDisplay.print(\"TRAINING\");"); }
        {
            // Step 1: execute action `this.tracer?.log("âš¡ FSM would execute action: " + "modeDisplay.print(\"TRAINING\");");`
            this.tracer?.log("âš¡ FSM would execute action: " + "modeDisplay.print(\"TRAINING\");");
        } // end of behavior for TrainingMode__Start
        
        // TrainingMode__Start behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.TRAININGMODE__START;) }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.TRAININGMODE__START;)`
            this.vars.Running_history = BeadSorter.Running_HistoryId.TRAININGMODE__START;
        } // end of behavior for TrainingMode__Start
    }
    
    #TRAININGMODE__START_exit()
    {
        // TrainingMode__Start behavior
        // uml: exit / { this.tracer?.exitState('TrainingMode__Start'); }
        {
            // Step 1: execute action `this.tracer?.exitState('TrainingMode__Start');`
            this.tracer?.exitState('TrainingMode__Start');
        } // end of behavior for TrainingMode__Start
        
        this.stateId = BeadSorter.StateId.TRAININGMODE;
    }
    
    #TRAININGMODE__START_do()
    {
        // TrainingMode__Start behavior
        // uml: do / { this.tracer?.edgeTransition("edge15"); } TransitionTo(ReadEmptySlot)
        {
            // Step 1: Exit states until we reach `TrainingMode` state (Least Common Ancestor for transition).
            this.#TRAININGMODE__START_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition("edge15");`.
            this.tracer?.edgeTransition("edge15");
            
            // Step 3: Enter/move towards transition target `ReadEmptySlot`.
            this.#READEMPTYSLOT_enter();
            
            // Finish transition by calling pseudo state transition function.
            this.#ReadEmptySlot_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for TrainingMode__Start
        
        // No ancestor handles this event.
    }
    
    // Thread safe.
    static stateIdToString(id)
    {
        switch (id)
        {
            case BeadSorter.StateId.ROOT: return "ROOT";
            case BeadSorter.StateId.PAUSED: return "PAUSED";
            case BeadSorter.StateId.RUNNING: return "RUNNING";
            case BeadSorter.StateId.SETUPCHECK: return "SETUPCHECK";
            case BeadSorter.StateId.ADJUSTSERVOOFFSETS: return "ADJUSTSERVOOFFSETS";
            case BeadSorter.StateId.DECREASE: return "DECREASE";
            case BeadSorter.StateId.INCREASE: return "INCREASE";
            case BeadSorter.StateId.WAIT: return "WAIT";
            case BeadSorter.StateId.SETUPCHECK__START: return "SETUPCHECK__START";
            case BeadSorter.StateId.TOUR: return "TOUR";
            case BeadSorter.StateId.SORTINGMODE: return "SORTINGMODE";
            case BeadSorter.StateId.SORTINGMODE__DROPOFF: return "SORTINGMODE__DROPOFF";
            case BeadSorter.StateId.SORTINGMODE__PICKUP: return "SORTINGMODE__PICKUP";
            case BeadSorter.StateId.SORTINGMODE__SENSOR: return "SORTINGMODE__SENSOR";
            case BeadSorter.StateId.SORTINGMODE__START: return "SORTINGMODE__START";
            case BeadSorter.StateId.TRAININGMODE: return "TRAININGMODE";
            case BeadSorter.StateId.READEMPTYSLOT: return "READEMPTYSLOT";
            case BeadSorter.StateId.READEMPTYSLOT__DROPOFF: return "READEMPTYSLOT__DROPOFF";
            case BeadSorter.StateId.READEMPTYSLOT__SENSOR: return "READEMPTYSLOT__SENSOR";
            case BeadSorter.StateId.READJAMMEDSLOT: return "READJAMMEDSLOT";
            case BeadSorter.StateId.JAMMED: return "JAMMED";
            case BeadSorter.StateId.READJAMMEDSLOT__DROPOFF: return "READJAMMEDSLOT__DROPOFF";
            case BeadSorter.StateId.READJAMMEDSLOT__SENSOR: return "READJAMMEDSLOT__SENSOR";
            case BeadSorter.StateId.READSLOT: return "READSLOT";
            case BeadSorter.StateId.READSLOT__DROPOFF: return "READSLOT__DROPOFF";
            case BeadSorter.StateId.READSLOT__SENSOR: return "READSLOT__SENSOR";
            case BeadSorter.StateId.TRAININGMODE__PICKUP: return "TRAININGMODE__PICKUP";
            case BeadSorter.StateId.TRAININGMODE__START: return "TRAININGMODE__START";
            default: return "?";
        }
    }
    
    // Thread safe.
    static eventIdToString(id)
    {
        switch (id)
        {
            case BeadSorter.EventId.BUTTON0: return "BUTTON0";
            case BeadSorter.EventId.BUTTON1: return "BUTTON1";
            case BeadSorter.EventId.BUTTON2: return "BUTTON2";
            case BeadSorter.EventId.DO: return "DO";
            default: return "?";
        }
    }
}

</script>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        import svgPanZoom from 'https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/+esm' ;
        mermaid.initialize({ startOnLoad: false });
        await mermaid.run();

        // svg-pan-zoom doesn't like the mermaid viewbox
        document.querySelector('svg').removeAttribute('viewBox');
        document.querySelector('svg').setAttribute('width', '100%');
        document.querySelector('svg').setAttribute('height', '100%');
        document.querySelector('svg').style["max-width"] = '';

        // don't scale the arrow when we scale the transition edge
        document.querySelectorAll('g defs marker[id$=barbEnd]').forEach(marker => {
            marker.setAttribute('markerUnits', 'userSpaceOnUse');
        });

        // https://github.com/StateSmith/StateSmith/issues/294
        // rewrite $initial_state to a black circle
        document.querySelectorAll('g[data-id*="(InitialState)"]').forEach(g=> {
          g.innerHTML = '<circle transform="translate(0,10)" height="14" width="14" r="7" class="state - start"></circle>';
        })

        var panZoom = window.panZoom = svgPanZoom(document.querySelector('svg'), {
            zoomEnabled: true,
            controlIconsEnabled: true,
            fit: true,
            center: true
        });

        const diagramEventNamesArray = ['do', 'BUTTON0', 'BUTTON1', 'BUTTON2', ];

        const leftPane = document.querySelector(".main");
        const rightPane = document.querySelector(".sidebar");
        const gutter = document.querySelector(".gutter");

        function resizer(e) {          
          window.addEventListener('mousemove', mousemove);
          window.addEventListener('mouseup', mouseup);          
          let prevX = e.x;
          const rightPanel = rightPane.getBoundingClientRect();
                    
          function mousemove(e) {
            let newX = prevX - e.x;
            rightPane.style.width = rightPanel.width + newX + 'px';
            window.panZoom.resize();
            window.panZoom.fit();
            window.panZoom.center();
          }
          
          function mouseup() {
            window.removeEventListener('mousemove', mousemove);
            window.removeEventListener('mouseup', mouseup);
            
          }                  
        }

        gutter.addEventListener('mousedown', resizer);

        document.getElementById('timestamps').checked = document.querySelector('table.console').classList.contains('timestamps');
        document.getElementById('timestamps').addEventListener('change', function() {
          if(this.checked) {
            document.querySelector('table.console').classList.add('timestamps');
          } else {
            document.querySelector('table.console').classList.remove('timestamps');
          }
        });

        document.getElementById('dropbtn').addEventListener('click', myFunction);

        /* When the user clicks on the button, 
        toggle between hiding and showing the dropdown content */
        function myFunction() {
          document.getElementById('myDropdown').classList.toggle('show');
        }

        // Close the dropdown if the user clicks outside of it
        window.onclick = function(event) {
          if (!event.target.matches('.dropbtn')) {
            var dropdowns = document.getElementsByClassName('dropdown-content');
            var i;
            for (i = 0; i < dropdowns.length; i++) {
              var openDropdown = dropdowns[i];
              if (openDropdown.classList.contains('show')) {
                openDropdown.classList.remove('show');
              }
            }
          }
        }




        // Convert a date to a string in the format HH:MM:SS.sss
        function formatTime(date) {
            return date.getHours().toString().padStart(2, '0') + ':' +
                date.getMinutes().toString().padStart(2, '0') + ':' +
                date.getSeconds().toString().padStart(2, '0') + '.' +
                date.getMilliseconds().toString().padStart(3, '0');
        }

        // Add a row to the history table.
        function addHistoryRow(time, event, html = false) {
            var row = document.createElement('tr');
            var timeCell = document.createElement('td');
            timeCell.innerText = formatTime(time);
            timeCell.classList.add('timestamp');
            var eventCell = document.createElement('td');

            if(html) {
              eventCell.innerHTML = event;
            } else {
              eventCell.innerText = event;
            }

            row.appendChild(timeCell);
            row.appendChild(eventCell);
            document.querySelector('tbody').appendChild(row);
        }

        var sm = new BeadSorter();

        // prompt the user to evaluate guards manually
        sm.evaluateGuard = (vertexName, behaviorUml) => {
            return confirm(`Evaluate guard for\n${vertexName} behavior:\n${behaviorUml}.\n\nPress 'OK' to evaluate guard as true and 'Cancel' to evaluate it as false.`);
        }; 

        const highlightedEdges = new Set();
        function highlightEdge(edgeId) {
            var edge = document.getElementById(edgeId);
            if (edge) {
              edge.classList.add('active');
              highlightedEdges.add(edge);
            }
        }

        function clearHighlightedEdges() {
            for (const edge of highlightedEdges) {
              edge.classList.remove('active');
              const showOldTraversal = false;
              if (showOldTraversal) {
                  // shows that the edge was traversed. Optional, but kinda nice.
                  edge.style.stroke = 'green';
              }
            }
            highlightedEdges.clear();
        }

        // The simulator uses a tracer callback to perform operations such as 
        // state highlighting and logging. You do not need this functionality
        // when using BeadSorter.js in your own applications, although you may
        // choose to implement a tracer for debugging purposes.
        sm.tracer = {
            enterState: (mermaidName) => {
                var e = document.querySelector('g[data-id=' + mermaidName + ']');
                if(e) {
                  e.classList.add('active');
                  panOnScreen(e);
                }
                sm.tracer.log('âž¡ï¸ Entered ' + mermaidName);
            },
            exitState: (mermaidName) => {
                document.querySelector('g[data-id=' + mermaidName + ']')?.classList.remove('active');
            },
            edgeTransition: (edgeId) => {
                highlightEdge(edgeId);
            },
            log: (message, html=false) => {
                addHistoryRow(new Date(), message, html);
            }
        };

        // Wire up the buttons that dispatch events for the state machine.
        diagramEventNamesArray.forEach(diagramEventName => {
            var button = document.createElement('button');
            button.id = 'button_' + diagramEventName;
            button.innerText = diagramEventName;
            button.addEventListener('click', () => {
                clearHighlightedEdges();
                sm.tracer?.log('<span class="dispatched"><span class="trigger">' + diagramEventName + '</span> DISPATCHED</span>', true);
                const fsmEventName = diagramEventName.toUpperCase();
                sm.dispatchEvent(BeadSorter.EventId[fsmEventName]); 
            });
            document.getElementById('buttons').appendChild(button);
        });

        sm.tracer?.log('<span class="dispatched">START</span>', true);
        sm.start();


        function panOnScreen(element) {
          if(!element) return;

          var bounds = element.getBoundingClientRect();
          if(bounds.x<0 || bounds.y<0) {
              var x = Math.max(0, -bounds.x + 20);
              var y = Math.max(0, -bounds.y + 20);
              window.panZoom.panBy({x: x, y: y});
          }
          var panebounds = document.querySelector('svg').getBoundingClientRect();
          if(bounds.x>panebounds.width || bounds.y>panebounds.height) {
              var x = Math.min(0, panebounds.width - bounds.x - bounds.width - 20);
              var y = Math.min(0, panebounds.height - bounds.y - bounds.height - 20);
              window.panZoom.panBy({x: x, y: y});
          }
        }
    </script>


  </body>
</html>
