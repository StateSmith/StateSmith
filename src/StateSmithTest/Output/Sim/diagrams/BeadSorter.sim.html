<!-- 
  -- This file was generated by StateSmith.
  -- It serves as an example of how to use the generated state machine in a web page.
  -- It also serves as an interactive console that you can use to validate the
  -- state machine's behavior.
  --
  -- Using BeadSorter.js generally looks like:
  --   var sm = new BeadSorter();
  --   sm.start();
  --
  -- And then using sm.dispatchEvent() to dispatch events to the state machine.
  -->
<html>
  <head>
    <link rel='icon' type='image/png' href='https://statesmith.github.io/favicon.png'>
    <link rel='stylesheet' href='https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined'>
    <style>
      body {
        display: flex;
        flex-direction: row;
        margin: 0px;
      }

      .wrapper {
        height: 100vh;
        width: 100vw;
        display: flex;
      }

      .pane {
        padding: 1em;
        min-width: 200px;
      }

      .titlebar-icon {
        font-family: 'Material Symbols Outlined', sans-serif;
        font-size: 16px;
        color: #777;
        border-radius: 5px;
      }

      .gutter {
        width: 10px;
        height: 100%;
        background: #ccc;
        position: absolute;
        top: 0;
        left: 0;
        cursor: col-resize;
      }

      .main {
        flex: 1;
        overflow: auto;
        padding: 10px;
      }

      .sidebar {
        width: 300px;
        padding-top: 0px;
        position: relative;
        background-color: #f0f0f0;
        border-left: 1px solid #ccc;
        display: flex;
        flex-direction: column;
      }

      #buttons {
        display: flex;
        flex-direction: column;
      }

      .titlebar {
        background-color: #ddd;
        border-bottom: 1px solid #ccc;
        font-weight: bold;
        padding: 5px;
        display: flex;
      }

      .console {
        border-collapse: collapse;
        margin-top: 10px;
        width: 100%;
      }

      table.console td.timestamp {
        display: none;
      }

      table.console.timestamps td.timestamp {
        display: table-cell;
      }

      .console th {
        background-color: #f0f0f0;
        border-bottom: 1px solid #ccc;
        font-weight: normal;
        padding: 5px;
        text-align: left;
      }

      .console tbody {
        font-family: monospace;
      }

      .console tr {
        border-bottom: 1px solid #ccc;
      }

      .console td {
        padding: 5px;
      }
  
      .console td.timestamp {
        font-size: small;
      }

      .console td.emphasis {
        font-weight: bold;
      }

      .history {
        margin-top: 30px;       
        display: flex;
        overflow: auto;    
        flex-direction: column-reverse;
      }

      .console tr:last-child td {
        border-bottom: none;
      }

      button {
        margin: 5px;
      }

      .dropbtn {
        border: none;
        cursor: pointer;
      }

      .dropbtn:hover, .dropbtn:focus {
        background-color: #f1f1f1;
      }

      .dropdown {
        position: relative;
        display: inline-block;
        margin-left: auto;
      }

      .dropdown-content {
        display: none;
        position: absolute;
        right: 0;
        background-color: #f1f1f1;
        min-width: 160px;
        overflow: auto;
        box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
        z-index: 1;
      }

      .dropdown-content .dropdown-item {
        padding: 12px 16px;
        font-weight: normal;
      }

      .show {display: block;}
    </style>
  </head>

  <body>
    <div class="wrapper">
    <div class="pane main">
        <pre class="mermaid">
stateDiagram
classDef active fill:yellow,stroke-width:2px;
state Running {
        state TrainingMode {
                state ReadEmptySlot {
                        state "$initial_state" as ReadEmptySlot.(InitialState)
                        Dropoff
                        Dropoff : Dropoff
                        Dropoff : enter / #123; picker.moveToAndShimmy(DEG_DROPOFF)#59; #125;
                        Sensor
                        Sensor : Sensor
                        Sensor : enter / #123; picker.moveTo(DEG_SENSOR)#59;\nempties++#59;\nsorter.readColor()#59; #125;
                        state "$HC" as ReadEmptySlot.(HistoryContinue)
                }
                state ReadJammedSlot {
                        state "$initial_state" as ReadJammedSlot.(InitialState)
                        Dropoff
                        Dropoff : Dropoff
                        Dropoff : enter / #123; picker.moveToAndShimmy(DEG_DROPOFF)#59; #125;
                        Jammed
                        Jammed : Jammed
                        Jammed : enter / #123; picker.moveTo(DEG_JAMMED_READ)#59; #125;
                        Sensor
                        Sensor : Sensor
                        Sensor : enter / #123; jammies++#59;\nsorter.readColor()#59; #125;
                        state "$HC" as ReadJammedSlot.(HistoryContinue)
                }
                state ReadSlot {
                        state "$initial_state" as ReadSlot.(InitialState)
                        Dropoff
                        Dropoff : Dropoff
                        Dropoff : enter / #123; picker.moveToAndShimmy(DEG_DROPOFF)#59; #125;
                        Pickup
                        Pickup : Pickup
                        Pickup : enter / #123; picker.moveTo(DEG_PICKUP)#59; #125;
                        Sensor
                        Sensor : Sensor
                        Sensor : enter / #123; picker.shimmyAndMoveTo(DEG_SENSOR)#59;\nsorter.readColor()#59;\nsorter.runTraining()#59;\nsorter.shimmyAndMoveTo(DEFAULT_BIN)#59; #125;
                        state "$HC" as ReadSlot.(HistoryContinue)
                }
                Start
                Start : Start
                Start : enter / #123; modeDisplay.print("TRAINING")#59; #125;
                state "$initial_state" as TrainingMode.(InitialState)
                state "$HC" as TrainingMode.(HistoryContinue)
        }
        state SortingMode {
                Dropoff
                Dropoff : Dropoff
                Dropoff : enter / #123; picker.moveToAndShimmy(DEG_DROPOFF)#59; #125;
                Pickup
                Pickup : Pickup
                Pickup : enter / #123; picker.moveTo(DEG_PICKUP)#59; #125;
                state "$initial_state" as SortingMode.(InitialState)
                Start
                Start : Start
                Start : enter / #123; modeDisplay.clear()#59; #125;
                state "$HC" as SortingMode.(HistoryContinue)
                Sensor
                Sensor : Sensor
                Sensor : enter / #123; picker.shimmyAndMoveTo(DEG_SENSOR)#59;\nsorter.shimmyAndMoveTo(min(sorter.readColor(), DEFAULT_BIN))#59; #125;
        }
        state SetupCheck {
                state "$initial_state" as SetupCheck.(InitialState)
                Tour
                Tour : Tour
                Tour : enter / #123; tourBin = min(tourBin+1, DEFAULT_BIN)#59;\nsorter.moveTo(tourBin)#59; #125;
                Start
                Start : Start
                Start : enter / #123; modeDisplay.print("SETUP CHECK")#59;\nsorter.moveTo(0)#59;\npicker.moveTo(DEG_DROPOFF)#59;\npicker.moveTo(DEG_PICKUP)#59;\nt1Restart()#59; #125;
                state "$HC" as SetupCheck.(HistoryContinue)
                state AdjustServoOffsets {
                        DECREASE
                        DECREASE : DECREASE
                        DECREASE : enter / #123; picker.adjustOffset(-2)#59; #125;
                        INCREASE
                        INCREASE : INCREASE
                        INCREASE : enter / #123; picker.adjustOffset(2)#59; #125;
                        Wait
                        Wait : Wait
                        Wait : enter / #123; picker.displayOffset()#59; #125;
                        state "$initial_state" as AdjustServoOffsets.(InitialState)
                }
        }
        state "$initial_state" as Running.(InitialState)
        state "$H" as Running.(History)
}
Paused
Paused : Paused
state "$initial_state" as ROOT.(InitialState)
Running --> Paused : BUTTON0
ReadEmptySlot.(InitialState) --> Dropoff
Dropoff --> Sensor
Sensor --> Dropoff
Sensor --> ReadJammedSlot : 1. [empties>=NUM_EMPTY_READS]
ReadJammedSlot.(InitialState) --> Jammed
Dropoff --> Jammed
Dropoff --> ReadSlot : 1. [jammies>=NUM_JAMMED_READS]
Jammed --> Sensor
Sensor --> Dropoff
ReadSlot.(InitialState) --> Pickup
Dropoff --> Pickup
Dropoff --> SortingMode : 1. [sorter.isTrainingDone()]
Pickup --> Sensor
Sensor --> Dropoff
Start --> ReadEmptySlot
TrainingMode.(InitialState) --> Start
Dropoff --> Pickup
Pickup --> Sensor
SortingMode.(InitialState) --> Start
Start --> Pickup
Sensor --> Dropoff
SetupCheck.(InitialState) --> Start
Tour --> TrainingMode : 1. [tourBin>=DEFAULT_BIN]
Tour --> Tour : [true]
Start --> Tour : [t1After(3s)]
Start --> AdjustServoOffsets : BUTTON2
AdjustServoOffsets --> Start : BUTTON2
DECREASE --> Wait
INCREASE --> Wait
Wait --> DECREASE : BUTTON1
Wait --> INCREASE : BUTTON2
AdjustServoOffsets.(InitialState) --> Wait
Running.(InitialState) --> Running.(History)
Running.(History) --> SetupCheck
Paused --> Running : BUTTON0
ROOT.(InitialState) --> Running


        </pre>
    </div>

    <div class="pane sidebar">
        <div id="buttons">
            <div class="titlebar">Events            
              <div class='dropdown'>
                <span id='dropbtn' class='titlebar-icon dropbtn'>settings</span>
                <div id='myDropdown' class='dropdown-content'>
                  <div class='dropdown-item'>
                    <input type='checkbox' id='timestamps' name='timestamps' value='Timestamps'>
                    <label for=timestamps'>Timestamps</label>
                  </div>
                </div>
              </div>            
          </div>
        </div>

        <div class="history">
          <table class="console">
            <tbody>
            </tbody>
          </table>
        </div>

        <div class="gutter"></div>
    </div>
    </div>

<script>
// Autogenerated with StateSmith.
// Algorithm: Balanced1. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

// Generated state machine
class BeadSorter
{
// Null by default.
// May be overridden to override guard evaluation (eg. in a simulator)
evaluateGuard = null;
    static EventId = 
    {
        DO : 0, // The `do` event is special. State event handlers do not consume this event (ancestors all get it too) unless a transition occurs.
        BUTTON0 : 1,
        BUTTON1 : 2,
        BUTTON2 : 3,
    }
    static { Object.freeze(this.EventId); }
    
    static EventIdCount = 4;
    static { Object.freeze(this.EventIdCount); }
    
    static StateId = 
    {
        ROOT : 0,
        PAUSED : 1,
        RUNNING : 2,
        SETUPCHECK : 3,
        ADJUSTSERVOOFFSETS : 4,
        DECREASE : 5,
        INCREASE : 6,
        WAIT : 7,
        SETUPCHECK__START : 8,
        TOUR : 9,
        SORTINGMODE : 10,
        SORTINGMODE__DROPOFF : 11,
        SORTINGMODE__PICKUP : 12,
        SORTINGMODE__SENSOR : 13,
        SORTINGMODE__START : 14,
        TRAININGMODE : 15,
        READEMPTYSLOT : 16,
        READEMPTYSLOT__DROPOFF : 17,
        READEMPTYSLOT__SENSOR : 18,
        READJAMMEDSLOT : 19,
        JAMMED : 20,
        READJAMMEDSLOT__DROPOFF : 21,
        READJAMMEDSLOT__SENSOR : 22,
        READSLOT : 23,
        READSLOT__DROPOFF : 24,
        READSLOT__SENSOR : 25,
        TRAININGMODE__PICKUP : 26,
        TRAININGMODE__START : 27,
    }
    static { Object.freeze(this.StateId); }
    
    static StateIdCount = 28;
    static { Object.freeze(this.StateIdCount); }
    
    static Running_HistoryId = 
    {
        SETUPCHECK : 0, // default transition
        TRAININGMODE : 1,
        SORTINGMODE : 2,
        READEMPTYSLOT : 3,
        READJAMMEDSLOT : 4,
        READSLOT : 5,
        TRAININGMODE__START : 6,
        READEMPTYSLOT__DROPOFF : 7,
        READEMPTYSLOT__SENSOR : 8,
        READJAMMEDSLOT__DROPOFF : 9,
        JAMMED : 10,
        READJAMMEDSLOT__SENSOR : 11,
        READSLOT__DROPOFF : 12,
        TRAININGMODE__PICKUP : 13,
        READSLOT__SENSOR : 14,
        SORTINGMODE__DROPOFF : 15,
        SORTINGMODE__PICKUP : 16,
        SORTINGMODE__START : 17,
        SORTINGMODE__SENSOR : 18,
        TOUR : 19,
        SETUPCHECK__START : 20,
        ADJUSTSERVOOFFSETS : 21,
    }
    static { Object.freeze(this.Running_HistoryId); }
    
    // Used internally by state machine. Feel free to inspect, but don't modify.
    stateId;
    
    // Used internally by state machine. Don't modify.
    #ancestorEventHandler;
    
    // Used internally by state machine. Don't modify.
    #currentEventHandlers = Array(BeadSorter.EventIdCount).fill(undefined);
    
    // Used internally by state machine. Don't modify.
    #currentStateExitHandler;
    
    // Variables. Can be used for inputs, outputs, user variables...
    vars = {
        Running_history: undefined,
    };
    
    // Starts the state machine. Must be called before dispatching events. Not thread safe.
    start()
    {
        this.#ROOT_enter();
        // ROOT behavior
        // uml: TransitionTo(ROOT.<InitialState>)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
            // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.
            
            // ROOT.<InitialState> behavior
            // uml: / { this.tracer.edgeTransition("edge36"); } TransitionTo(Running)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer.edgeTransition("edge36");`.
                this.tracer.edgeTransition("edge36");
                
                // Step 3: Enter/move towards transition target `Running`.
                this.#RUNNING_enter();
                
                // Finish transition by calling pseudo state transition function.
                this.#Running_InitialState_transition();
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for ROOT.<InitialState>
        } // end of behavior for ROOT
    }
    
    // Dispatches an event to the state machine. Not thread safe.
    dispatchEvent(eventId)
    {
        let behaviorFunc = this.#currentEventHandlers[eventId];
        
        while (behaviorFunc != null)
        {
            this.#ancestorEventHandler = null;
            behaviorFunc.call(this);
            behaviorFunc = this.#ancestorEventHandler;
        }
    }
    
    // This function is used when StateSmith doesn't know what the active leaf state is at
    // compile time due to sub states or when multiple states need to be exited.
    #exitUpToStateHandler(desiredStateExitHandler)
    {
        while (this.#currentStateExitHandler != desiredStateExitHandler)
        {
            this.#currentStateExitHandler.call(this);
        }
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ROOT
    ////////////////////////////////////////////////////////////////////////////////
    
    #ROOT_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#ROOT_exit;
    }
    
    #ROOT_exit()
    {
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state PAUSED
    ////////////////////////////////////////////////////////////////////////////////
    
    #PAUSED_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#PAUSED_exit;
        this.#currentEventHandlers[BeadSorter.EventId.BUTTON0] = this.#PAUSED_button0;
        
        // Paused behavior
        // uml: enter / { this.tracer?.enterState(BeadSorter.StateId.PAUSED); }
        {
            // Step 1: execute action `this.tracer?.enterState(BeadSorter.StateId.PAUSED);`
            this.tracer?.enterState(BeadSorter.StateId.PAUSED);
        } // end of behavior for Paused
    }
    
    #PAUSED_exit()
    {
        // Paused behavior
        // uml: exit / { this.tracer?.exitState(BeadSorter.StateId.PAUSED); }
        {
            // Step 1: execute action `this.tracer?.exitState(BeadSorter.StateId.PAUSED);`
            this.tracer?.exitState(BeadSorter.StateId.PAUSED);
        } // end of behavior for Paused
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#ROOT_exit;
        this.#currentEventHandlers[BeadSorter.EventId.BUTTON0] = null;  // no ancestor listens to this event
    }
    
    #PAUSED_button0()
    {
        // No ancestor state handles `button0` event.
        
        // Paused behavior
        // uml: BUTTON0 / { this.tracer.edgeTransition("edge35"); } TransitionTo(Running)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#PAUSED_exit();
            
            // Step 2: Transition action: `this.tracer.edgeTransition("edge35");`.
            this.tracer.edgeTransition("edge35");
            
            // Step 3: Enter/move towards transition target `Running`.
            this.#RUNNING_enter();
            
            // Finish transition by calling pseudo state transition function.
            this.#Running_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for Paused
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state RUNNING
    ////////////////////////////////////////////////////////////////////////////////
    
    #RUNNING_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#RUNNING_exit;
        this.#currentEventHandlers[BeadSorter.EventId.BUTTON0] = this.#RUNNING_button0;
        
        // Running behavior
        // uml: enter / { this.tracer?.enterState(BeadSorter.StateId.RUNNING); }
        {
            // Step 1: execute action `this.tracer?.enterState(BeadSorter.StateId.RUNNING);`
            this.tracer?.enterState(BeadSorter.StateId.RUNNING);
        } // end of behavior for Running
    }
    
    #RUNNING_exit()
    {
        // Running behavior
        // uml: exit / { this.tracer?.exitState(BeadSorter.StateId.RUNNING); }
        {
            // Step 1: execute action `this.tracer?.exitState(BeadSorter.StateId.RUNNING);`
            this.tracer?.exitState(BeadSorter.StateId.RUNNING);
        } // end of behavior for Running
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#ROOT_exit;
        this.#currentEventHandlers[BeadSorter.EventId.BUTTON0] = null;  // no ancestor listens to this event
    }
    
    #RUNNING_button0()
    {
        // No ancestor state handles `button0` event.
        
        // Running behavior
        // uml: BUTTON0 / { this.tracer.edgeTransition("edge0"); } TransitionTo(Paused)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(this.#ROOT_exit);
            
            // Step 2: Transition action: `this.tracer.edgeTransition("edge0");`.
            this.tracer.edgeTransition("edge0");
            
            // Step 3: Enter/move towards transition target `Paused`.
            this.#PAUSED_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = BeadSorter.StateId.PAUSED;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for Running
    }
    
    #Running_InitialState_transition()
    {
        // Running.<InitialState> behavior
        // uml: / { this.tracer.edgeTransition("edge33"); } TransitionTo(Running.<History>)
        {
            // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `this.tracer.edgeTransition("edge33");`.
            this.tracer.edgeTransition("edge33");
            
            // Step 3: Enter/move towards transition target `Running.<History>`.
            // Running.<History> is a pseudo state and cannot have an `enter` trigger.
            
            // Running.<History> behavior
            // uml: [this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.TRAININGMODE)") || $gil(this.vars.Running_history == Running_HistoryId.TRAININGMODE)] TransitionTo(TrainingMode)
            if (this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.TRAININGMODE)") || this.vars.Running_history == BeadSorter.Running_HistoryId.TRAININGMODE)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `TrainingMode`.
                this.#TRAININGMODE_enter();
                
                // Finish transition by calling pseudo state transition function.
                this.#TrainingMode_InitialState_transition();
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.SORTINGMODE)") || $gil(this.vars.Running_history == Running_HistoryId.SORTINGMODE)] TransitionTo(SortingMode)
            if (this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.SORTINGMODE)") || this.vars.Running_history == BeadSorter.Running_HistoryId.SORTINGMODE)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `SortingMode`.
                this.#SORTINGMODE_enter();
                
                // Finish transition by calling pseudo state transition function.
                this.#SortingMode_InitialState_transition();
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.READEMPTYSLOT)") || $gil(this.vars.Running_history == Running_HistoryId.READEMPTYSLOT)] TransitionTo(ReadEmptySlot)
            if (this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.READEMPTYSLOT)") || this.vars.Running_history == BeadSorter.Running_HistoryId.READEMPTYSLOT)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `ReadEmptySlot`.
                this.#TRAININGMODE_enter();
                this.#READEMPTYSLOT_enter();
                
                // Finish transition by calling pseudo state transition function.
                this.#ReadEmptySlot_InitialState_transition();
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.READJAMMEDSLOT)") || $gil(this.vars.Running_history == Running_HistoryId.READJAMMEDSLOT)] TransitionTo(ReadJammedSlot)
            if (this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.READJAMMEDSLOT)") || this.vars.Running_history == BeadSorter.Running_HistoryId.READJAMMEDSLOT)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `ReadJammedSlot`.
                this.#TRAININGMODE_enter();
                this.#READJAMMEDSLOT_enter();
                
                // Finish transition by calling pseudo state transition function.
                this.#ReadJammedSlot_InitialState_transition();
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.READSLOT)") || $gil(this.vars.Running_history == Running_HistoryId.READSLOT)] TransitionTo(ReadSlot)
            if (this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.READSLOT)") || this.vars.Running_history == BeadSorter.Running_HistoryId.READSLOT)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `ReadSlot`.
                this.#TRAININGMODE_enter();
                this.#READSLOT_enter();
                
                // Finish transition by calling pseudo state transition function.
                this.#ReadSlot_InitialState_transition();
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.TRAININGMODE__START)") || $gil(this.vars.Running_history == Running_HistoryId.TRAININGMODE__START)] TransitionTo(TrainingMode__Start)
            if (this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.TRAININGMODE__START)") || this.vars.Running_history == BeadSorter.Running_HistoryId.TRAININGMODE__START)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `TrainingMode__Start`.
                this.#TRAININGMODE_enter();
                this.#TRAININGMODE__START_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                this.stateId = BeadSorter.StateId.TRAININGMODE__START;
                this.#ancestorEventHandler = null;
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.READEMPTYSLOT__DROPOFF)") || $gil(this.vars.Running_history == Running_HistoryId.READEMPTYSLOT__DROPOFF)] TransitionTo(ReadEmptySlot__Dropoff)
            if (this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.READEMPTYSLOT__DROPOFF)") || this.vars.Running_history == BeadSorter.Running_HistoryId.READEMPTYSLOT__DROPOFF)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `ReadEmptySlot__Dropoff`.
                this.#TRAININGMODE_enter();
                this.#READEMPTYSLOT_enter();
                this.#READEMPTYSLOT__DROPOFF_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                this.stateId = BeadSorter.StateId.READEMPTYSLOT__DROPOFF;
                this.#ancestorEventHandler = null;
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.READEMPTYSLOT__SENSOR)") || $gil(this.vars.Running_history == Running_HistoryId.READEMPTYSLOT__SENSOR)] TransitionTo(ReadEmptySlot__Sensor)
            if (this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.READEMPTYSLOT__SENSOR)") || this.vars.Running_history == BeadSorter.Running_HistoryId.READEMPTYSLOT__SENSOR)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `ReadEmptySlot__Sensor`.
                this.#TRAININGMODE_enter();
                this.#READEMPTYSLOT_enter();
                this.#READEMPTYSLOT__SENSOR_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                this.stateId = BeadSorter.StateId.READEMPTYSLOT__SENSOR;
                this.#ancestorEventHandler = null;
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.READJAMMEDSLOT__DROPOFF)") || $gil(this.vars.Running_history == Running_HistoryId.READJAMMEDSLOT__DROPOFF)] TransitionTo(ReadJammedSlot__Dropoff)
            if (this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.READJAMMEDSLOT__DROPOFF)") || this.vars.Running_history == BeadSorter.Running_HistoryId.READJAMMEDSLOT__DROPOFF)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `ReadJammedSlot__Dropoff`.
                this.#TRAININGMODE_enter();
                this.#READJAMMEDSLOT_enter();
                this.#READJAMMEDSLOT__DROPOFF_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                this.stateId = BeadSorter.StateId.READJAMMEDSLOT__DROPOFF;
                this.#ancestorEventHandler = null;
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.JAMMED)") || $gil(this.vars.Running_history == Running_HistoryId.JAMMED)] TransitionTo(Jammed)
            if (this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.JAMMED)") || this.vars.Running_history == BeadSorter.Running_HistoryId.JAMMED)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `Jammed`.
                this.#TRAININGMODE_enter();
                this.#READJAMMEDSLOT_enter();
                this.#JAMMED_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                this.stateId = BeadSorter.StateId.JAMMED;
                this.#ancestorEventHandler = null;
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.READJAMMEDSLOT__SENSOR)") || $gil(this.vars.Running_history == Running_HistoryId.READJAMMEDSLOT__SENSOR)] TransitionTo(ReadJammedSlot__Sensor)
            if (this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.READJAMMEDSLOT__SENSOR)") || this.vars.Running_history == BeadSorter.Running_HistoryId.READJAMMEDSLOT__SENSOR)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `ReadJammedSlot__Sensor`.
                this.#TRAININGMODE_enter();
                this.#READJAMMEDSLOT_enter();
                this.#READJAMMEDSLOT__SENSOR_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                this.stateId = BeadSorter.StateId.READJAMMEDSLOT__SENSOR;
                this.#ancestorEventHandler = null;
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.READSLOT__DROPOFF)") || $gil(this.vars.Running_history == Running_HistoryId.READSLOT__DROPOFF)] TransitionTo(ReadSlot__Dropoff)
            if (this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.READSLOT__DROPOFF)") || this.vars.Running_history == BeadSorter.Running_HistoryId.READSLOT__DROPOFF)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `ReadSlot__Dropoff`.
                this.#TRAININGMODE_enter();
                this.#READSLOT_enter();
                this.#READSLOT__DROPOFF_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                this.stateId = BeadSorter.StateId.READSLOT__DROPOFF;
                this.#ancestorEventHandler = null;
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.TRAININGMODE__PICKUP)") || $gil(this.vars.Running_history == Running_HistoryId.TRAININGMODE__PICKUP)] TransitionTo(TrainingMode__Pickup)
            if (this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.TRAININGMODE__PICKUP)") || this.vars.Running_history == BeadSorter.Running_HistoryId.TRAININGMODE__PICKUP)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `TrainingMode__Pickup`.
                this.#TRAININGMODE_enter();
                this.#READSLOT_enter();
                this.#TRAININGMODE__PICKUP_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                this.stateId = BeadSorter.StateId.TRAININGMODE__PICKUP;
                this.#ancestorEventHandler = null;
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.READSLOT__SENSOR)") || $gil(this.vars.Running_history == Running_HistoryId.READSLOT__SENSOR)] TransitionTo(ReadSlot__Sensor)
            if (this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.READSLOT__SENSOR)") || this.vars.Running_history == BeadSorter.Running_HistoryId.READSLOT__SENSOR)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `ReadSlot__Sensor`.
                this.#TRAININGMODE_enter();
                this.#READSLOT_enter();
                this.#READSLOT__SENSOR_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                this.stateId = BeadSorter.StateId.READSLOT__SENSOR;
                this.#ancestorEventHandler = null;
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.SORTINGMODE__DROPOFF)") || $gil(this.vars.Running_history == Running_HistoryId.SORTINGMODE__DROPOFF)] TransitionTo(SortingMode__Dropoff)
            if (this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.SORTINGMODE__DROPOFF)") || this.vars.Running_history == BeadSorter.Running_HistoryId.SORTINGMODE__DROPOFF)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `SortingMode__Dropoff`.
                this.#SORTINGMODE_enter();
                this.#SORTINGMODE__DROPOFF_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                this.stateId = BeadSorter.StateId.SORTINGMODE__DROPOFF;
                this.#ancestorEventHandler = null;
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.SORTINGMODE__PICKUP)") || $gil(this.vars.Running_history == Running_HistoryId.SORTINGMODE__PICKUP)] TransitionTo(SortingMode__Pickup)
            if (this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.SORTINGMODE__PICKUP)") || this.vars.Running_history == BeadSorter.Running_HistoryId.SORTINGMODE__PICKUP)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `SortingMode__Pickup`.
                this.#SORTINGMODE_enter();
                this.#SORTINGMODE__PICKUP_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                this.stateId = BeadSorter.StateId.SORTINGMODE__PICKUP;
                this.#ancestorEventHandler = null;
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.SORTINGMODE__START)") || $gil(this.vars.Running_history == Running_HistoryId.SORTINGMODE__START)] TransitionTo(SortingMode__Start)
            if (this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.SORTINGMODE__START)") || this.vars.Running_history == BeadSorter.Running_HistoryId.SORTINGMODE__START)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `SortingMode__Start`.
                this.#SORTINGMODE_enter();
                this.#SORTINGMODE__START_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                this.stateId = BeadSorter.StateId.SORTINGMODE__START;
                this.#ancestorEventHandler = null;
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.SORTINGMODE__SENSOR)") || $gil(this.vars.Running_history == Running_HistoryId.SORTINGMODE__SENSOR)] TransitionTo(SortingMode__Sensor)
            if (this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.SORTINGMODE__SENSOR)") || this.vars.Running_history == BeadSorter.Running_HistoryId.SORTINGMODE__SENSOR)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `SortingMode__Sensor`.
                this.#SORTINGMODE_enter();
                this.#SORTINGMODE__SENSOR_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                this.stateId = BeadSorter.StateId.SORTINGMODE__SENSOR;
                this.#ancestorEventHandler = null;
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.TOUR)") || $gil(this.vars.Running_history == Running_HistoryId.TOUR)] TransitionTo(Tour)
            if (this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.TOUR)") || this.vars.Running_history == BeadSorter.Running_HistoryId.TOUR)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `Tour`.
                this.#SETUPCHECK_enter();
                this.#TOUR_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                this.stateId = BeadSorter.StateId.TOUR;
                this.#ancestorEventHandler = null;
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.SETUPCHECK__START)") || $gil(this.vars.Running_history == Running_HistoryId.SETUPCHECK__START)] TransitionTo(SetupCheck__Start)
            if (this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.SETUPCHECK__START)") || this.vars.Running_history == BeadSorter.Running_HistoryId.SETUPCHECK__START)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `SetupCheck__Start`.
                this.#SETUPCHECK_enter();
                this.#SETUPCHECK__START_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                this.stateId = BeadSorter.StateId.SETUPCHECK__START;
                this.#ancestorEventHandler = null;
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.ADJUSTSERVOOFFSETS)") || $gil(this.vars.Running_history == Running_HistoryId.ADJUSTSERVOOFFSETS)] TransitionTo(AdjustServoOffsets)
            if (this.tracer.log("History state evaluating guard: " + "$gil(this.vars.Running_history == Running_HistoryId.ADJUSTSERVOOFFSETS)") || this.vars.Running_history == BeadSorter.Running_HistoryId.ADJUSTSERVOOFFSETS)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `AdjustServoOffsets`.
                this.#SETUPCHECK_enter();
                this.#ADJUSTSERVOOFFSETS_enter();
                
                // Finish transition by calling pseudo state transition function.
                this.#AdjustServoOffsets_InitialState_transition();
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: else / { this.tracer.log("History state taking default transition.");this.tracer.edgeTransition("edge34"); } TransitionTo(SetupCheck)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer.log("History state taking default transition.");this.tracer.edgeTransition("edge34");`.
                this.tracer.log("History state taking default transition.");this.tracer.edgeTransition("edge34");
                
                // Step 3: Enter/move towards transition target `SetupCheck`.
                this.#SETUPCHECK_enter();
                
                // SetupCheck.<InitialState> behavior
                // uml: / { this.tracer.edgeTransition("edge22"); } TransitionTo(SetupCheck__Start)
                {
                    // Step 1: Exit states until we reach `SetupCheck` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                    
                    // Step 2: Transition action: `this.tracer.edgeTransition("edge22");`.
                    this.tracer.edgeTransition("edge22");
                    
                    // Step 3: Enter/move towards transition target `SetupCheck__Start`.
                    this.#SETUPCHECK__START_enter();
                    
                    // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                    this.stateId = BeadSorter.StateId.SETUPCHECK__START;
                    this.#ancestorEventHandler = null;
                    return;
                } // end of behavior for SetupCheck.<InitialState>
            } // end of behavior for Running.<History>
        } // end of behavior for Running.<InitialState>
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state SETUPCHECK
    ////////////////////////////////////////////////////////////////////////////////
    
    #SETUPCHECK_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#SETUPCHECK_exit;
        
        // SetupCheck behavior
        // uml: enter / { this.tracer?.enterState(BeadSorter.StateId.SETUPCHECK); }
        {
            // Step 1: execute action `this.tracer?.enterState(BeadSorter.StateId.SETUPCHECK);`
            this.tracer?.enterState(BeadSorter.StateId.SETUPCHECK);
        } // end of behavior for SetupCheck
        
        // SetupCheck behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.SETUPCHECK;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.SETUPCHECK;)"); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.SETUPCHECK;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.SETUPCHECK;)");`
            this.vars.Running_history = BeadSorter.Running_HistoryId.SETUPCHECK;this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.SETUPCHECK;)");
        } // end of behavior for SetupCheck
    }
    
    #SETUPCHECK_exit()
    {
        // SetupCheck behavior
        // uml: exit / { this.tracer?.exitState(BeadSorter.StateId.SETUPCHECK); }
        {
            // Step 1: execute action `this.tracer?.exitState(BeadSorter.StateId.SETUPCHECK);`
            this.tracer?.exitState(BeadSorter.StateId.SETUPCHECK);
        } // end of behavior for SetupCheck
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#RUNNING_exit;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ADJUSTSERVOOFFSETS
    ////////////////////////////////////////////////////////////////////////////////
    
    #ADJUSTSERVOOFFSETS_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#ADJUSTSERVOOFFSETS_exit;
        this.#currentEventHandlers[BeadSorter.EventId.BUTTON2] = this.#ADJUSTSERVOOFFSETS_button2;
        
        // AdjustServoOffsets behavior
        // uml: enter / { this.tracer?.enterState(BeadSorter.StateId.ADJUSTSERVOOFFSETS); }
        {
            // Step 1: execute action `this.tracer?.enterState(BeadSorter.StateId.ADJUSTSERVOOFFSETS);`
            this.tracer?.enterState(BeadSorter.StateId.ADJUSTSERVOOFFSETS);
        } // end of behavior for AdjustServoOffsets
        
        // AdjustServoOffsets behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.ADJUSTSERVOOFFSETS;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.ADJUSTSERVOOFFSETS;)"); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.ADJUSTSERVOOFFSETS;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.ADJUSTSERVOOFFSETS;)");`
            this.vars.Running_history = BeadSorter.Running_HistoryId.ADJUSTSERVOOFFSETS;this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.ADJUSTSERVOOFFSETS;)");
        } // end of behavior for AdjustServoOffsets
    }
    
    #ADJUSTSERVOOFFSETS_exit()
    {
        // AdjustServoOffsets behavior
        // uml: exit / { this.tracer?.exitState(BeadSorter.StateId.ADJUSTSERVOOFFSETS); }
        {
            // Step 1: execute action `this.tracer?.exitState(BeadSorter.StateId.ADJUSTSERVOOFFSETS);`
            this.tracer?.exitState(BeadSorter.StateId.ADJUSTSERVOOFFSETS);
        } // end of behavior for AdjustServoOffsets
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#SETUPCHECK_exit;
        this.#currentEventHandlers[BeadSorter.EventId.BUTTON2] = null;  // no ancestor listens to this event
    }
    
    #ADJUSTSERVOOFFSETS_button2()
    {
        // No ancestor state handles `button2` event.
        
        // AdjustServoOffsets behavior
        // uml: BUTTON2 / { this.tracer.edgeTransition("edge27"); } TransitionTo(SetupCheck__Start)
        {
            // Step 1: Exit states until we reach `SetupCheck` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(this.#SETUPCHECK_exit);
            
            // Step 2: Transition action: `this.tracer.edgeTransition("edge27");`.
            this.tracer.edgeTransition("edge27");
            
            // Step 3: Enter/move towards transition target `SetupCheck__Start`.
            this.#SETUPCHECK__START_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = BeadSorter.StateId.SETUPCHECK__START;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for AdjustServoOffsets
    }
    
    #AdjustServoOffsets_InitialState_transition()
    {
        // AdjustServoOffsets.<InitialState> behavior
        // uml: / { this.tracer.edgeTransition("edge32"); } TransitionTo(Wait)
        {
            // Step 1: Exit states until we reach `AdjustServoOffsets` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `this.tracer.edgeTransition("edge32");`.
            this.tracer.edgeTransition("edge32");
            
            // Step 3: Enter/move towards transition target `Wait`.
            this.#WAIT_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = BeadSorter.StateId.WAIT;
            this.#ancestorEventHandler = null;
            return;
        } // end of behavior for AdjustServoOffsets.<InitialState>
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state DECREASE
    ////////////////////////////////////////////////////////////////////////////////
    
    #DECREASE_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#DECREASE_exit;
        this.#currentEventHandlers[BeadSorter.EventId.DO] = this.#DECREASE_do;
        
        // DECREASE behavior
        // uml: enter / { this.tracer?.enterState(BeadSorter.StateId.DECREASE); }
        {
            // Step 1: execute action `this.tracer?.enterState(BeadSorter.StateId.DECREASE);`
            this.tracer?.enterState(BeadSorter.StateId.DECREASE);
        } // end of behavior for DECREASE
        
        // DECREASE behavior
        // uml: enter / { this.tracer.log("FSM would execute action: " + "picker.adjustOffset(-2);"); }
        {
            // Step 1: execute action `this.tracer.log("FSM would execute action: " + "picker.adjustOffset(-2);");`
            this.tracer.log("FSM would execute action: " + "picker.adjustOffset(-2);");
        } // end of behavior for DECREASE
    }
    
    #DECREASE_exit()
    {
        // DECREASE behavior
        // uml: exit / { this.tracer?.exitState(BeadSorter.StateId.DECREASE); }
        {
            // Step 1: execute action `this.tracer?.exitState(BeadSorter.StateId.DECREASE);`
            this.tracer?.exitState(BeadSorter.StateId.DECREASE);
        } // end of behavior for DECREASE
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#ADJUSTSERVOOFFSETS_exit;
        this.#currentEventHandlers[BeadSorter.EventId.DO] = null;  // no ancestor listens to this event
    }
    
    #DECREASE_do()
    {
        // No ancestor state handles `do` event.
        
        // DECREASE behavior
        // uml: do / { this.tracer.edgeTransition("edge28"); } TransitionTo(Wait)
        {
            // Step 1: Exit states until we reach `AdjustServoOffsets` state (Least Common Ancestor for transition).
            this.#DECREASE_exit();
            
            // Step 2: Transition action: `this.tracer.edgeTransition("edge28");`.
            this.tracer.edgeTransition("edge28");
            
            // Step 3: Enter/move towards transition target `Wait`.
            this.#WAIT_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = BeadSorter.StateId.WAIT;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for DECREASE
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state INCREASE
    ////////////////////////////////////////////////////////////////////////////////
    
    #INCREASE_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#INCREASE_exit;
        this.#currentEventHandlers[BeadSorter.EventId.DO] = this.#INCREASE_do;
        
        // INCREASE behavior
        // uml: enter / { this.tracer?.enterState(BeadSorter.StateId.INCREASE); }
        {
            // Step 1: execute action `this.tracer?.enterState(BeadSorter.StateId.INCREASE);`
            this.tracer?.enterState(BeadSorter.StateId.INCREASE);
        } // end of behavior for INCREASE
        
        // INCREASE behavior
        // uml: enter / { this.tracer.log("FSM would execute action: " + "picker.adjustOffset(2);"); }
        {
            // Step 1: execute action `this.tracer.log("FSM would execute action: " + "picker.adjustOffset(2);");`
            this.tracer.log("FSM would execute action: " + "picker.adjustOffset(2);");
        } // end of behavior for INCREASE
    }
    
    #INCREASE_exit()
    {
        // INCREASE behavior
        // uml: exit / { this.tracer?.exitState(BeadSorter.StateId.INCREASE); }
        {
            // Step 1: execute action `this.tracer?.exitState(BeadSorter.StateId.INCREASE);`
            this.tracer?.exitState(BeadSorter.StateId.INCREASE);
        } // end of behavior for INCREASE
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#ADJUSTSERVOOFFSETS_exit;
        this.#currentEventHandlers[BeadSorter.EventId.DO] = null;  // no ancestor listens to this event
    }
    
    #INCREASE_do()
    {
        // No ancestor state handles `do` event.
        
        // INCREASE behavior
        // uml: do / { this.tracer.edgeTransition("edge29"); } TransitionTo(Wait)
        {
            // Step 1: Exit states until we reach `AdjustServoOffsets` state (Least Common Ancestor for transition).
            this.#INCREASE_exit();
            
            // Step 2: Transition action: `this.tracer.edgeTransition("edge29");`.
            this.tracer.edgeTransition("edge29");
            
            // Step 3: Enter/move towards transition target `Wait`.
            this.#WAIT_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = BeadSorter.StateId.WAIT;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for INCREASE
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state WAIT
    ////////////////////////////////////////////////////////////////////////////////
    
    #WAIT_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#WAIT_exit;
        this.#currentEventHandlers[BeadSorter.EventId.BUTTON1] = this.#WAIT_button1;
        this.#currentEventHandlers[BeadSorter.EventId.BUTTON2] = this.#WAIT_button2;
        
        // Wait behavior
        // uml: enter / { this.tracer?.enterState(BeadSorter.StateId.WAIT); }
        {
            // Step 1: execute action `this.tracer?.enterState(BeadSorter.StateId.WAIT);`
            this.tracer?.enterState(BeadSorter.StateId.WAIT);
        } // end of behavior for Wait
        
        // Wait behavior
        // uml: enter / { this.tracer.log("FSM would execute action: " + "picker.displayOffset();"); }
        {
            // Step 1: execute action `this.tracer.log("FSM would execute action: " + "picker.displayOffset();");`
            this.tracer.log("FSM would execute action: " + "picker.displayOffset();");
        } // end of behavior for Wait
    }
    
    #WAIT_exit()
    {
        // Wait behavior
        // uml: exit / { this.tracer?.exitState(BeadSorter.StateId.WAIT); }
        {
            // Step 1: execute action `this.tracer?.exitState(BeadSorter.StateId.WAIT);`
            this.tracer?.exitState(BeadSorter.StateId.WAIT);
        } // end of behavior for Wait
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#ADJUSTSERVOOFFSETS_exit;
        this.#currentEventHandlers[BeadSorter.EventId.BUTTON1] = null;  // no ancestor listens to this event
        this.#currentEventHandlers[BeadSorter.EventId.BUTTON2] = this.#ADJUSTSERVOOFFSETS_button2;  // the next ancestor that handles this event is ADJUSTSERVOOFFSETS
    }
    
    #WAIT_button1()
    {
        // No ancestor state handles `button1` event.
        
        // Wait behavior
        // uml: BUTTON1 / { this.tracer.edgeTransition("edge30"); } TransitionTo(DECREASE)
        {
            // Step 1: Exit states until we reach `AdjustServoOffsets` state (Least Common Ancestor for transition).
            this.#WAIT_exit();
            
            // Step 2: Transition action: `this.tracer.edgeTransition("edge30");`.
            this.tracer.edgeTransition("edge30");
            
            // Step 3: Enter/move towards transition target `DECREASE`.
            this.#DECREASE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = BeadSorter.StateId.DECREASE;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for Wait
    }
    
    #WAIT_button2()
    {
        // Setup handler for next ancestor that listens to `button2` event.
        this.#ancestorEventHandler = this.#ADJUSTSERVOOFFSETS_button2;
        
        // Wait behavior
        // uml: BUTTON2 / { this.tracer.edgeTransition("edge31"); } TransitionTo(INCREASE)
        {
            // Step 1: Exit states until we reach `AdjustServoOffsets` state (Least Common Ancestor for transition).
            this.#WAIT_exit();
            
            // Step 2: Transition action: `this.tracer.edgeTransition("edge31");`.
            this.tracer.edgeTransition("edge31");
            
            // Step 3: Enter/move towards transition target `INCREASE`.
            this.#INCREASE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = BeadSorter.StateId.INCREASE;
            this.#ancestorEventHandler = null;
            return;
        } // end of behavior for Wait
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state SETUPCHECK__START
    ////////////////////////////////////////////////////////////////////////////////
    
    #SETUPCHECK__START_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#SETUPCHECK__START_exit;
        this.#currentEventHandlers[BeadSorter.EventId.BUTTON2] = this.#SETUPCHECK__START_button2;
        this.#currentEventHandlers[BeadSorter.EventId.DO] = this.#SETUPCHECK__START_do;
        
        // SetupCheck__Start behavior
        // uml: enter / { this.tracer?.enterState(BeadSorter.StateId.SETUPCHECK__START); }
        {
            // Step 1: execute action `this.tracer?.enterState(BeadSorter.StateId.SETUPCHECK__START);`
            this.tracer?.enterState(BeadSorter.StateId.SETUPCHECK__START);
        } // end of behavior for SetupCheck__Start
        
        // SetupCheck__Start behavior
        // uml: enter / { this.tracer.log("FSM would execute action: " + "modeDisplay.print(\"SETUP CHECK\");\nsorter.moveTo(0);\npicker.moveTo(DEG_DROPOFF);\npicker.moveTo(DEG_PICKUP);\nt1Restart();"); }
        {
            // Step 1: execute action `this.tracer.log("FSM would execute action: " + "modeDisplay.print(\"SETUP CHECK\");\nsorter.moveTo(0);\npicker.moveTo(DEG_DROPOFF);\npicker.moveTo(DEG_PICKUP);\nt1Restart();");`
            this.tracer.log("FSM would execute action: " + "modeDisplay.print(\"SETUP CHECK\");\nsorter.moveTo(0);\npicker.moveTo(DEG_DROPOFF);\npicker.moveTo(DEG_PICKUP);\nt1Restart();");
        } // end of behavior for SetupCheck__Start
        
        // SetupCheck__Start behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.SETUPCHECK__START;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.SETUPCHECK__START;)"); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.SETUPCHECK__START;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.SETUPCHECK__START;)");`
            this.vars.Running_history = BeadSorter.Running_HistoryId.SETUPCHECK__START;this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.SETUPCHECK__START;)");
        } // end of behavior for SetupCheck__Start
    }
    
    #SETUPCHECK__START_exit()
    {
        // SetupCheck__Start behavior
        // uml: exit / { this.tracer?.exitState(BeadSorter.StateId.SETUPCHECK__START); }
        {
            // Step 1: execute action `this.tracer?.exitState(BeadSorter.StateId.SETUPCHECK__START);`
            this.tracer?.exitState(BeadSorter.StateId.SETUPCHECK__START);
        } // end of behavior for SetupCheck__Start
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#SETUPCHECK_exit;
        this.#currentEventHandlers[BeadSorter.EventId.BUTTON2] = null;  // no ancestor listens to this event
        this.#currentEventHandlers[BeadSorter.EventId.DO] = null;  // no ancestor listens to this event
    }
    
    #SETUPCHECK__START_button2()
    {
        // No ancestor state handles `button2` event.
        
        // SetupCheck__Start behavior
        // uml: BUTTON2 / { this.tracer.edgeTransition("edge26"); } TransitionTo(AdjustServoOffsets)
        {
            // Step 1: Exit states until we reach `SetupCheck` state (Least Common Ancestor for transition).
            this.#SETUPCHECK__START_exit();
            
            // Step 2: Transition action: `this.tracer.edgeTransition("edge26");`.
            this.tracer.edgeTransition("edge26");
            
            // Step 3: Enter/move towards transition target `AdjustServoOffsets`.
            this.#ADJUSTSERVOOFFSETS_enter();
            
            // Finish transition by calling pseudo state transition function.
            this.#AdjustServoOffsets_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for SetupCheck__Start
    }
    
    #SETUPCHECK__START_do()
    {
        // No ancestor state handles `do` event.
        
        // SetupCheck__Start behavior
        // uml: do [this.tracer.log("User evaluating guard: " + "t1After(3s)") || this.evaluateGuard("t1After(3s)")] / { this.tracer.edgeTransition("edge25"); } TransitionTo(Tour)
        if (this.tracer.log("User evaluating guard: " + "t1After(3s)") || this.evaluateGuard("t1After(3s)"))
        {
            // Step 1: Exit states until we reach `SetupCheck` state (Least Common Ancestor for transition).
            this.#SETUPCHECK__START_exit();
            
            // Step 2: Transition action: `this.tracer.edgeTransition("edge25");`.
            this.tracer.edgeTransition("edge25");
            
            // Step 3: Enter/move towards transition target `Tour`.
            this.#TOUR_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = BeadSorter.StateId.TOUR;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for SetupCheck__Start
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state TOUR
    ////////////////////////////////////////////////////////////////////////////////
    
    #TOUR_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#TOUR_exit;
        this.#currentEventHandlers[BeadSorter.EventId.DO] = this.#TOUR_do;
        
        // Tour behavior
        // uml: enter / { this.tracer?.enterState(BeadSorter.StateId.TOUR); }
        {
            // Step 1: execute action `this.tracer?.enterState(BeadSorter.StateId.TOUR);`
            this.tracer?.enterState(BeadSorter.StateId.TOUR);
        } // end of behavior for Tour
        
        // Tour behavior
        // uml: enter / { this.tracer.log("FSM would execute action: " + "tourBin = min(tourBin+1, DEFAULT_BIN);\nsorter.moveTo(tourBin);"); }
        {
            // Step 1: execute action `this.tracer.log("FSM would execute action: " + "tourBin = min(tourBin+1, DEFAULT_BIN);\nsorter.moveTo(tourBin);");`
            this.tracer.log("FSM would execute action: " + "tourBin = min(tourBin+1, DEFAULT_BIN);\nsorter.moveTo(tourBin);");
        } // end of behavior for Tour
        
        // Tour behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.TOUR;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.TOUR;)"); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.TOUR;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.TOUR;)");`
            this.vars.Running_history = BeadSorter.Running_HistoryId.TOUR;this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.TOUR;)");
        } // end of behavior for Tour
    }
    
    #TOUR_exit()
    {
        // Tour behavior
        // uml: exit / { this.tracer?.exitState(BeadSorter.StateId.TOUR); }
        {
            // Step 1: execute action `this.tracer?.exitState(BeadSorter.StateId.TOUR);`
            this.tracer?.exitState(BeadSorter.StateId.TOUR);
        } // end of behavior for Tour
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#SETUPCHECK_exit;
        this.#currentEventHandlers[BeadSorter.EventId.DO] = null;  // no ancestor listens to this event
    }
    
    #TOUR_do()
    {
        // No ancestor state handles `do` event.
        
        // Tour behavior
        // uml: 1. do [this.tracer.log("User evaluating guard: " + "tourBin>=DEFAULT_BIN") || this.evaluateGuard("tourBin>=DEFAULT_BIN")] / { this.tracer.edgeTransition("edge23"); } TransitionTo(TrainingMode)
        if (this.tracer.log("User evaluating guard: " + "tourBin>=DEFAULT_BIN") || this.evaluateGuard("tourBin>=DEFAULT_BIN"))
        {
            // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(this.#RUNNING_exit);
            
            // Step 2: Transition action: `this.tracer.edgeTransition("edge23");`.
            this.tracer.edgeTransition("edge23");
            
            // Step 3: Enter/move towards transition target `TrainingMode`.
            this.#TRAININGMODE_enter();
            
            // Finish transition by calling pseudo state transition function.
            this.#TrainingMode_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for Tour
        
        // Tour behavior
        // uml: do [this.tracer.log("User evaluating guard: " + "true") || this.evaluateGuard("true")] / { this.tracer.edgeTransition("edge24"); } TransitionTo(Tour)
        if (this.tracer.log("User evaluating guard: " + "true") || this.evaluateGuard("true"))
        {
            // Step 1: Exit states until we reach `SetupCheck` state (Least Common Ancestor for transition).
            this.#TOUR_exit();
            
            // Step 2: Transition action: `this.tracer.edgeTransition("edge24");`.
            this.tracer.edgeTransition("edge24");
            
            // Step 3: Enter/move towards transition target `Tour`.
            this.#TOUR_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = BeadSorter.StateId.TOUR;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for Tour
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state SORTINGMODE
    ////////////////////////////////////////////////////////////////////////////////
    
    #SORTINGMODE_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#SORTINGMODE_exit;
        
        // SortingMode behavior
        // uml: enter / { this.tracer?.enterState(BeadSorter.StateId.SORTINGMODE); }
        {
            // Step 1: execute action `this.tracer?.enterState(BeadSorter.StateId.SORTINGMODE);`
            this.tracer?.enterState(BeadSorter.StateId.SORTINGMODE);
        } // end of behavior for SortingMode
        
        // SortingMode behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE;)"); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE;)");`
            this.vars.Running_history = BeadSorter.Running_HistoryId.SORTINGMODE;this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE;)");
        } // end of behavior for SortingMode
    }
    
    #SORTINGMODE_exit()
    {
        // SortingMode behavior
        // uml: exit / { this.tracer?.exitState(BeadSorter.StateId.SORTINGMODE); }
        {
            // Step 1: execute action `this.tracer?.exitState(BeadSorter.StateId.SORTINGMODE);`
            this.tracer?.exitState(BeadSorter.StateId.SORTINGMODE);
        } // end of behavior for SortingMode
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#RUNNING_exit;
    }
    
    #SortingMode_InitialState_transition()
    {
        // SortingMode.<InitialState> behavior
        // uml: / { this.tracer.edgeTransition("edge19"); } TransitionTo(SortingMode__Start)
        {
            // Step 1: Exit states until we reach `SortingMode` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `this.tracer.edgeTransition("edge19");`.
            this.tracer.edgeTransition("edge19");
            
            // Step 3: Enter/move towards transition target `SortingMode__Start`.
            this.#SORTINGMODE__START_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = BeadSorter.StateId.SORTINGMODE__START;
            this.#ancestorEventHandler = null;
            return;
        } // end of behavior for SortingMode.<InitialState>
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state SORTINGMODE__DROPOFF
    ////////////////////////////////////////////////////////////////////////////////
    
    #SORTINGMODE__DROPOFF_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#SORTINGMODE__DROPOFF_exit;
        this.#currentEventHandlers[BeadSorter.EventId.DO] = this.#SORTINGMODE__DROPOFF_do;
        
        // SortingMode__Dropoff behavior
        // uml: enter / { this.tracer?.enterState(BeadSorter.StateId.SORTINGMODE__DROPOFF); }
        {
            // Step 1: execute action `this.tracer?.enterState(BeadSorter.StateId.SORTINGMODE__DROPOFF);`
            this.tracer?.enterState(BeadSorter.StateId.SORTINGMODE__DROPOFF);
        } // end of behavior for SortingMode__Dropoff
        
        // SortingMode__Dropoff behavior
        // uml: enter / { this.tracer.log("FSM would execute action: " + "picker.moveToAndShimmy(DEG_DROPOFF);"); }
        {
            // Step 1: execute action `this.tracer.log("FSM would execute action: " + "picker.moveToAndShimmy(DEG_DROPOFF);");`
            this.tracer.log("FSM would execute action: " + "picker.moveToAndShimmy(DEG_DROPOFF);");
        } // end of behavior for SortingMode__Dropoff
        
        // SortingMode__Dropoff behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__DROPOFF;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__DROPOFF;)"); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__DROPOFF;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__DROPOFF;)");`
            this.vars.Running_history = BeadSorter.Running_HistoryId.SORTINGMODE__DROPOFF;this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__DROPOFF;)");
        } // end of behavior for SortingMode__Dropoff
    }
    
    #SORTINGMODE__DROPOFF_exit()
    {
        // SortingMode__Dropoff behavior
        // uml: exit / { this.tracer?.exitState(BeadSorter.StateId.SORTINGMODE__DROPOFF); }
        {
            // Step 1: execute action `this.tracer?.exitState(BeadSorter.StateId.SORTINGMODE__DROPOFF);`
            this.tracer?.exitState(BeadSorter.StateId.SORTINGMODE__DROPOFF);
        } // end of behavior for SortingMode__Dropoff
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#SORTINGMODE_exit;
        this.#currentEventHandlers[BeadSorter.EventId.DO] = null;  // no ancestor listens to this event
    }
    
    #SORTINGMODE__DROPOFF_do()
    {
        // No ancestor state handles `do` event.
        
        // SortingMode__Dropoff behavior
        // uml: do / { this.tracer.edgeTransition("edge17"); } TransitionTo(SortingMode__Pickup)
        {
            // Step 1: Exit states until we reach `SortingMode` state (Least Common Ancestor for transition).
            this.#SORTINGMODE__DROPOFF_exit();
            
            // Step 2: Transition action: `this.tracer.edgeTransition("edge17");`.
            this.tracer.edgeTransition("edge17");
            
            // Step 3: Enter/move towards transition target `SortingMode__Pickup`.
            this.#SORTINGMODE__PICKUP_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = BeadSorter.StateId.SORTINGMODE__PICKUP;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for SortingMode__Dropoff
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state SORTINGMODE__PICKUP
    ////////////////////////////////////////////////////////////////////////////////
    
    #SORTINGMODE__PICKUP_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#SORTINGMODE__PICKUP_exit;
        this.#currentEventHandlers[BeadSorter.EventId.DO] = this.#SORTINGMODE__PICKUP_do;
        
        // SortingMode__Pickup behavior
        // uml: enter / { this.tracer?.enterState(BeadSorter.StateId.SORTINGMODE__PICKUP); }
        {
            // Step 1: execute action `this.tracer?.enterState(BeadSorter.StateId.SORTINGMODE__PICKUP);`
            this.tracer?.enterState(BeadSorter.StateId.SORTINGMODE__PICKUP);
        } // end of behavior for SortingMode__Pickup
        
        // SortingMode__Pickup behavior
        // uml: enter / { this.tracer.log("FSM would execute action: " + "picker.moveTo(DEG_PICKUP);"); }
        {
            // Step 1: execute action `this.tracer.log("FSM would execute action: " + "picker.moveTo(DEG_PICKUP);");`
            this.tracer.log("FSM would execute action: " + "picker.moveTo(DEG_PICKUP);");
        } // end of behavior for SortingMode__Pickup
        
        // SortingMode__Pickup behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__PICKUP;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__PICKUP;)"); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__PICKUP;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__PICKUP;)");`
            this.vars.Running_history = BeadSorter.Running_HistoryId.SORTINGMODE__PICKUP;this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__PICKUP;)");
        } // end of behavior for SortingMode__Pickup
    }
    
    #SORTINGMODE__PICKUP_exit()
    {
        // SortingMode__Pickup behavior
        // uml: exit / { this.tracer?.exitState(BeadSorter.StateId.SORTINGMODE__PICKUP); }
        {
            // Step 1: execute action `this.tracer?.exitState(BeadSorter.StateId.SORTINGMODE__PICKUP);`
            this.tracer?.exitState(BeadSorter.StateId.SORTINGMODE__PICKUP);
        } // end of behavior for SortingMode__Pickup
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#SORTINGMODE_exit;
        this.#currentEventHandlers[BeadSorter.EventId.DO] = null;  // no ancestor listens to this event
    }
    
    #SORTINGMODE__PICKUP_do()
    {
        // No ancestor state handles `do` event.
        
        // SortingMode__Pickup behavior
        // uml: do / { this.tracer.edgeTransition("edge18"); } TransitionTo(SortingMode__Sensor)
        {
            // Step 1: Exit states until we reach `SortingMode` state (Least Common Ancestor for transition).
            this.#SORTINGMODE__PICKUP_exit();
            
            // Step 2: Transition action: `this.tracer.edgeTransition("edge18");`.
            this.tracer.edgeTransition("edge18");
            
            // Step 3: Enter/move towards transition target `SortingMode__Sensor`.
            this.#SORTINGMODE__SENSOR_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = BeadSorter.StateId.SORTINGMODE__SENSOR;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for SortingMode__Pickup
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state SORTINGMODE__SENSOR
    ////////////////////////////////////////////////////////////////////////////////
    
    #SORTINGMODE__SENSOR_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#SORTINGMODE__SENSOR_exit;
        this.#currentEventHandlers[BeadSorter.EventId.DO] = this.#SORTINGMODE__SENSOR_do;
        
        // SortingMode__Sensor behavior
        // uml: enter / { this.tracer?.enterState(BeadSorter.StateId.SORTINGMODE__SENSOR); }
        {
            // Step 1: execute action `this.tracer?.enterState(BeadSorter.StateId.SORTINGMODE__SENSOR);`
            this.tracer?.enterState(BeadSorter.StateId.SORTINGMODE__SENSOR);
        } // end of behavior for SortingMode__Sensor
        
        // SortingMode__Sensor behavior
        // uml: enter / { this.tracer.log("FSM would execute action: " + "picker.shimmyAndMoveTo(DEG_SENSOR);\nsorter.shimmyAndMoveTo(min(sorter.readColor(), DEFAULT_BIN));"); }
        {
            // Step 1: execute action `this.tracer.log("FSM would execute action: " + "picker.shimmyAndMoveTo(DEG_SENSOR);\nsorter.shimmyAndMoveTo(min(sorter.readColor(), DEFAULT_BIN));");`
            this.tracer.log("FSM would execute action: " + "picker.shimmyAndMoveTo(DEG_SENSOR);\nsorter.shimmyAndMoveTo(min(sorter.readColor(), DEFAULT_BIN));");
        } // end of behavior for SortingMode__Sensor
        
        // SortingMode__Sensor behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__SENSOR;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__SENSOR;)"); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__SENSOR;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__SENSOR;)");`
            this.vars.Running_history = BeadSorter.Running_HistoryId.SORTINGMODE__SENSOR;this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__SENSOR;)");
        } // end of behavior for SortingMode__Sensor
    }
    
    #SORTINGMODE__SENSOR_exit()
    {
        // SortingMode__Sensor behavior
        // uml: exit / { this.tracer?.exitState(BeadSorter.StateId.SORTINGMODE__SENSOR); }
        {
            // Step 1: execute action `this.tracer?.exitState(BeadSorter.StateId.SORTINGMODE__SENSOR);`
            this.tracer?.exitState(BeadSorter.StateId.SORTINGMODE__SENSOR);
        } // end of behavior for SortingMode__Sensor
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#SORTINGMODE_exit;
        this.#currentEventHandlers[BeadSorter.EventId.DO] = null;  // no ancestor listens to this event
    }
    
    #SORTINGMODE__SENSOR_do()
    {
        // No ancestor state handles `do` event.
        
        // SortingMode__Sensor behavior
        // uml: do / { this.tracer.edgeTransition("edge21"); } TransitionTo(SortingMode__Dropoff)
        {
            // Step 1: Exit states until we reach `SortingMode` state (Least Common Ancestor for transition).
            this.#SORTINGMODE__SENSOR_exit();
            
            // Step 2: Transition action: `this.tracer.edgeTransition("edge21");`.
            this.tracer.edgeTransition("edge21");
            
            // Step 3: Enter/move towards transition target `SortingMode__Dropoff`.
            this.#SORTINGMODE__DROPOFF_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = BeadSorter.StateId.SORTINGMODE__DROPOFF;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for SortingMode__Sensor
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state SORTINGMODE__START
    ////////////////////////////////////////////////////////////////////////////////
    
    #SORTINGMODE__START_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#SORTINGMODE__START_exit;
        this.#currentEventHandlers[BeadSorter.EventId.DO] = this.#SORTINGMODE__START_do;
        
        // SortingMode__Start behavior
        // uml: enter / { this.tracer?.enterState(BeadSorter.StateId.SORTINGMODE__START); }
        {
            // Step 1: execute action `this.tracer?.enterState(BeadSorter.StateId.SORTINGMODE__START);`
            this.tracer?.enterState(BeadSorter.StateId.SORTINGMODE__START);
        } // end of behavior for SortingMode__Start
        
        // SortingMode__Start behavior
        // uml: enter / { this.tracer.log("FSM would execute action: " + "modeDisplay.clear();"); }
        {
            // Step 1: execute action `this.tracer.log("FSM would execute action: " + "modeDisplay.clear();");`
            this.tracer.log("FSM would execute action: " + "modeDisplay.clear();");
        } // end of behavior for SortingMode__Start
        
        // SortingMode__Start behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__START;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__START;)"); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__START;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__START;)");`
            this.vars.Running_history = BeadSorter.Running_HistoryId.SORTINGMODE__START;this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__START;)");
        } // end of behavior for SortingMode__Start
    }
    
    #SORTINGMODE__START_exit()
    {
        // SortingMode__Start behavior
        // uml: exit / { this.tracer?.exitState(BeadSorter.StateId.SORTINGMODE__START); }
        {
            // Step 1: execute action `this.tracer?.exitState(BeadSorter.StateId.SORTINGMODE__START);`
            this.tracer?.exitState(BeadSorter.StateId.SORTINGMODE__START);
        } // end of behavior for SortingMode__Start
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#SORTINGMODE_exit;
        this.#currentEventHandlers[BeadSorter.EventId.DO] = null;  // no ancestor listens to this event
    }
    
    #SORTINGMODE__START_do()
    {
        // No ancestor state handles `do` event.
        
        // SortingMode__Start behavior
        // uml: do / { this.tracer.edgeTransition("edge20"); } TransitionTo(SortingMode__Pickup)
        {
            // Step 1: Exit states until we reach `SortingMode` state (Least Common Ancestor for transition).
            this.#SORTINGMODE__START_exit();
            
            // Step 2: Transition action: `this.tracer.edgeTransition("edge20");`.
            this.tracer.edgeTransition("edge20");
            
            // Step 3: Enter/move towards transition target `SortingMode__Pickup`.
            this.#SORTINGMODE__PICKUP_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = BeadSorter.StateId.SORTINGMODE__PICKUP;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for SortingMode__Start
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state TRAININGMODE
    ////////////////////////////////////////////////////////////////////////////////
    
    #TRAININGMODE_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#TRAININGMODE_exit;
        
        // TrainingMode behavior
        // uml: enter / { this.tracer?.enterState(BeadSorter.StateId.TRAININGMODE); }
        {
            // Step 1: execute action `this.tracer?.enterState(BeadSorter.StateId.TRAININGMODE);`
            this.tracer?.enterState(BeadSorter.StateId.TRAININGMODE);
        } // end of behavior for TrainingMode
        
        // TrainingMode behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.TRAININGMODE;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.TRAININGMODE;)"); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.TRAININGMODE;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.TRAININGMODE;)");`
            this.vars.Running_history = BeadSorter.Running_HistoryId.TRAININGMODE;this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.TRAININGMODE;)");
        } // end of behavior for TrainingMode
    }
    
    #TRAININGMODE_exit()
    {
        // TrainingMode behavior
        // uml: exit / { this.tracer?.exitState(BeadSorter.StateId.TRAININGMODE); }
        {
            // Step 1: execute action `this.tracer?.exitState(BeadSorter.StateId.TRAININGMODE);`
            this.tracer?.exitState(BeadSorter.StateId.TRAININGMODE);
        } // end of behavior for TrainingMode
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#RUNNING_exit;
    }
    
    #TrainingMode_InitialState_transition()
    {
        // TrainingMode.<InitialState> behavior
        // uml: / { this.tracer.edgeTransition("edge16"); } TransitionTo(TrainingMode__Start)
        {
            // Step 1: Exit states until we reach `TrainingMode` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `this.tracer.edgeTransition("edge16");`.
            this.tracer.edgeTransition("edge16");
            
            // Step 3: Enter/move towards transition target `TrainingMode__Start`.
            this.#TRAININGMODE__START_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = BeadSorter.StateId.TRAININGMODE__START;
            this.#ancestorEventHandler = null;
            return;
        } // end of behavior for TrainingMode.<InitialState>
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state READEMPTYSLOT
    ////////////////////////////////////////////////////////////////////////////////
    
    #READEMPTYSLOT_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#READEMPTYSLOT_exit;
        
        // ReadEmptySlot behavior
        // uml: enter / { this.tracer?.enterState(BeadSorter.StateId.READEMPTYSLOT); }
        {
            // Step 1: execute action `this.tracer?.enterState(BeadSorter.StateId.READEMPTYSLOT);`
            this.tracer?.enterState(BeadSorter.StateId.READEMPTYSLOT);
        } // end of behavior for ReadEmptySlot
        
        // ReadEmptySlot behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.READEMPTYSLOT;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.READEMPTYSLOT;)"); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.READEMPTYSLOT;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.READEMPTYSLOT;)");`
            this.vars.Running_history = BeadSorter.Running_HistoryId.READEMPTYSLOT;this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.READEMPTYSLOT;)");
        } // end of behavior for ReadEmptySlot
    }
    
    #READEMPTYSLOT_exit()
    {
        // ReadEmptySlot behavior
        // uml: exit / { this.tracer?.exitState(BeadSorter.StateId.READEMPTYSLOT); }
        {
            // Step 1: execute action `this.tracer?.exitState(BeadSorter.StateId.READEMPTYSLOT);`
            this.tracer?.exitState(BeadSorter.StateId.READEMPTYSLOT);
        } // end of behavior for ReadEmptySlot
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#TRAININGMODE_exit;
    }
    
    #ReadEmptySlot_InitialState_transition()
    {
        // ReadEmptySlot.<InitialState> behavior
        // uml: / { this.tracer.edgeTransition("edge1"); } TransitionTo(ReadEmptySlot__Dropoff)
        {
            // Step 1: Exit states until we reach `ReadEmptySlot` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `this.tracer.edgeTransition("edge1");`.
            this.tracer.edgeTransition("edge1");
            
            // Step 3: Enter/move towards transition target `ReadEmptySlot__Dropoff`.
            this.#READEMPTYSLOT__DROPOFF_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = BeadSorter.StateId.READEMPTYSLOT__DROPOFF;
            this.#ancestorEventHandler = null;
            return;
        } // end of behavior for ReadEmptySlot.<InitialState>
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state READEMPTYSLOT__DROPOFF
    ////////////////////////////////////////////////////////////////////////////////
    
    #READEMPTYSLOT__DROPOFF_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#READEMPTYSLOT__DROPOFF_exit;
        this.#currentEventHandlers[BeadSorter.EventId.DO] = this.#READEMPTYSLOT__DROPOFF_do;
        
        // ReadEmptySlot__Dropoff behavior
        // uml: enter / { this.tracer?.enterState(BeadSorter.StateId.READEMPTYSLOT__DROPOFF); }
        {
            // Step 1: execute action `this.tracer?.enterState(BeadSorter.StateId.READEMPTYSLOT__DROPOFF);`
            this.tracer?.enterState(BeadSorter.StateId.READEMPTYSLOT__DROPOFF);
        } // end of behavior for ReadEmptySlot__Dropoff
        
        // ReadEmptySlot__Dropoff behavior
        // uml: enter / { this.tracer.log("FSM would execute action: " + "picker.moveToAndShimmy(DEG_DROPOFF);"); }
        {
            // Step 1: execute action `this.tracer.log("FSM would execute action: " + "picker.moveToAndShimmy(DEG_DROPOFF);");`
            this.tracer.log("FSM would execute action: " + "picker.moveToAndShimmy(DEG_DROPOFF);");
        } // end of behavior for ReadEmptySlot__Dropoff
        
        // ReadEmptySlot__Dropoff behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.READEMPTYSLOT__DROPOFF;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.READEMPTYSLOT__DROPOFF;)"); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.READEMPTYSLOT__DROPOFF;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.READEMPTYSLOT__DROPOFF;)");`
            this.vars.Running_history = BeadSorter.Running_HistoryId.READEMPTYSLOT__DROPOFF;this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.READEMPTYSLOT__DROPOFF;)");
        } // end of behavior for ReadEmptySlot__Dropoff
    }
    
    #READEMPTYSLOT__DROPOFF_exit()
    {
        // ReadEmptySlot__Dropoff behavior
        // uml: exit / { this.tracer?.exitState(BeadSorter.StateId.READEMPTYSLOT__DROPOFF); }
        {
            // Step 1: execute action `this.tracer?.exitState(BeadSorter.StateId.READEMPTYSLOT__DROPOFF);`
            this.tracer?.exitState(BeadSorter.StateId.READEMPTYSLOT__DROPOFF);
        } // end of behavior for ReadEmptySlot__Dropoff
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#READEMPTYSLOT_exit;
        this.#currentEventHandlers[BeadSorter.EventId.DO] = null;  // no ancestor listens to this event
    }
    
    #READEMPTYSLOT__DROPOFF_do()
    {
        // No ancestor state handles `do` event.
        
        // ReadEmptySlot__Dropoff behavior
        // uml: do / { this.tracer.edgeTransition("edge2"); } TransitionTo(ReadEmptySlot__Sensor)
        {
            // Step 1: Exit states until we reach `ReadEmptySlot` state (Least Common Ancestor for transition).
            this.#READEMPTYSLOT__DROPOFF_exit();
            
            // Step 2: Transition action: `this.tracer.edgeTransition("edge2");`.
            this.tracer.edgeTransition("edge2");
            
            // Step 3: Enter/move towards transition target `ReadEmptySlot__Sensor`.
            this.#READEMPTYSLOT__SENSOR_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = BeadSorter.StateId.READEMPTYSLOT__SENSOR;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for ReadEmptySlot__Dropoff
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state READEMPTYSLOT__SENSOR
    ////////////////////////////////////////////////////////////////////////////////
    
    #READEMPTYSLOT__SENSOR_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#READEMPTYSLOT__SENSOR_exit;
        this.#currentEventHandlers[BeadSorter.EventId.DO] = this.#READEMPTYSLOT__SENSOR_do;
        
        // ReadEmptySlot__Sensor behavior
        // uml: enter / { this.tracer?.enterState(BeadSorter.StateId.READEMPTYSLOT__SENSOR); }
        {
            // Step 1: execute action `this.tracer?.enterState(BeadSorter.StateId.READEMPTYSLOT__SENSOR);`
            this.tracer?.enterState(BeadSorter.StateId.READEMPTYSLOT__SENSOR);
        } // end of behavior for ReadEmptySlot__Sensor
        
        // ReadEmptySlot__Sensor behavior
        // uml: enter / { this.tracer.log("FSM would execute action: " + "picker.moveTo(DEG_SENSOR);\nempties++;\nsorter.readColor();"); }
        {
            // Step 1: execute action `this.tracer.log("FSM would execute action: " + "picker.moveTo(DEG_SENSOR);\nempties++;\nsorter.readColor();");`
            this.tracer.log("FSM would execute action: " + "picker.moveTo(DEG_SENSOR);\nempties++;\nsorter.readColor();");
        } // end of behavior for ReadEmptySlot__Sensor
        
        // ReadEmptySlot__Sensor behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.READEMPTYSLOT__SENSOR;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.READEMPTYSLOT__SENSOR;)"); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.READEMPTYSLOT__SENSOR;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.READEMPTYSLOT__SENSOR;)");`
            this.vars.Running_history = BeadSorter.Running_HistoryId.READEMPTYSLOT__SENSOR;this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.READEMPTYSLOT__SENSOR;)");
        } // end of behavior for ReadEmptySlot__Sensor
    }
    
    #READEMPTYSLOT__SENSOR_exit()
    {
        // ReadEmptySlot__Sensor behavior
        // uml: exit / { this.tracer?.exitState(BeadSorter.StateId.READEMPTYSLOT__SENSOR); }
        {
            // Step 1: execute action `this.tracer?.exitState(BeadSorter.StateId.READEMPTYSLOT__SENSOR);`
            this.tracer?.exitState(BeadSorter.StateId.READEMPTYSLOT__SENSOR);
        } // end of behavior for ReadEmptySlot__Sensor
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#READEMPTYSLOT_exit;
        this.#currentEventHandlers[BeadSorter.EventId.DO] = null;  // no ancestor listens to this event
    }
    
    #READEMPTYSLOT__SENSOR_do()
    {
        // No ancestor state handles `do` event.
        
        // ReadEmptySlot__Sensor behavior
        // uml: 1. do [this.tracer.log("User evaluating guard: " + "empties>=NUM_EMPTY_READS") || this.evaluateGuard("empties>=NUM_EMPTY_READS")] / { this.tracer.edgeTransition("edge4"); } TransitionTo(ReadJammedSlot)
        if (this.tracer.log("User evaluating guard: " + "empties>=NUM_EMPTY_READS") || this.evaluateGuard("empties>=NUM_EMPTY_READS"))
        {
            // Step 1: Exit states until we reach `TrainingMode` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(this.#TRAININGMODE_exit);
            
            // Step 2: Transition action: `this.tracer.edgeTransition("edge4");`.
            this.tracer.edgeTransition("edge4");
            
            // Step 3: Enter/move towards transition target `ReadJammedSlot`.
            this.#READJAMMEDSLOT_enter();
            
            // Finish transition by calling pseudo state transition function.
            this.#ReadJammedSlot_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for ReadEmptySlot__Sensor
        
        // ReadEmptySlot__Sensor behavior
        // uml: do / { this.tracer.edgeTransition("edge3"); } TransitionTo(ReadEmptySlot__Dropoff)
        {
            // Step 1: Exit states until we reach `ReadEmptySlot` state (Least Common Ancestor for transition).
            this.#READEMPTYSLOT__SENSOR_exit();
            
            // Step 2: Transition action: `this.tracer.edgeTransition("edge3");`.
            this.tracer.edgeTransition("edge3");
            
            // Step 3: Enter/move towards transition target `ReadEmptySlot__Dropoff`.
            this.#READEMPTYSLOT__DROPOFF_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = BeadSorter.StateId.READEMPTYSLOT__DROPOFF;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for ReadEmptySlot__Sensor
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state READJAMMEDSLOT
    ////////////////////////////////////////////////////////////////////////////////
    
    #READJAMMEDSLOT_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#READJAMMEDSLOT_exit;
        
        // ReadJammedSlot behavior
        // uml: enter / { this.tracer?.enterState(BeadSorter.StateId.READJAMMEDSLOT); }
        {
            // Step 1: execute action `this.tracer?.enterState(BeadSorter.StateId.READJAMMEDSLOT);`
            this.tracer?.enterState(BeadSorter.StateId.READJAMMEDSLOT);
        } // end of behavior for ReadJammedSlot
        
        // ReadJammedSlot behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.READJAMMEDSLOT;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.READJAMMEDSLOT;)"); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.READJAMMEDSLOT;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.READJAMMEDSLOT;)");`
            this.vars.Running_history = BeadSorter.Running_HistoryId.READJAMMEDSLOT;this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.READJAMMEDSLOT;)");
        } // end of behavior for ReadJammedSlot
    }
    
    #READJAMMEDSLOT_exit()
    {
        // ReadJammedSlot behavior
        // uml: exit / { this.tracer?.exitState(BeadSorter.StateId.READJAMMEDSLOT); }
        {
            // Step 1: execute action `this.tracer?.exitState(BeadSorter.StateId.READJAMMEDSLOT);`
            this.tracer?.exitState(BeadSorter.StateId.READJAMMEDSLOT);
        } // end of behavior for ReadJammedSlot
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#TRAININGMODE_exit;
    }
    
    #ReadJammedSlot_InitialState_transition()
    {
        // ReadJammedSlot.<InitialState> behavior
        // uml: / { this.tracer.edgeTransition("edge5"); } TransitionTo(Jammed)
        {
            // Step 1: Exit states until we reach `ReadJammedSlot` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `this.tracer.edgeTransition("edge5");`.
            this.tracer.edgeTransition("edge5");
            
            // Step 3: Enter/move towards transition target `Jammed`.
            this.#JAMMED_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = BeadSorter.StateId.JAMMED;
            this.#ancestorEventHandler = null;
            return;
        } // end of behavior for ReadJammedSlot.<InitialState>
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state JAMMED
    ////////////////////////////////////////////////////////////////////////////////
    
    #JAMMED_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#JAMMED_exit;
        this.#currentEventHandlers[BeadSorter.EventId.DO] = this.#JAMMED_do;
        
        // Jammed behavior
        // uml: enter / { this.tracer?.enterState(BeadSorter.StateId.JAMMED); }
        {
            // Step 1: execute action `this.tracer?.enterState(BeadSorter.StateId.JAMMED);`
            this.tracer?.enterState(BeadSorter.StateId.JAMMED);
        } // end of behavior for Jammed
        
        // Jammed behavior
        // uml: enter / { this.tracer.log("FSM would execute action: " + "picker.moveTo(DEG_JAMMED_READ);"); }
        {
            // Step 1: execute action `this.tracer.log("FSM would execute action: " + "picker.moveTo(DEG_JAMMED_READ);");`
            this.tracer.log("FSM would execute action: " + "picker.moveTo(DEG_JAMMED_READ);");
        } // end of behavior for Jammed
        
        // Jammed behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.JAMMED;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.JAMMED;)"); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.JAMMED;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.JAMMED;)");`
            this.vars.Running_history = BeadSorter.Running_HistoryId.JAMMED;this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.JAMMED;)");
        } // end of behavior for Jammed
    }
    
    #JAMMED_exit()
    {
        // Jammed behavior
        // uml: exit / { this.tracer?.exitState(BeadSorter.StateId.JAMMED); }
        {
            // Step 1: execute action `this.tracer?.exitState(BeadSorter.StateId.JAMMED);`
            this.tracer?.exitState(BeadSorter.StateId.JAMMED);
        } // end of behavior for Jammed
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#READJAMMEDSLOT_exit;
        this.#currentEventHandlers[BeadSorter.EventId.DO] = null;  // no ancestor listens to this event
    }
    
    #JAMMED_do()
    {
        // No ancestor state handles `do` event.
        
        // Jammed behavior
        // uml: do / { this.tracer.edgeTransition("edge8"); } TransitionTo(ReadJammedSlot__Sensor)
        {
            // Step 1: Exit states until we reach `ReadJammedSlot` state (Least Common Ancestor for transition).
            this.#JAMMED_exit();
            
            // Step 2: Transition action: `this.tracer.edgeTransition("edge8");`.
            this.tracer.edgeTransition("edge8");
            
            // Step 3: Enter/move towards transition target `ReadJammedSlot__Sensor`.
            this.#READJAMMEDSLOT__SENSOR_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = BeadSorter.StateId.READJAMMEDSLOT__SENSOR;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for Jammed
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state READJAMMEDSLOT__DROPOFF
    ////////////////////////////////////////////////////////////////////////////////
    
    #READJAMMEDSLOT__DROPOFF_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#READJAMMEDSLOT__DROPOFF_exit;
        this.#currentEventHandlers[BeadSorter.EventId.DO] = this.#READJAMMEDSLOT__DROPOFF_do;
        
        // ReadJammedSlot__Dropoff behavior
        // uml: enter / { this.tracer?.enterState(BeadSorter.StateId.READJAMMEDSLOT__DROPOFF); }
        {
            // Step 1: execute action `this.tracer?.enterState(BeadSorter.StateId.READJAMMEDSLOT__DROPOFF);`
            this.tracer?.enterState(BeadSorter.StateId.READJAMMEDSLOT__DROPOFF);
        } // end of behavior for ReadJammedSlot__Dropoff
        
        // ReadJammedSlot__Dropoff behavior
        // uml: enter / { this.tracer.log("FSM would execute action: " + "picker.moveToAndShimmy(DEG_DROPOFF);"); }
        {
            // Step 1: execute action `this.tracer.log("FSM would execute action: " + "picker.moveToAndShimmy(DEG_DROPOFF);");`
            this.tracer.log("FSM would execute action: " + "picker.moveToAndShimmy(DEG_DROPOFF);");
        } // end of behavior for ReadJammedSlot__Dropoff
        
        // ReadJammedSlot__Dropoff behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.READJAMMEDSLOT__DROPOFF;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.READJAMMEDSLOT__DROPOFF;)"); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.READJAMMEDSLOT__DROPOFF;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.READJAMMEDSLOT__DROPOFF;)");`
            this.vars.Running_history = BeadSorter.Running_HistoryId.READJAMMEDSLOT__DROPOFF;this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.READJAMMEDSLOT__DROPOFF;)");
        } // end of behavior for ReadJammedSlot__Dropoff
    }
    
    #READJAMMEDSLOT__DROPOFF_exit()
    {
        // ReadJammedSlot__Dropoff behavior
        // uml: exit / { this.tracer?.exitState(BeadSorter.StateId.READJAMMEDSLOT__DROPOFF); }
        {
            // Step 1: execute action `this.tracer?.exitState(BeadSorter.StateId.READJAMMEDSLOT__DROPOFF);`
            this.tracer?.exitState(BeadSorter.StateId.READJAMMEDSLOT__DROPOFF);
        } // end of behavior for ReadJammedSlot__Dropoff
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#READJAMMEDSLOT_exit;
        this.#currentEventHandlers[BeadSorter.EventId.DO] = null;  // no ancestor listens to this event
    }
    
    #READJAMMEDSLOT__DROPOFF_do()
    {
        // No ancestor state handles `do` event.
        
        // ReadJammedSlot__Dropoff behavior
        // uml: 1. do [this.tracer.log("User evaluating guard: " + "jammies>=NUM_JAMMED_READS") || this.evaluateGuard("jammies>=NUM_JAMMED_READS")] / { this.tracer.edgeTransition("edge7"); } TransitionTo(ReadSlot)
        if (this.tracer.log("User evaluating guard: " + "jammies>=NUM_JAMMED_READS") || this.evaluateGuard("jammies>=NUM_JAMMED_READS"))
        {
            // Step 1: Exit states until we reach `TrainingMode` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(this.#TRAININGMODE_exit);
            
            // Step 2: Transition action: `this.tracer.edgeTransition("edge7");`.
            this.tracer.edgeTransition("edge7");
            
            // Step 3: Enter/move towards transition target `ReadSlot`.
            this.#READSLOT_enter();
            
            // Finish transition by calling pseudo state transition function.
            this.#ReadSlot_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for ReadJammedSlot__Dropoff
        
        // ReadJammedSlot__Dropoff behavior
        // uml: do / { this.tracer.edgeTransition("edge6"); } TransitionTo(Jammed)
        {
            // Step 1: Exit states until we reach `ReadJammedSlot` state (Least Common Ancestor for transition).
            this.#READJAMMEDSLOT__DROPOFF_exit();
            
            // Step 2: Transition action: `this.tracer.edgeTransition("edge6");`.
            this.tracer.edgeTransition("edge6");
            
            // Step 3: Enter/move towards transition target `Jammed`.
            this.#JAMMED_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = BeadSorter.StateId.JAMMED;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for ReadJammedSlot__Dropoff
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state READJAMMEDSLOT__SENSOR
    ////////////////////////////////////////////////////////////////////////////////
    
    #READJAMMEDSLOT__SENSOR_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#READJAMMEDSLOT__SENSOR_exit;
        this.#currentEventHandlers[BeadSorter.EventId.DO] = this.#READJAMMEDSLOT__SENSOR_do;
        
        // ReadJammedSlot__Sensor behavior
        // uml: enter / { this.tracer?.enterState(BeadSorter.StateId.READJAMMEDSLOT__SENSOR); }
        {
            // Step 1: execute action `this.tracer?.enterState(BeadSorter.StateId.READJAMMEDSLOT__SENSOR);`
            this.tracer?.enterState(BeadSorter.StateId.READJAMMEDSLOT__SENSOR);
        } // end of behavior for ReadJammedSlot__Sensor
        
        // ReadJammedSlot__Sensor behavior
        // uml: enter / { this.tracer.log("FSM would execute action: " + "jammies++;\nsorter.readColor();"); }
        {
            // Step 1: execute action `this.tracer.log("FSM would execute action: " + "jammies++;\nsorter.readColor();");`
            this.tracer.log("FSM would execute action: " + "jammies++;\nsorter.readColor();");
        } // end of behavior for ReadJammedSlot__Sensor
        
        // ReadJammedSlot__Sensor behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.READJAMMEDSLOT__SENSOR;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.READJAMMEDSLOT__SENSOR;)"); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.READJAMMEDSLOT__SENSOR;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.READJAMMEDSLOT__SENSOR;)");`
            this.vars.Running_history = BeadSorter.Running_HistoryId.READJAMMEDSLOT__SENSOR;this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.READJAMMEDSLOT__SENSOR;)");
        } // end of behavior for ReadJammedSlot__Sensor
    }
    
    #READJAMMEDSLOT__SENSOR_exit()
    {
        // ReadJammedSlot__Sensor behavior
        // uml: exit / { this.tracer?.exitState(BeadSorter.StateId.READJAMMEDSLOT__SENSOR); }
        {
            // Step 1: execute action `this.tracer?.exitState(BeadSorter.StateId.READJAMMEDSLOT__SENSOR);`
            this.tracer?.exitState(BeadSorter.StateId.READJAMMEDSLOT__SENSOR);
        } // end of behavior for ReadJammedSlot__Sensor
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#READJAMMEDSLOT_exit;
        this.#currentEventHandlers[BeadSorter.EventId.DO] = null;  // no ancestor listens to this event
    }
    
    #READJAMMEDSLOT__SENSOR_do()
    {
        // No ancestor state handles `do` event.
        
        // ReadJammedSlot__Sensor behavior
        // uml: do / { this.tracer.edgeTransition("edge9"); } TransitionTo(ReadJammedSlot__Dropoff)
        {
            // Step 1: Exit states until we reach `ReadJammedSlot` state (Least Common Ancestor for transition).
            this.#READJAMMEDSLOT__SENSOR_exit();
            
            // Step 2: Transition action: `this.tracer.edgeTransition("edge9");`.
            this.tracer.edgeTransition("edge9");
            
            // Step 3: Enter/move towards transition target `ReadJammedSlot__Dropoff`.
            this.#READJAMMEDSLOT__DROPOFF_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = BeadSorter.StateId.READJAMMEDSLOT__DROPOFF;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for ReadJammedSlot__Sensor
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state READSLOT
    ////////////////////////////////////////////////////////////////////////////////
    
    #READSLOT_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#READSLOT_exit;
        
        // ReadSlot behavior
        // uml: enter / { this.tracer?.enterState(BeadSorter.StateId.READSLOT); }
        {
            // Step 1: execute action `this.tracer?.enterState(BeadSorter.StateId.READSLOT);`
            this.tracer?.enterState(BeadSorter.StateId.READSLOT);
        } // end of behavior for ReadSlot
        
        // ReadSlot behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.READSLOT;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.READSLOT;)"); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.READSLOT;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.READSLOT;)");`
            this.vars.Running_history = BeadSorter.Running_HistoryId.READSLOT;this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.READSLOT;)");
        } // end of behavior for ReadSlot
    }
    
    #READSLOT_exit()
    {
        // ReadSlot behavior
        // uml: exit / { this.tracer?.exitState(BeadSorter.StateId.READSLOT); }
        {
            // Step 1: execute action `this.tracer?.exitState(BeadSorter.StateId.READSLOT);`
            this.tracer?.exitState(BeadSorter.StateId.READSLOT);
        } // end of behavior for ReadSlot
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#TRAININGMODE_exit;
    }
    
    #ReadSlot_InitialState_transition()
    {
        // ReadSlot.<InitialState> behavior
        // uml: / { this.tracer.edgeTransition("edge10"); } TransitionTo(TrainingMode__Pickup)
        {
            // Step 1: Exit states until we reach `ReadSlot` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `this.tracer.edgeTransition("edge10");`.
            this.tracer.edgeTransition("edge10");
            
            // Step 3: Enter/move towards transition target `TrainingMode__Pickup`.
            this.#TRAININGMODE__PICKUP_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = BeadSorter.StateId.TRAININGMODE__PICKUP;
            this.#ancestorEventHandler = null;
            return;
        } // end of behavior for ReadSlot.<InitialState>
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state READSLOT__DROPOFF
    ////////////////////////////////////////////////////////////////////////////////
    
    #READSLOT__DROPOFF_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#READSLOT__DROPOFF_exit;
        this.#currentEventHandlers[BeadSorter.EventId.DO] = this.#READSLOT__DROPOFF_do;
        
        // ReadSlot__Dropoff behavior
        // uml: enter / { this.tracer?.enterState(BeadSorter.StateId.READSLOT__DROPOFF); }
        {
            // Step 1: execute action `this.tracer?.enterState(BeadSorter.StateId.READSLOT__DROPOFF);`
            this.tracer?.enterState(BeadSorter.StateId.READSLOT__DROPOFF);
        } // end of behavior for ReadSlot__Dropoff
        
        // ReadSlot__Dropoff behavior
        // uml: enter / { this.tracer.log("FSM would execute action: " + "picker.moveToAndShimmy(DEG_DROPOFF);"); }
        {
            // Step 1: execute action `this.tracer.log("FSM would execute action: " + "picker.moveToAndShimmy(DEG_DROPOFF);");`
            this.tracer.log("FSM would execute action: " + "picker.moveToAndShimmy(DEG_DROPOFF);");
        } // end of behavior for ReadSlot__Dropoff
        
        // ReadSlot__Dropoff behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.READSLOT__DROPOFF;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.READSLOT__DROPOFF;)"); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.READSLOT__DROPOFF;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.READSLOT__DROPOFF;)");`
            this.vars.Running_history = BeadSorter.Running_HistoryId.READSLOT__DROPOFF;this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.READSLOT__DROPOFF;)");
        } // end of behavior for ReadSlot__Dropoff
    }
    
    #READSLOT__DROPOFF_exit()
    {
        // ReadSlot__Dropoff behavior
        // uml: exit / { this.tracer?.exitState(BeadSorter.StateId.READSLOT__DROPOFF); }
        {
            // Step 1: execute action `this.tracer?.exitState(BeadSorter.StateId.READSLOT__DROPOFF);`
            this.tracer?.exitState(BeadSorter.StateId.READSLOT__DROPOFF);
        } // end of behavior for ReadSlot__Dropoff
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#READSLOT_exit;
        this.#currentEventHandlers[BeadSorter.EventId.DO] = null;  // no ancestor listens to this event
    }
    
    #READSLOT__DROPOFF_do()
    {
        // No ancestor state handles `do` event.
        
        // ReadSlot__Dropoff behavior
        // uml: 1. do [this.tracer.log("User evaluating guard: " + "sorter.isTrainingDone()") || this.evaluateGuard("sorter.isTrainingDone()")] / { this.tracer.edgeTransition("edge12"); } TransitionTo(SortingMode)
        if (this.tracer.log("User evaluating guard: " + "sorter.isTrainingDone()") || this.evaluateGuard("sorter.isTrainingDone()"))
        {
            // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(this.#RUNNING_exit);
            
            // Step 2: Transition action: `this.tracer.edgeTransition("edge12");`.
            this.tracer.edgeTransition("edge12");
            
            // Step 3: Enter/move towards transition target `SortingMode`.
            this.#SORTINGMODE_enter();
            
            // Finish transition by calling pseudo state transition function.
            this.#SortingMode_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for ReadSlot__Dropoff
        
        // ReadSlot__Dropoff behavior
        // uml: do / { this.tracer.edgeTransition("edge11"); } TransitionTo(TrainingMode__Pickup)
        {
            // Step 1: Exit states until we reach `ReadSlot` state (Least Common Ancestor for transition).
            this.#READSLOT__DROPOFF_exit();
            
            // Step 2: Transition action: `this.tracer.edgeTransition("edge11");`.
            this.tracer.edgeTransition("edge11");
            
            // Step 3: Enter/move towards transition target `TrainingMode__Pickup`.
            this.#TRAININGMODE__PICKUP_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = BeadSorter.StateId.TRAININGMODE__PICKUP;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for ReadSlot__Dropoff
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state READSLOT__SENSOR
    ////////////////////////////////////////////////////////////////////////////////
    
    #READSLOT__SENSOR_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#READSLOT__SENSOR_exit;
        this.#currentEventHandlers[BeadSorter.EventId.DO] = this.#READSLOT__SENSOR_do;
        
        // ReadSlot__Sensor behavior
        // uml: enter / { this.tracer?.enterState(BeadSorter.StateId.READSLOT__SENSOR); }
        {
            // Step 1: execute action `this.tracer?.enterState(BeadSorter.StateId.READSLOT__SENSOR);`
            this.tracer?.enterState(BeadSorter.StateId.READSLOT__SENSOR);
        } // end of behavior for ReadSlot__Sensor
        
        // ReadSlot__Sensor behavior
        // uml: enter / { this.tracer.log("FSM would execute action: " + "picker.shimmyAndMoveTo(DEG_SENSOR);\nsorter.readColor();\nsorter.runTraining();\nsorter.shimmyAndMoveTo(DEFAULT_BIN);"); }
        {
            // Step 1: execute action `this.tracer.log("FSM would execute action: " + "picker.shimmyAndMoveTo(DEG_SENSOR);\nsorter.readColor();\nsorter.runTraining();\nsorter.shimmyAndMoveTo(DEFAULT_BIN);");`
            this.tracer.log("FSM would execute action: " + "picker.shimmyAndMoveTo(DEG_SENSOR);\nsorter.readColor();\nsorter.runTraining();\nsorter.shimmyAndMoveTo(DEFAULT_BIN);");
        } // end of behavior for ReadSlot__Sensor
        
        // ReadSlot__Sensor behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.READSLOT__SENSOR;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.READSLOT__SENSOR;)"); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.READSLOT__SENSOR;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.READSLOT__SENSOR;)");`
            this.vars.Running_history = BeadSorter.Running_HistoryId.READSLOT__SENSOR;this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.READSLOT__SENSOR;)");
        } // end of behavior for ReadSlot__Sensor
    }
    
    #READSLOT__SENSOR_exit()
    {
        // ReadSlot__Sensor behavior
        // uml: exit / { this.tracer?.exitState(BeadSorter.StateId.READSLOT__SENSOR); }
        {
            // Step 1: execute action `this.tracer?.exitState(BeadSorter.StateId.READSLOT__SENSOR);`
            this.tracer?.exitState(BeadSorter.StateId.READSLOT__SENSOR);
        } // end of behavior for ReadSlot__Sensor
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#READSLOT_exit;
        this.#currentEventHandlers[BeadSorter.EventId.DO] = null;  // no ancestor listens to this event
    }
    
    #READSLOT__SENSOR_do()
    {
        // No ancestor state handles `do` event.
        
        // ReadSlot__Sensor behavior
        // uml: do / { this.tracer.edgeTransition("edge14"); } TransitionTo(ReadSlot__Dropoff)
        {
            // Step 1: Exit states until we reach `ReadSlot` state (Least Common Ancestor for transition).
            this.#READSLOT__SENSOR_exit();
            
            // Step 2: Transition action: `this.tracer.edgeTransition("edge14");`.
            this.tracer.edgeTransition("edge14");
            
            // Step 3: Enter/move towards transition target `ReadSlot__Dropoff`.
            this.#READSLOT__DROPOFF_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = BeadSorter.StateId.READSLOT__DROPOFF;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for ReadSlot__Sensor
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state TRAININGMODE__PICKUP
    ////////////////////////////////////////////////////////////////////////////////
    
    #TRAININGMODE__PICKUP_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#TRAININGMODE__PICKUP_exit;
        this.#currentEventHandlers[BeadSorter.EventId.DO] = this.#TRAININGMODE__PICKUP_do;
        
        // TrainingMode__Pickup behavior
        // uml: enter / { this.tracer?.enterState(BeadSorter.StateId.TRAININGMODE__PICKUP); }
        {
            // Step 1: execute action `this.tracer?.enterState(BeadSorter.StateId.TRAININGMODE__PICKUP);`
            this.tracer?.enterState(BeadSorter.StateId.TRAININGMODE__PICKUP);
        } // end of behavior for TrainingMode__Pickup
        
        // TrainingMode__Pickup behavior
        // uml: enter / { this.tracer.log("FSM would execute action: " + "picker.moveTo(DEG_PICKUP);"); }
        {
            // Step 1: execute action `this.tracer.log("FSM would execute action: " + "picker.moveTo(DEG_PICKUP);");`
            this.tracer.log("FSM would execute action: " + "picker.moveTo(DEG_PICKUP);");
        } // end of behavior for TrainingMode__Pickup
        
        // TrainingMode__Pickup behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.TRAININGMODE__PICKUP;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.TRAININGMODE__PICKUP;)"); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.TRAININGMODE__PICKUP;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.TRAININGMODE__PICKUP;)");`
            this.vars.Running_history = BeadSorter.Running_HistoryId.TRAININGMODE__PICKUP;this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.TRAININGMODE__PICKUP;)");
        } // end of behavior for TrainingMode__Pickup
    }
    
    #TRAININGMODE__PICKUP_exit()
    {
        // TrainingMode__Pickup behavior
        // uml: exit / { this.tracer?.exitState(BeadSorter.StateId.TRAININGMODE__PICKUP); }
        {
            // Step 1: execute action `this.tracer?.exitState(BeadSorter.StateId.TRAININGMODE__PICKUP);`
            this.tracer?.exitState(BeadSorter.StateId.TRAININGMODE__PICKUP);
        } // end of behavior for TrainingMode__Pickup
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#READSLOT_exit;
        this.#currentEventHandlers[BeadSorter.EventId.DO] = null;  // no ancestor listens to this event
    }
    
    #TRAININGMODE__PICKUP_do()
    {
        // No ancestor state handles `do` event.
        
        // TrainingMode__Pickup behavior
        // uml: do / { this.tracer.edgeTransition("edge13"); } TransitionTo(ReadSlot__Sensor)
        {
            // Step 1: Exit states until we reach `ReadSlot` state (Least Common Ancestor for transition).
            this.#TRAININGMODE__PICKUP_exit();
            
            // Step 2: Transition action: `this.tracer.edgeTransition("edge13");`.
            this.tracer.edgeTransition("edge13");
            
            // Step 3: Enter/move towards transition target `ReadSlot__Sensor`.
            this.#READSLOT__SENSOR_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = BeadSorter.StateId.READSLOT__SENSOR;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for TrainingMode__Pickup
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state TRAININGMODE__START
    ////////////////////////////////////////////////////////////////////////////////
    
    #TRAININGMODE__START_enter()
    {
        // setup trigger/event handlers
        this.#currentStateExitHandler = this.#TRAININGMODE__START_exit;
        this.#currentEventHandlers[BeadSorter.EventId.DO] = this.#TRAININGMODE__START_do;
        
        // TrainingMode__Start behavior
        // uml: enter / { this.tracer?.enterState(BeadSorter.StateId.TRAININGMODE__START); }
        {
            // Step 1: execute action `this.tracer?.enterState(BeadSorter.StateId.TRAININGMODE__START);`
            this.tracer?.enterState(BeadSorter.StateId.TRAININGMODE__START);
        } // end of behavior for TrainingMode__Start
        
        // TrainingMode__Start behavior
        // uml: enter / { this.tracer.log("FSM would execute action: " + "modeDisplay.print(\"TRAINING\");"); }
        {
            // Step 1: execute action `this.tracer.log("FSM would execute action: " + "modeDisplay.print(\"TRAINING\");");`
            this.tracer.log("FSM would execute action: " + "modeDisplay.print(\"TRAINING\");");
        } // end of behavior for TrainingMode__Start
        
        // TrainingMode__Start behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.TRAININGMODE__START;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.TRAININGMODE__START;)"); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.TRAININGMODE__START;)this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.TRAININGMODE__START;)");`
            this.vars.Running_history = BeadSorter.Running_HistoryId.TRAININGMODE__START;this.tracer.log("Executed action: " + "$gil(this.vars.Running_history = Running_HistoryId.TRAININGMODE__START;)");
        } // end of behavior for TrainingMode__Start
    }
    
    #TRAININGMODE__START_exit()
    {
        // TrainingMode__Start behavior
        // uml: exit / { this.tracer?.exitState(BeadSorter.StateId.TRAININGMODE__START); }
        {
            // Step 1: execute action `this.tracer?.exitState(BeadSorter.StateId.TRAININGMODE__START);`
            this.tracer?.exitState(BeadSorter.StateId.TRAININGMODE__START);
        } // end of behavior for TrainingMode__Start
        
        // adjust function pointers for this state's exit
        this.#currentStateExitHandler = this.#TRAININGMODE_exit;
        this.#currentEventHandlers[BeadSorter.EventId.DO] = null;  // no ancestor listens to this event
    }
    
    #TRAININGMODE__START_do()
    {
        // No ancestor state handles `do` event.
        
        // TrainingMode__Start behavior
        // uml: do / { this.tracer.edgeTransition("edge15"); } TransitionTo(ReadEmptySlot)
        {
            // Step 1: Exit states until we reach `TrainingMode` state (Least Common Ancestor for transition).
            this.#TRAININGMODE__START_exit();
            
            // Step 2: Transition action: `this.tracer.edgeTransition("edge15");`.
            this.tracer.edgeTransition("edge15");
            
            // Step 3: Enter/move towards transition target `ReadEmptySlot`.
            this.#READEMPTYSLOT_enter();
            
            // Finish transition by calling pseudo state transition function.
            this.#ReadEmptySlot_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for TrainingMode__Start
    }
    
    // Thread safe.
    static stateIdToString(id)
    {
        switch (id)
        {
            case BeadSorter.StateId.ROOT: return "ROOT";
            case BeadSorter.StateId.PAUSED: return "PAUSED";
            case BeadSorter.StateId.RUNNING: return "RUNNING";
            case BeadSorter.StateId.SETUPCHECK: return "SETUPCHECK";
            case BeadSorter.StateId.ADJUSTSERVOOFFSETS: return "ADJUSTSERVOOFFSETS";
            case BeadSorter.StateId.DECREASE: return "DECREASE";
            case BeadSorter.StateId.INCREASE: return "INCREASE";
            case BeadSorter.StateId.WAIT: return "WAIT";
            case BeadSorter.StateId.SETUPCHECK__START: return "SETUPCHECK__START";
            case BeadSorter.StateId.TOUR: return "TOUR";
            case BeadSorter.StateId.SORTINGMODE: return "SORTINGMODE";
            case BeadSorter.StateId.SORTINGMODE__DROPOFF: return "SORTINGMODE__DROPOFF";
            case BeadSorter.StateId.SORTINGMODE__PICKUP: return "SORTINGMODE__PICKUP";
            case BeadSorter.StateId.SORTINGMODE__SENSOR: return "SORTINGMODE__SENSOR";
            case BeadSorter.StateId.SORTINGMODE__START: return "SORTINGMODE__START";
            case BeadSorter.StateId.TRAININGMODE: return "TRAININGMODE";
            case BeadSorter.StateId.READEMPTYSLOT: return "READEMPTYSLOT";
            case BeadSorter.StateId.READEMPTYSLOT__DROPOFF: return "READEMPTYSLOT__DROPOFF";
            case BeadSorter.StateId.READEMPTYSLOT__SENSOR: return "READEMPTYSLOT__SENSOR";
            case BeadSorter.StateId.READJAMMEDSLOT: return "READJAMMEDSLOT";
            case BeadSorter.StateId.JAMMED: return "JAMMED";
            case BeadSorter.StateId.READJAMMEDSLOT__DROPOFF: return "READJAMMEDSLOT__DROPOFF";
            case BeadSorter.StateId.READJAMMEDSLOT__SENSOR: return "READJAMMEDSLOT__SENSOR";
            case BeadSorter.StateId.READSLOT: return "READSLOT";
            case BeadSorter.StateId.READSLOT__DROPOFF: return "READSLOT__DROPOFF";
            case BeadSorter.StateId.READSLOT__SENSOR: return "READSLOT__SENSOR";
            case BeadSorter.StateId.TRAININGMODE__PICKUP: return "TRAININGMODE__PICKUP";
            case BeadSorter.StateId.TRAININGMODE__START: return "TRAININGMODE__START";
            default: return "?";
        }
    }
    
    // Thread safe.
    static eventIdToString(id)
    {
        switch (id)
        {
            case BeadSorter.EventId.BUTTON0: return "BUTTON0";
            case BeadSorter.EventId.BUTTON1: return "BUTTON1";
            case BeadSorter.EventId.BUTTON2: return "BUTTON2";
            case BeadSorter.EventId.DO: return "DO";
            default: return "?";
        }
    }
}

</script>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        import svgPanZoom from 'https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/+esm' ;
        mermaid.initialize({ startOnLoad: false });
        await mermaid.run();

        // svg-pan-zoom doesn't like the mermaid viewbox
        document.querySelector('svg').removeAttribute('viewBox');
        document.querySelector('svg').setAttribute('width', '100%');
        document.querySelector('svg').setAttribute('height', '100%');
        document.querySelector('svg').style["max-width"] = '';

        var panZoom = window.panZoom = svgPanZoom(document.querySelector('svg'), {
            zoomEnabled: true,
            controlIconsEnabled: true,
            fit: true,
            center: true
        });


        const leftPane = document.querySelector(".main");
        const rightPane = document.querySelector(".sidebar");
        const gutter = document.querySelector(".gutter");

        function resizer(e) {          
          window.addEventListener('mousemove', mousemove);
          window.addEventListener('mouseup', mouseup);          
          let prevX = e.x;
          const rightPanel = rightPane.getBoundingClientRect();
                    
          function mousemove(e) {
            let newX = prevX - e.x;
            rightPane.style.width = rightPanel.width + newX + 'px';
            window.panZoom.resize();
            window.panZoom.fit();
            window.panZoom.center();
          }
          
          function mouseup() {
            window.removeEventListener('mousemove', mousemove);
            window.removeEventListener('mouseup', mouseup);
            
          }                  
        }

        gutter.addEventListener('mousedown', resizer);

        document.getElementById('timestamps').checked = document.querySelector('table.console').classList.contains('timestamps');
        document.getElementById('timestamps').addEventListener('change', function() {
          if(this.checked) {
            document.querySelector('table.console').classList.add('timestamps');
          } else {
            document.querySelector('table.console').classList.remove('timestamps');
          }
        });

        document.getElementById('dropbtn').addEventListener('click', myFunction);

        /* When the user clicks on the button, 
        toggle between hiding and showing the dropdown content */
        function myFunction() {
          document.getElementById('myDropdown').classList.toggle('show');
        }

        // Close the dropdown if the user clicks outside of it
        window.onclick = function(event) {
          if (!event.target.matches('.dropbtn')) {
            var dropdowns = document.getElementsByClassName('dropdown-content');
            var i;
            for (i = 0; i < dropdowns.length; i++) {
              var openDropdown = dropdowns[i];
              if (openDropdown.classList.contains('show')) {
                openDropdown.classList.remove('show');
              }
            }
          }
        }




        // Convert a date to a string in the format HH:MM:SS.sss
        function formatTime(date) {
            return date.getHours().toString().padStart(2, '0') + ':' +
                date.getMinutes().toString().padStart(2, '0') + ':' +
                date.getSeconds().toString().padStart(2, '0') + '.' +
                date.getMilliseconds().toString().padStart(3, '0');
        }

        // Add a row to the history table.
        function addHistoryRow(time, event, emphasis = false) {
            var row = document.createElement('tr');
            var timeCell = document.createElement('td');
            timeCell.innerText = formatTime(time);
            timeCell.classList.add('timestamp');
            var eventCell = document.createElement('td');
            eventCell.innerText = event;
            if(emphasis) {
                eventCell.classList.add('emphasis');                
            }
            row.appendChild(timeCell);
            row.appendChild(eventCell);
            document.querySelector('tbody').appendChild(row);
        }

        var sm = new BeadSorter();

        // prompt the user to evaluate guards manually
        sm.evaluateGuard = (guard) => {
            return confirm('Evaluate guard: ' + guard);
        }; 

        const highlightedEdges = new Set();
        function highlightEdge(edgeId) {
            var edge = document.getElementById(edgeId);
            if (edge) {
                edge.style.stroke = 'red';
                highlightedEdges.add(edge);
            }
        }

        function clearHighlightedEdges() {
            for (const edge of highlightedEdges) {
                const showOldTraversal = true;
                if (showOldTraversal) {
                    // shows that the edge was traversed. Optional, but kinda nice.
                    edge.style.stroke = 'green';
                } else {
                    edge.style.stroke = '';
                }
            }
            highlightedEdges.clear();
        }

        // The simulator uses a tracer callback to perform operations such as 
        // state highlighting and logging. You do not need this functionality
        // when using BeadSorter.js in your own applications, although you may
        // choose to implement a tracer for debugging purposes.
        sm.tracer = {
            enterState: (stateId) => {
                var name = BeadSorter.stateIdToString(stateId);
                document.querySelector('g[data-id=' + name + ']')?.classList.add('active');
                sm.tracer.log("Entered " + name);
            },
            exitState: (stateId) => {
                var name = BeadSorter.stateIdToString(stateId);
                document.querySelector('g[data-id=' + name + ']')?.classList.remove('active');
            },
            edgeTransition: (edgeId) => {
                highlightEdge(edgeId);
            },
            log: (message, emphasis=false) => {
                addHistoryRow(new Date(), message, emphasis);
            }
        };

        // Wire up the buttons that dispatch events for the state machine.
        for (const eventName in BeadSorter.EventId) {
            var button = document.createElement('button');
            button.id = 'button_' + eventName;
            button.innerText = eventName;
            button.addEventListener('click', () => {
                clearHighlightedEdges();
                sm.tracer.log("Dispatched " + eventName, true);
                sm.dispatchEvent(BeadSorter.EventId[eventName]); 
            });
            document.getElementById('buttons').appendChild(button);
        }

        sm.start();
    </script>


  </body>
</html>
