<!-- 
  -- This file was generated by StateSmith.
  -- Note! The generated state machine code in this file has been specially instrumented to support simulator features.
  -- Regular generated javascript state machine code is smaller and simpler.
  -->
<html>
  <head>
    <link rel='icon' type='image/png' href='https://statesmith.github.io/favicon.png'>

      <!-- The below css makes the titlebar-icon functionality work. See https://fonts.google.com/icons -->
    <link rel='stylesheet' href='https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined'>

    <style>
      body {
        display: flex;
        flex-direction: row;
        margin: 0px;
        color: #cacad1;
        font-family: 'Arial';
        font-size: 13px;
      }

      code {
        font-family: monospace;
        color:aquamarine;
        white-space: pre;
      }

      .identifier {
        color: #9bc2e4;
      }

      /* Fix for mermaid content requiring scroll bars https://github.com/StateSmith/StateSmith/issues/288 */
      pre.mermaid {
        margin: 0px;
      }

      #event-logs a {
        text-decoration: none;
        color: inherit;
      }

      .wrapper {
        height: 100vh;
        width: 100vw;
        display: flex;
      }

      .pane {
        padding: 1em;
        min-width: 200px;
      }

      .titlebar-icon {
        font-family: 'Material Symbols Outlined', sans-serif;
        font-size: 16px;
        color: #b4b4b4;
        border-radius: 5px;
      }

      .gutter {
        width: 10px;
        height: 100%;
        background: #ccc;
        position: absolute;
        top: 0;
        left: 0;
        cursor: col-resize;
      }

      .main {
        flex: 1;
        overflow: auto;
        padding: 10px;
        background-color: #1E222A; /* Dark theme */
      }

      .sidebar {
        width: 300px;
        padding-top: 0px;
        position: relative;
        background-color: #30394b;
        border-left: 1px solid #ccc;
        display: flex;
        flex-direction: column;
      }

      #buttons {
        display: flex;
        flex-direction: column;
      }

      .titlebar {
        background-color: #1d222e;
        border-bottom: 1px solid #454f64;
        font-weight: bold;
        padding: 5px;
        display: flex;
      }

      .console {
        border-collapse: collapse;
        margin-top: 10px;
        width: 100%;
      }

      table.console td.timestamp {
        display: none;
      }

      table.console.timestamps td.timestamp {
        display: table-cell;
      }

      table.console td {
          color: inherit;
      }

      table.console td .dispatched {
          font-weight: bold;
          color: #dbdbdb;
      }

      table.console tr:has(+tr td .dispatched) {
          border-bottom: 0px;
      }

      table.console tr:has(+tr td .dispatched) td {
          padding-bottom: 25px;
      }

      .console tbody {
        font-family: monospace;
      }

      .console tr {
        border-bottom: 1px solid #596275;
      }

      .console td {
        padding: 5px;
      }
  
      .console td.timestamp {
        font-size: small;
      }

      #event-logs {
        margin-top: 30px;       
        display: flex;
        overflow: auto;    
        flex-direction: column-reverse;
      }

      .console tr:last-child td {
        border-bottom: none;
      }

      .dispatched {
        font-weight: bold;
      }

      .dispatched .event-id {
        border: 1px solid #000;
        border-radius: 4px;
        padding: 2px 4px;
      }

      .dispatched .forced-state {
        border: 1px solid #000;
        /* color: white; */
        color: #252541;
        background-color: #E06C75;
        border-radius: 4px;
        padding: 2px 4px;
      }

      button {
        margin: 5px;
      }

      button.event-button, .event-id {
        /* background-color: #4e98d4;
        color: #252541; */
        background-color: #08487c;
        color: #e9f5ff;
      }

      button.event-button {
        transition: opacity 0.3s ease, background-color 0.3s ease;
        opacity: 1;
        cursor: pointer;
      }

      button.event-button.hasNoEventHandler {
        opacity: 0.4;
        background-color: #f0f0f0;
        color: #2b2b30;
        cursor: not-allowed;
      }

      button.event-button:not(.hasNoEventHandler):hover {
        background-color: #00559b;
      }

      /* Style for hiding irrelevant events */
      button.event-button.hidden {
        display: none;
      }



      /* ----------------------------- Dropdown related start ----------------------------- */
      
      .dropdown-button {
        border: none;
        cursor: pointer;
        user-select: none;
      }
      
      .dropdown-button:hover, .dropdown-button:focus {
        background-color: aquamarine;
        color: #000;
      }
      
      .dropdown {
        position: relative;
        display: inline-block;
        margin-left: auto;
      }
      
      .dropdown-content {
        display: none;
        position: absolute;
        right: 0;
        background-color: #24253c;
        min-width: 250px;
        overflow: auto;
        box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
        z-index: 1;
      }
      
      .dropdown-content .dropdown-item {
        display: block;
        padding: 12px 16px;
        font-weight: normal;
      }

      .dropdown-content .dropdown-item:hover {
        background-color: #333786;
        cursor: pointer;
      }

      .show {
        display: block;
      }

      /* ----------------------------- Dropdown related end ----------------------------- */

      .transition {
        stroke-width: 2px !important;
      }

      .transition.pathJustTaken {
        stroke: #E06C75 !important;
        stroke-width: 4px !important;
        stroke-dasharray: 10 5;
        filter: drop-shadow( 3px 3px 2px rgba(0, 0, 0, .7));
      }

      /* give priority over pathJustTaken. If it is available and pathJustTaken, then it will still have dash. */
      .transition.available {
        stroke: #7e70cf !important;
        stroke-width: 4px !important;
        filter: drop-shadow( 2px 2px 1px rgba(0, 0, 0, .7));
      }

      .statediagram-state.active > * {
        fill: #4e98d4 !important;
        stroke: #00559b !important;
        stroke-width: 2px !important;
      }

      .statediagram-state.active span.nodeLabel {
        color: #000d53 !important;
      }

      /* we don't want to fill body of parent state with regular active yellow. It's just too much! */
      .statediagram-state.active rect.inner {
        fill: #444  !important;
        stroke-width: 2px !important;
      }

      .clickableDiagramElement {
        cursor: pointer;
      }

      span.edgeLabel.clickableDiagramElement:hover {
        color: aquamarine !important;
      }

      span.nodeLabel.clickableDiagramElement:hover {
        color: aquamarine !important;
      }

    </style>
  </head>

  <body>
    <div class='wrapper'>
    <div class='pane main'>
        <!-- mermaid themes: default, dark, forest, neutral, base https://mermaid.ai/open-source/config/theming.html -->
        <pre class='mermaid'>
---

config:
    theme: 'base'
    themeVariables:
        primaryColor: '#1f2020'
        primaryTextColor: '#f0f0f0'
        background: '#333'
        primaryBorderColor: '#888888'
        lineColor: '#999'

---

stateDiagram

state Running {

        state TrainingMode {

                state ReadEmptySlot {

                        %% Initial state name as "." so that it fits in black circle shape.
                        %% See https://github.com/StateSmith/StateSmith/issues/404
                        state "." as ReadEmptySlot.(InitialState)

                        ReadEmptySlot__Dropoff

                        ReadEmptySlot__Dropoff : ReadEmptySlot__Dropoff

                        ReadEmptySlot__Dropoff : enter / #123; picker.moveToAndShimmy(DEG_DROPOFF)#59; #125;

                        ReadEmptySlot__Sensor

                        ReadEmptySlot__Sensor : ReadEmptySlot__Sensor

                        ReadEmptySlot__Sensor : enter / #123; picker.moveTo(DEG_SENSOR)#59;\nempties++#59;\nsorter.readColor()#59; #125;

                        state "$HC" as ReadEmptySlot.(HistoryContinue)

                }

                state ReadJammedSlot {

                        %% Initial state name as "." so that it fits in black circle shape.
                        %% See https://github.com/StateSmith/StateSmith/issues/404
                        state "." as ReadJammedSlot.(InitialState)

                        ReadJammedSlot__Dropoff

                        ReadJammedSlot__Dropoff : ReadJammedSlot__Dropoff

                        ReadJammedSlot__Dropoff : enter / #123; picker.moveToAndShimmy(DEG_DROPOFF)#59; #125;

                        Jammed

                        Jammed : Jammed

                        Jammed : enter / #123; picker.moveTo(DEG_JAMMED_READ)#59; #125;

                        ReadJammedSlot__Sensor

                        ReadJammedSlot__Sensor : ReadJammedSlot__Sensor

                        ReadJammedSlot__Sensor : enter / #123; jammies++#59;\nsorter.readColor()#59; #125;

                        state "$HC" as ReadJammedSlot.(HistoryContinue)

                }

                state ReadSlot {

                        %% Initial state name as "." so that it fits in black circle shape.
                        %% See https://github.com/StateSmith/StateSmith/issues/404
                        state "." as ReadSlot.(InitialState)

                        ReadSlot__Dropoff

                        ReadSlot__Dropoff : ReadSlot__Dropoff

                        ReadSlot__Dropoff : enter / #123; picker.moveToAndShimmy(DEG_DROPOFF)#59; #125;

                        TrainingMode__Pickup

                        TrainingMode__Pickup : TrainingMode__Pickup

                        TrainingMode__Pickup : enter / #123; picker.moveTo(DEG_PICKUP)#59; #125;

                        ReadSlot__Sensor

                        ReadSlot__Sensor : ReadSlot__Sensor

                        ReadSlot__Sensor : enter / #123; picker.shimmyAndMoveTo(DEG_SENSOR)#59;\nsorter.readColor()#59;\nsorter.runTraining()#59;\nsorter.shimmyAndMoveTo(DEFAULT_BIN)#59; #125;

                        state "$HC" as ReadSlot.(HistoryContinue)

                }

                TrainingMode__Start

                TrainingMode__Start : TrainingMode__Start

                TrainingMode__Start : enter / #123; modeDisplay.print("TRAINING")#59; #125;

                %% Initial state name as "." so that it fits in black circle shape.
                %% See https://github.com/StateSmith/StateSmith/issues/404
                state "." as TrainingMode.(InitialState)

                state "$HC" as TrainingMode.(HistoryContinue)

        }

        state SortingMode {

                SortingMode__Dropoff

                SortingMode__Dropoff : SortingMode__Dropoff

                SortingMode__Dropoff : enter / #123; picker.moveToAndShimmy(DEG_DROPOFF)#59; #125;

                SortingMode__Pickup

                SortingMode__Pickup : SortingMode__Pickup

                SortingMode__Pickup : enter / #123; picker.moveTo(DEG_PICKUP)#59; #125;

                %% Initial state name as "." so that it fits in black circle shape.
                %% See https://github.com/StateSmith/StateSmith/issues/404
                state "." as SortingMode.(InitialState)

                SortingMode__Start

                SortingMode__Start : SortingMode__Start

                SortingMode__Start : enter / #123; modeDisplay.clear()#59; #125;

                state "$HC" as SortingMode.(HistoryContinue)

                SortingMode__Sensor

                SortingMode__Sensor : SortingMode__Sensor

                SortingMode__Sensor : enter / #123; picker.shimmyAndMoveTo(DEG_SENSOR)#59;\nsorter.shimmyAndMoveTo(min(sorter.readColor(), DEFAULT_BIN))#59; #125;

        }

        state SetupCheck {

                %% Initial state name as "." so that it fits in black circle shape.
                %% See https://github.com/StateSmith/StateSmith/issues/404
                state "." as SetupCheck.(InitialState)

                Tour

                Tour : Tour

                Tour : enter / #123; tourBin = min(tourBin+1, DEFAULT_BIN)#59;\nsorter.moveTo(tourBin)#59; #125;

                SetupCheck__Start

                SetupCheck__Start : SetupCheck__Start

                SetupCheck__Start : enter / #123; modeDisplay.print("SETUP CHECK")#59;\nsorter.moveTo(0)#59;\npicker.moveTo(DEG_DROPOFF)#59;\npicker.moveTo(DEG_PICKUP)#59;\nt1Restart()#59; #125;

                state "$HC" as SetupCheck.(HistoryContinue)

                state AdjustServoOffsets {

                        DECREASE

                        DECREASE : DECREASE

                        DECREASE : enter / #123; picker.adjustOffset(-2)#59; #125;

                        INCREASE

                        INCREASE : INCREASE

                        INCREASE : enter / #123; picker.adjustOffset(2)#59; #125;

                        Wait

                        Wait : Wait

                        Wait : enter / #123; picker.displayOffset()#59; #125;

                        %% Initial state name as "." so that it fits in black circle shape.
                        %% See https://github.com/StateSmith/StateSmith/issues/404
                        state "." as AdjustServoOffsets.(InitialState)

                }

        }

        %% Initial state name as "." so that it fits in black circle shape.
        %% See https://github.com/StateSmith/StateSmith/issues/404
        state "." as Running.(InitialState)

        state "$H" as Running.(History)

}

Paused

Paused : Paused

%% Initial state name as "." so that it fits in black circle shape.
%% See https://github.com/StateSmith/StateSmith/issues/404
state "." as ROOT.(InitialState)

Running --> Paused : BUTTON0

ReadEmptySlot.(InitialState) --> ReadEmptySlot__Dropoff

ReadEmptySlot__Dropoff --> ReadEmptySlot__Sensor : do

ReadEmptySlot__Sensor --> ReadEmptySlot__Dropoff : do

ReadEmptySlot__Sensor --> ReadJammedSlot : 1. do [empties>=NUM_EMPTY_READS]

ReadJammedSlot.(InitialState) --> Jammed

ReadJammedSlot__Dropoff --> Jammed : do

ReadJammedSlot__Dropoff --> ReadSlot : 1. do [jammies>=NUM_JAMMED_READS]

Jammed --> ReadJammedSlot__Sensor : do

ReadJammedSlot__Sensor --> ReadJammedSlot__Dropoff : do

ReadSlot.(InitialState) --> TrainingMode__Pickup

ReadSlot__Dropoff --> TrainingMode__Pickup : do

ReadSlot__Dropoff --> SortingMode : 1. do [sorter.isTrainingDone()]

TrainingMode__Pickup --> ReadSlot__Sensor : do

ReadSlot__Sensor --> ReadSlot__Dropoff : do

TrainingMode__Start --> ReadEmptySlot : do

TrainingMode.(InitialState) --> TrainingMode__Start

SortingMode__Dropoff --> SortingMode__Pickup : do

SortingMode__Pickup --> SortingMode__Sensor : do

SortingMode.(InitialState) --> SortingMode__Start

SortingMode__Start --> SortingMode__Pickup : do

SortingMode__Sensor --> SortingMode__Dropoff : do

SetupCheck.(InitialState) --> SetupCheck__Start

Tour --> TrainingMode : 1. do [tourBin>=DEFAULT_BIN]

Tour --> Tour : do [true]

SetupCheck__Start --> Tour : do [t1After(3s)]

SetupCheck__Start --> AdjustServoOffsets : BUTTON2

AdjustServoOffsets --> SetupCheck__Start : BUTTON2

DECREASE --> Wait : do

INCREASE --> Wait : do

Wait --> DECREASE : BUTTON1

Wait --> INCREASE : BUTTON2

AdjustServoOffsets.(InitialState) --> Wait

Running.(InitialState) --> Running.(History)

Running.(History) --> SetupCheck

Paused --> Running : BUTTON0

ROOT.(InitialState) --> Running



        </pre>
    </div>

    <div class='pane sidebar'>
      <div id='buttons'>
        <div class='titlebar'>Events
          <div class='dropdown'>
            <span id='settings-dropdown-button' class='titlebar-icon dropdown-button' title='Settings'>settings</span>
            <span id='clear-button' class='titlebar-icon dropdown-button' title='Clear event log'>delete</span>
            <a href='https://github.com/StateSmith/StateSmith/wiki/Simulator' id='help-button' class='titlebar-icon dropdown-button' target='_blank' title='CHECK THIS!&#10;The simulator has a number of quirks and limitations&#10;that you should be aware of.'>help</a>
            <div id='myDropdown' class='dropdown-content'>

              <!-- 
                NOTE! Try not to change the ids of input checkboxes below as that will reset user preferences stored in localStorage.
                NOTE! New settings will be automatically picked up if they start with 'savedSetting_' and are checkboxes.
               -->

              <label class='dropdown-item' for='savedSetting_hideIrrelevantEvents'
                title='When enabled, event dispatching buttons will be hidden if the current active state(s) ignore the event.'>
                <input type='checkbox' id='savedSetting_hideIrrelevantEvents' name='savedSetting_hideIrrelevantEvents'>
                Hide ignored event buttons
              </label>
              <label class='dropdown-item' for='savedSetting_verboseEnter'
                title='Every time a state is entered, it will be logged below in the event log.'>
                <input type='checkbox' id='savedSetting_verboseEnter' name='savedSetting_verboseEnter' checked>
                Log State Entry
              </label>
              <label class='dropdown-item' for='savedSetting_verboseExit'
                title='Every time a state is exited, it will be logged below in the event log.'>
                <input type='checkbox' id='savedSetting_verboseExit' name='savedSetting_verboseExit' checked>
                Log State Exit
              </label>
              <label class='dropdown-item' for='savedSetting_verboseHistory'
                title='Log history pseudo state variable updates'>
                <input type='checkbox' id='savedSetting_verboseHistory' name='savedSetting_verboseHistory' checked>
                Log History Variables
              </label>
              <label class='dropdown-item' for='savedSetting_showEventButtonTooltips'
                 title='Event dispatching buttons will have tooltips with additional info.&#10;ðŸ“¢ NOTE! Changes to this setting take effect on state change or page reload.'>
                <input type='checkbox' id='savedSetting_showEventButtonTooltips' name='savedSetting_showEventButtonTooltips' checked>
                Show event button tooltips
              </label>
              <!-- setting for requiring CTRL to held while clicking to force state -->
                <label class='dropdown-item' for='savedSetting_requireCtrlForForceState'
                    title='CTRL key must be held while clicking a state to force it.&#10;This can help prevent accidental forced state changes.'>
                    <input type='checkbox' id='savedSetting_requireCtrlForForceState' name='savedSetting_requireCtrlForForceState'>
                    Require CTRL to force state
                </label>
              <label class='dropdown-item' for='savedSetting_timestamps'
                title='Controls whether timestamps are shown along side event dispatches.'>
                <input type='checkbox' id='savedSetting_timestamps' name='savedSetting_timestamps'>
                Timestamps
              </label>
            </div>
          </div>
        </div>
      </div>
    
      <div id='event-logs'>
        <table class='console'>
          <tbody>
          </tbody>
        </table>
      </div>
    
      <div class='gutter'></div>
    </div>
    </div>

<script>
// Autogenerated with StateSmith.
// Algorithm: Balanced2. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

// Generated state machine
class BeadSorter
{
// Null by default.
// May be overridden to override guard evaluation (eg. in a simulator)
evaluateGuard = null;
    static EventId = 
    {
        DO : 0, // The `do` event is special. State event handlers do not consume this event (ancestors all get it too) unless a transition occurs.
        BUTTON0 : 1,
        BUTTON1 : 2,
        BUTTON2 : 3,
    }
    static { Object.freeze(this.EventId); }
    
    static EventIdCount = 4;
    static { Object.freeze(this.EventIdCount); }
    
    static StateId = 
    {
        ROOT : 0,
        PAUSED : 1,
        RUNNING : 2,
        SETUPCHECK : 3,
        ADJUSTSERVOOFFSETS : 4,
        DECREASE : 5,
        INCREASE : 6,
        WAIT : 7,
        SETUPCHECK__START : 8,
        TOUR : 9,
        SORTINGMODE : 10,
        SORTINGMODE__DROPOFF : 11,
        SORTINGMODE__PICKUP : 12,
        SORTINGMODE__SENSOR : 13,
        SORTINGMODE__START : 14,
        TRAININGMODE : 15,
        READEMPTYSLOT : 16,
        READEMPTYSLOT__DROPOFF : 17,
        READEMPTYSLOT__SENSOR : 18,
        READJAMMEDSLOT : 19,
        JAMMED : 20,
        READJAMMEDSLOT__DROPOFF : 21,
        READJAMMEDSLOT__SENSOR : 22,
        READSLOT : 23,
        READSLOT__DROPOFF : 24,
        READSLOT__SENSOR : 25,
        TRAININGMODE__PICKUP : 26,
        TRAININGMODE__START : 27,
    }
    static { Object.freeze(this.StateId); }
    
    static StateIdCount = 28;
    static { Object.freeze(this.StateIdCount); }
    
    static Running_HistoryId = 
    {
        SETUPCHECK : 0, // default transition
        TRAININGMODE : 1,
        SORTINGMODE : 2,
        READEMPTYSLOT : 3,
        READJAMMEDSLOT : 4,
        READSLOT : 5,
        TRAININGMODE__START : 6,
        READEMPTYSLOT__DROPOFF : 7,
        READEMPTYSLOT__SENSOR : 8,
        READJAMMEDSLOT__DROPOFF : 9,
        JAMMED : 10,
        READJAMMEDSLOT__SENSOR : 11,
        READSLOT__DROPOFF : 12,
        TRAININGMODE__PICKUP : 13,
        READSLOT__SENSOR : 14,
        SORTINGMODE__DROPOFF : 15,
        SORTINGMODE__PICKUP : 16,
        SORTINGMODE__START : 17,
        SORTINGMODE__SENSOR : 18,
        TOUR : 19,
        SETUPCHECK__START : 20,
        ADJUSTSERVOOFFSETS : 21,
    }
    static { Object.freeze(this.Running_HistoryId); }

    
    // Used internally by state machine. Feel free to inspect, but don't modify.
    stateId;
    
    // Variables. Can be used for inputs, outputs, user variables...
    vars = {
        Running_history: undefined,
    };
    
    // Starts the state machine. Must be called before dispatching events. Not thread safe.
    start()
    {
        this._ROOT_enter();
        // ROOT behavior
        // uml: TransitionTo(ROOT.<InitialState>)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
            // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.
            
            // ROOT.<InitialState> behavior
            // uml: / { this.tracer?.edgeTransition('edge36'); } TransitionTo(Running)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.edgeTransition('edge36');`.
                this.tracer?.edgeTransition('edge36');
                
                // Step 3: Enter/move towards transition target `Running`.
                this._RUNNING_enter();
                
                // Finish transition by calling pseudo state transition function.
                this._Running_InitialState_transition();
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for ROOT.<InitialState>
        } // end of behavior for ROOT
    }
    
    // Dispatches an event to the state machine. Not thread safe.
    // Note! This function assumes that the `eventId` parameter is valid.
    dispatchEvent(eventId)
    {
        switch (this.stateId)
        {
            // STATE: BeadSorter
            case BeadSorter.StateId.ROOT:
                // No events handled by this state (or its ancestors).
                break;
            
            // STATE: Paused
            case BeadSorter.StateId.PAUSED:
                switch (eventId)
                {
                    case BeadSorter.EventId.BUTTON0: this._PAUSED_button0(); break;
                }
                break;
            
            // STATE: Running
            case BeadSorter.StateId.RUNNING:
                switch (eventId)
                {
                    case BeadSorter.EventId.BUTTON0: this._RUNNING_button0(); break;
                }
                break;
            
            // STATE: SetupCheck
            case BeadSorter.StateId.SETUPCHECK:
                switch (eventId)
                {
                    case BeadSorter.EventId.BUTTON0: this._RUNNING_button0(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: AdjustServoOffsets
            case BeadSorter.StateId.ADJUSTSERVOOFFSETS:
                switch (eventId)
                {
                    case BeadSorter.EventId.BUTTON2: this._ADJUSTSERVOOFFSETS_button2(); break;
                    case BeadSorter.EventId.BUTTON0: this._RUNNING_button0(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: DECREASE
            case BeadSorter.StateId.DECREASE:
                switch (eventId)
                {
                    case BeadSorter.EventId.DO: this._DECREASE_do(); break;
                    case BeadSorter.EventId.BUTTON0: this._RUNNING_button0(); break; // First ancestor handler for this event
                    case BeadSorter.EventId.BUTTON2: this._ADJUSTSERVOOFFSETS_button2(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: INCREASE
            case BeadSorter.StateId.INCREASE:
                switch (eventId)
                {
                    case BeadSorter.EventId.DO: this._INCREASE_do(); break;
                    case BeadSorter.EventId.BUTTON0: this._RUNNING_button0(); break; // First ancestor handler for this event
                    case BeadSorter.EventId.BUTTON2: this._ADJUSTSERVOOFFSETS_button2(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: Wait
            case BeadSorter.StateId.WAIT:
                switch (eventId)
                {
                    case BeadSorter.EventId.BUTTON1: this._WAIT_button1(); break;
                    case BeadSorter.EventId.BUTTON2: this._WAIT_button2(); break;
                    case BeadSorter.EventId.BUTTON0: this._RUNNING_button0(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: SetupCheck__Start
            case BeadSorter.StateId.SETUPCHECK__START:
                switch (eventId)
                {
                    case BeadSorter.EventId.DO: this._SETUPCHECK__START_do(); break;
                    case BeadSorter.EventId.BUTTON2: this._SETUPCHECK__START_button2(); break;
                    case BeadSorter.EventId.BUTTON0: this._RUNNING_button0(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: Tour
            case BeadSorter.StateId.TOUR:
                switch (eventId)
                {
                    case BeadSorter.EventId.DO: this._TOUR_do(); break;
                    case BeadSorter.EventId.BUTTON0: this._RUNNING_button0(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: SortingMode
            case BeadSorter.StateId.SORTINGMODE:
                switch (eventId)
                {
                    case BeadSorter.EventId.BUTTON0: this._RUNNING_button0(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: SortingMode__Dropoff
            case BeadSorter.StateId.SORTINGMODE__DROPOFF:
                switch (eventId)
                {
                    case BeadSorter.EventId.DO: this._SORTINGMODE__DROPOFF_do(); break;
                    case BeadSorter.EventId.BUTTON0: this._RUNNING_button0(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: SortingMode__Pickup
            case BeadSorter.StateId.SORTINGMODE__PICKUP:
                switch (eventId)
                {
                    case BeadSorter.EventId.DO: this._SORTINGMODE__PICKUP_do(); break;
                    case BeadSorter.EventId.BUTTON0: this._RUNNING_button0(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: SortingMode__Sensor
            case BeadSorter.StateId.SORTINGMODE__SENSOR:
                switch (eventId)
                {
                    case BeadSorter.EventId.DO: this._SORTINGMODE__SENSOR_do(); break;
                    case BeadSorter.EventId.BUTTON0: this._RUNNING_button0(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: SortingMode__Start
            case BeadSorter.StateId.SORTINGMODE__START:
                switch (eventId)
                {
                    case BeadSorter.EventId.DO: this._SORTINGMODE__START_do(); break;
                    case BeadSorter.EventId.BUTTON0: this._RUNNING_button0(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: TrainingMode
            case BeadSorter.StateId.TRAININGMODE:
                switch (eventId)
                {
                    case BeadSorter.EventId.BUTTON0: this._RUNNING_button0(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: ReadEmptySlot
            case BeadSorter.StateId.READEMPTYSLOT:
                switch (eventId)
                {
                    case BeadSorter.EventId.BUTTON0: this._RUNNING_button0(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: ReadEmptySlot__Dropoff
            case BeadSorter.StateId.READEMPTYSLOT__DROPOFF:
                switch (eventId)
                {
                    case BeadSorter.EventId.DO: this._READEMPTYSLOT__DROPOFF_do(); break;
                    case BeadSorter.EventId.BUTTON0: this._RUNNING_button0(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: ReadEmptySlot__Sensor
            case BeadSorter.StateId.READEMPTYSLOT__SENSOR:
                switch (eventId)
                {
                    case BeadSorter.EventId.DO: this._READEMPTYSLOT__SENSOR_do(); break;
                    case BeadSorter.EventId.BUTTON0: this._RUNNING_button0(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: ReadJammedSlot
            case BeadSorter.StateId.READJAMMEDSLOT:
                switch (eventId)
                {
                    case BeadSorter.EventId.BUTTON0: this._RUNNING_button0(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: Jammed
            case BeadSorter.StateId.JAMMED:
                switch (eventId)
                {
                    case BeadSorter.EventId.DO: this._JAMMED_do(); break;
                    case BeadSorter.EventId.BUTTON0: this._RUNNING_button0(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: ReadJammedSlot__Dropoff
            case BeadSorter.StateId.READJAMMEDSLOT__DROPOFF:
                switch (eventId)
                {
                    case BeadSorter.EventId.DO: this._READJAMMEDSLOT__DROPOFF_do(); break;
                    case BeadSorter.EventId.BUTTON0: this._RUNNING_button0(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: ReadJammedSlot__Sensor
            case BeadSorter.StateId.READJAMMEDSLOT__SENSOR:
                switch (eventId)
                {
                    case BeadSorter.EventId.DO: this._READJAMMEDSLOT__SENSOR_do(); break;
                    case BeadSorter.EventId.BUTTON0: this._RUNNING_button0(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: ReadSlot
            case BeadSorter.StateId.READSLOT:
                switch (eventId)
                {
                    case BeadSorter.EventId.BUTTON0: this._RUNNING_button0(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: ReadSlot__Dropoff
            case BeadSorter.StateId.READSLOT__DROPOFF:
                switch (eventId)
                {
                    case BeadSorter.EventId.DO: this._READSLOT__DROPOFF_do(); break;
                    case BeadSorter.EventId.BUTTON0: this._RUNNING_button0(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: ReadSlot__Sensor
            case BeadSorter.StateId.READSLOT__SENSOR:
                switch (eventId)
                {
                    case BeadSorter.EventId.DO: this._READSLOT__SENSOR_do(); break;
                    case BeadSorter.EventId.BUTTON0: this._RUNNING_button0(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: TrainingMode__Pickup
            case BeadSorter.StateId.TRAININGMODE__PICKUP:
                switch (eventId)
                {
                    case BeadSorter.EventId.DO: this._TRAININGMODE__PICKUP_do(); break;
                    case BeadSorter.EventId.BUTTON0: this._RUNNING_button0(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: TrainingMode__Start
            case BeadSorter.StateId.TRAININGMODE__START:
                switch (eventId)
                {
                    case BeadSorter.EventId.DO: this._TRAININGMODE__START_do(); break;
                    case BeadSorter.EventId.BUTTON0: this._RUNNING_button0(); break; // First ancestor handler for this event
                }
                break;
        }
        
    }
    
    // This function is used when StateSmith doesn't know what the active leaf state is at
    // compile time due to sub states or when multiple states need to be exited.
    _exitUpToStateHandler(desiredState)
    {
        while (this.stateId != desiredState)
        {
            switch (this.stateId)
            {
                case BeadSorter.StateId.PAUSED: this._PAUSED_exit(); break;
                
                case BeadSorter.StateId.RUNNING: this._RUNNING_exit(); break;
                
                case BeadSorter.StateId.SETUPCHECK: this._SETUPCHECK_exit(); break;
                
                case BeadSorter.StateId.ADJUSTSERVOOFFSETS: this._ADJUSTSERVOOFFSETS_exit(); break;
                
                case BeadSorter.StateId.DECREASE: this._DECREASE_exit(); break;
                
                case BeadSorter.StateId.INCREASE: this._INCREASE_exit(); break;
                
                case BeadSorter.StateId.WAIT: this._WAIT_exit(); break;
                
                case BeadSorter.StateId.SETUPCHECK__START: this._SETUPCHECK__START_exit(); break;
                
                case BeadSorter.StateId.TOUR: this._TOUR_exit(); break;
                
                case BeadSorter.StateId.SORTINGMODE: this._SORTINGMODE_exit(); break;
                
                case BeadSorter.StateId.SORTINGMODE__DROPOFF: this._SORTINGMODE__DROPOFF_exit(); break;
                
                case BeadSorter.StateId.SORTINGMODE__PICKUP: this._SORTINGMODE__PICKUP_exit(); break;
                
                case BeadSorter.StateId.SORTINGMODE__SENSOR: this._SORTINGMODE__SENSOR_exit(); break;
                
                case BeadSorter.StateId.SORTINGMODE__START: this._SORTINGMODE__START_exit(); break;
                
                case BeadSorter.StateId.TRAININGMODE: this._TRAININGMODE_exit(); break;
                
                case BeadSorter.StateId.READEMPTYSLOT: this._READEMPTYSLOT_exit(); break;
                
                case BeadSorter.StateId.READEMPTYSLOT__DROPOFF: this._READEMPTYSLOT__DROPOFF_exit(); break;
                
                case BeadSorter.StateId.READEMPTYSLOT__SENSOR: this._READEMPTYSLOT__SENSOR_exit(); break;
                
                case BeadSorter.StateId.READJAMMEDSLOT: this._READJAMMEDSLOT_exit(); break;
                
                case BeadSorter.StateId.JAMMED: this._JAMMED_exit(); break;
                
                case BeadSorter.StateId.READJAMMEDSLOT__DROPOFF: this._READJAMMEDSLOT__DROPOFF_exit(); break;
                
                case BeadSorter.StateId.READJAMMEDSLOT__SENSOR: this._READJAMMEDSLOT__SENSOR_exit(); break;
                
                case BeadSorter.StateId.READSLOT: this._READSLOT_exit(); break;
                
                case BeadSorter.StateId.READSLOT__DROPOFF: this._READSLOT__DROPOFF_exit(); break;
                
                case BeadSorter.StateId.READSLOT__SENSOR: this._READSLOT__SENSOR_exit(); break;
                
                case BeadSorter.StateId.TRAININGMODE__PICKUP: this._TRAININGMODE__PICKUP_exit(); break;
                
                case BeadSorter.StateId.TRAININGMODE__START: this._TRAININGMODE__START_exit(); break;
                
                default: return;  // Just to be safe. Prevents infinite loop if state ID memory is somehow corrupted.
            }
        }
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ROOT
    ////////////////////////////////////////////////////////////////////////////////
    
    _ROOT_enter()
    {
        this.stateId = BeadSorter.StateId.ROOT;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state PAUSED
    ////////////////////////////////////////////////////////////////////////////////
    
    _PAUSED_enter()
    {
        this.stateId = BeadSorter.StateId.PAUSED;
        
        // Paused behavior
        // uml: enter / { this.tracer?.enterState('Paused'); }
        {
            // Step 1: execute action `this.tracer?.enterState('Paused');`
            this.tracer?.enterState('Paused');
        } // end of behavior for Paused
    }
    
    _PAUSED_exit()
    {
        // Paused behavior
        // uml: exit / { this.tracer?.exitState('Paused'); }
        {
            // Step 1: execute action `this.tracer?.exitState('Paused');`
            this.tracer?.exitState('Paused');
        } // end of behavior for Paused
        
        this.stateId = BeadSorter.StateId.ROOT;
    }
    
    _PAUSED_button0()
    {
        // Paused behavior
        // uml: BUTTON0 / { this.tracer?.edgeTransition('edge35'); } TransitionTo(Running)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this._PAUSED_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge35');`.
            this.tracer?.edgeTransition('edge35');
            
            // Step 3: Enter/move towards transition target `Running`.
            this._RUNNING_enter();
            
            // Finish transition by calling pseudo state transition function.
            this._Running_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for Paused
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state RUNNING
    ////////////////////////////////////////////////////////////////////////////////
    
    _RUNNING_enter()
    {
        this.stateId = BeadSorter.StateId.RUNNING;
        
        // Running behavior
        // uml: enter / { this.tracer?.enterState('Running'); }
        {
            // Step 1: execute action `this.tracer?.enterState('Running');`
            this.tracer?.enterState('Running');
        } // end of behavior for Running
    }
    
    _RUNNING_exit()
    {
        // Running behavior
        // uml: exit / { this.tracer?.exitState('Running'); }
        {
            // Step 1: execute action `this.tracer?.exitState('Running');`
            this.tracer?.exitState('Running');
        } // end of behavior for Running
        
        this.stateId = BeadSorter.StateId.ROOT;
    }
    
    _RUNNING_button0()
    {
        // Running behavior
        // uml: BUTTON0 / { this.tracer?.edgeTransition('edge0'); } TransitionTo(Paused)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this._exitUpToStateHandler(BeadSorter.StateId.ROOT);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge0');`.
            this.tracer?.edgeTransition('edge0');
            
            // Step 3: Enter/move towards transition target `Paused`.
            this._PAUSED_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Running
        
        // No ancestor handles this event.
    }
    
    _Running_InitialState_transition()
    {
        // Running.<InitialState> behavior
        // uml: / { this.tracer?.edgeTransition('edge33'); } TransitionTo(Running.<History>)
        {
            // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge33');`.
            this.tracer?.edgeTransition('edge33');
            
            // Step 3: Enter/move towards transition target `Running.<History>`.
            // Running.<History> is a pseudo state and cannot have an `enter` trigger.
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.TRAININGMODE)] / { this.tracer?.logHistoryTransition('transitioning to TrainingMode'); } TransitionTo(TrainingMode)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.TRAININGMODE)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.logHistoryTransition('transitioning to TrainingMode');`.
                this.tracer?.logHistoryTransition('transitioning to TrainingMode');
                
                // Step 3: Enter/move towards transition target `TrainingMode`.
                this._TRAININGMODE_enter();
                
                // Finish transition by calling pseudo state transition function.
                this._TrainingMode_InitialState_transition();
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.SORTINGMODE)] / { this.tracer?.logHistoryTransition('transitioning to SortingMode'); } TransitionTo(SortingMode)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.SORTINGMODE)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.logHistoryTransition('transitioning to SortingMode');`.
                this.tracer?.logHistoryTransition('transitioning to SortingMode');
                
                // Step 3: Enter/move towards transition target `SortingMode`.
                this._SORTINGMODE_enter();
                
                // Finish transition by calling pseudo state transition function.
                this._SortingMode_InitialState_transition();
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.READEMPTYSLOT)] / { this.tracer?.logHistoryTransition('transitioning to ReadEmptySlot'); } TransitionTo(ReadEmptySlot)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.READEMPTYSLOT)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.logHistoryTransition('transitioning to ReadEmptySlot');`.
                this.tracer?.logHistoryTransition('transitioning to ReadEmptySlot');
                
                // Step 3: Enter/move towards transition target `ReadEmptySlot`.
                this._TRAININGMODE_enter();
                this._READEMPTYSLOT_enter();
                
                // Finish transition by calling pseudo state transition function.
                this._ReadEmptySlot_InitialState_transition();
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.READJAMMEDSLOT)] / { this.tracer?.logHistoryTransition('transitioning to ReadJammedSlot'); } TransitionTo(ReadJammedSlot)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.READJAMMEDSLOT)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.logHistoryTransition('transitioning to ReadJammedSlot');`.
                this.tracer?.logHistoryTransition('transitioning to ReadJammedSlot');
                
                // Step 3: Enter/move towards transition target `ReadJammedSlot`.
                this._TRAININGMODE_enter();
                this._READJAMMEDSLOT_enter();
                
                // Finish transition by calling pseudo state transition function.
                this._ReadJammedSlot_InitialState_transition();
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.READSLOT)] / { this.tracer?.logHistoryTransition('transitioning to ReadSlot'); } TransitionTo(ReadSlot)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.READSLOT)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.logHistoryTransition('transitioning to ReadSlot');`.
                this.tracer?.logHistoryTransition('transitioning to ReadSlot');
                
                // Step 3: Enter/move towards transition target `ReadSlot`.
                this._TRAININGMODE_enter();
                this._READSLOT_enter();
                
                // Finish transition by calling pseudo state transition function.
                this._ReadSlot_InitialState_transition();
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.TRAININGMODE__START)] / { this.tracer?.logHistoryTransition('transitioning to TrainingMode__Start'); } TransitionTo(TrainingMode__Start)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.TRAININGMODE__START)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.logHistoryTransition('transitioning to TrainingMode__Start');`.
                this.tracer?.logHistoryTransition('transitioning to TrainingMode__Start');
                
                // Step 3: Enter/move towards transition target `TrainingMode__Start`.
                this._TRAININGMODE_enter();
                this._TRAININGMODE__START_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.READEMPTYSLOT__DROPOFF)] / { this.tracer?.logHistoryTransition('transitioning to ReadEmptySlot__Dropoff'); } TransitionTo(ReadEmptySlot__Dropoff)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.READEMPTYSLOT__DROPOFF)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.logHistoryTransition('transitioning to ReadEmptySlot__Dropoff');`.
                this.tracer?.logHistoryTransition('transitioning to ReadEmptySlot__Dropoff');
                
                // Step 3: Enter/move towards transition target `ReadEmptySlot__Dropoff`.
                this._TRAININGMODE_enter();
                this._READEMPTYSLOT_enter();
                this._READEMPTYSLOT__DROPOFF_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.READEMPTYSLOT__SENSOR)] / { this.tracer?.logHistoryTransition('transitioning to ReadEmptySlot__Sensor'); } TransitionTo(ReadEmptySlot__Sensor)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.READEMPTYSLOT__SENSOR)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.logHistoryTransition('transitioning to ReadEmptySlot__Sensor');`.
                this.tracer?.logHistoryTransition('transitioning to ReadEmptySlot__Sensor');
                
                // Step 3: Enter/move towards transition target `ReadEmptySlot__Sensor`.
                this._TRAININGMODE_enter();
                this._READEMPTYSLOT_enter();
                this._READEMPTYSLOT__SENSOR_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.READJAMMEDSLOT__DROPOFF)] / { this.tracer?.logHistoryTransition('transitioning to ReadJammedSlot__Dropoff'); } TransitionTo(ReadJammedSlot__Dropoff)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.READJAMMEDSLOT__DROPOFF)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.logHistoryTransition('transitioning to ReadJammedSlot__Dropoff');`.
                this.tracer?.logHistoryTransition('transitioning to ReadJammedSlot__Dropoff');
                
                // Step 3: Enter/move towards transition target `ReadJammedSlot__Dropoff`.
                this._TRAININGMODE_enter();
                this._READJAMMEDSLOT_enter();
                this._READJAMMEDSLOT__DROPOFF_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.JAMMED)] / { this.tracer?.logHistoryTransition('transitioning to Jammed'); } TransitionTo(Jammed)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.JAMMED)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.logHistoryTransition('transitioning to Jammed');`.
                this.tracer?.logHistoryTransition('transitioning to Jammed');
                
                // Step 3: Enter/move towards transition target `Jammed`.
                this._TRAININGMODE_enter();
                this._READJAMMEDSLOT_enter();
                this._JAMMED_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.READJAMMEDSLOT__SENSOR)] / { this.tracer?.logHistoryTransition('transitioning to ReadJammedSlot__Sensor'); } TransitionTo(ReadJammedSlot__Sensor)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.READJAMMEDSLOT__SENSOR)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.logHistoryTransition('transitioning to ReadJammedSlot__Sensor');`.
                this.tracer?.logHistoryTransition('transitioning to ReadJammedSlot__Sensor');
                
                // Step 3: Enter/move towards transition target `ReadJammedSlot__Sensor`.
                this._TRAININGMODE_enter();
                this._READJAMMEDSLOT_enter();
                this._READJAMMEDSLOT__SENSOR_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.READSLOT__DROPOFF)] / { this.tracer?.logHistoryTransition('transitioning to ReadSlot__Dropoff'); } TransitionTo(ReadSlot__Dropoff)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.READSLOT__DROPOFF)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.logHistoryTransition('transitioning to ReadSlot__Dropoff');`.
                this.tracer?.logHistoryTransition('transitioning to ReadSlot__Dropoff');
                
                // Step 3: Enter/move towards transition target `ReadSlot__Dropoff`.
                this._TRAININGMODE_enter();
                this._READSLOT_enter();
                this._READSLOT__DROPOFF_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.TRAININGMODE__PICKUP)] / { this.tracer?.logHistoryTransition('transitioning to TrainingMode__Pickup'); } TransitionTo(TrainingMode__Pickup)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.TRAININGMODE__PICKUP)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.logHistoryTransition('transitioning to TrainingMode__Pickup');`.
                this.tracer?.logHistoryTransition('transitioning to TrainingMode__Pickup');
                
                // Step 3: Enter/move towards transition target `TrainingMode__Pickup`.
                this._TRAININGMODE_enter();
                this._READSLOT_enter();
                this._TRAININGMODE__PICKUP_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.READSLOT__SENSOR)] / { this.tracer?.logHistoryTransition('transitioning to ReadSlot__Sensor'); } TransitionTo(ReadSlot__Sensor)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.READSLOT__SENSOR)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.logHistoryTransition('transitioning to ReadSlot__Sensor');`.
                this.tracer?.logHistoryTransition('transitioning to ReadSlot__Sensor');
                
                // Step 3: Enter/move towards transition target `ReadSlot__Sensor`.
                this._TRAININGMODE_enter();
                this._READSLOT_enter();
                this._READSLOT__SENSOR_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.SORTINGMODE__DROPOFF)] / { this.tracer?.logHistoryTransition('transitioning to SortingMode__Dropoff'); } TransitionTo(SortingMode__Dropoff)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.SORTINGMODE__DROPOFF)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.logHistoryTransition('transitioning to SortingMode__Dropoff');`.
                this.tracer?.logHistoryTransition('transitioning to SortingMode__Dropoff');
                
                // Step 3: Enter/move towards transition target `SortingMode__Dropoff`.
                this._SORTINGMODE_enter();
                this._SORTINGMODE__DROPOFF_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.SORTINGMODE__PICKUP)] / { this.tracer?.logHistoryTransition('transitioning to SortingMode__Pickup'); } TransitionTo(SortingMode__Pickup)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.SORTINGMODE__PICKUP)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.logHistoryTransition('transitioning to SortingMode__Pickup');`.
                this.tracer?.logHistoryTransition('transitioning to SortingMode__Pickup');
                
                // Step 3: Enter/move towards transition target `SortingMode__Pickup`.
                this._SORTINGMODE_enter();
                this._SORTINGMODE__PICKUP_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.SORTINGMODE__START)] / { this.tracer?.logHistoryTransition('transitioning to SortingMode__Start'); } TransitionTo(SortingMode__Start)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.SORTINGMODE__START)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.logHistoryTransition('transitioning to SortingMode__Start');`.
                this.tracer?.logHistoryTransition('transitioning to SortingMode__Start');
                
                // Step 3: Enter/move towards transition target `SortingMode__Start`.
                this._SORTINGMODE_enter();
                this._SORTINGMODE__START_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.SORTINGMODE__SENSOR)] / { this.tracer?.logHistoryTransition('transitioning to SortingMode__Sensor'); } TransitionTo(SortingMode__Sensor)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.SORTINGMODE__SENSOR)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.logHistoryTransition('transitioning to SortingMode__Sensor');`.
                this.tracer?.logHistoryTransition('transitioning to SortingMode__Sensor');
                
                // Step 3: Enter/move towards transition target `SortingMode__Sensor`.
                this._SORTINGMODE_enter();
                this._SORTINGMODE__SENSOR_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.TOUR)] / { this.tracer?.logHistoryTransition('transitioning to Tour'); } TransitionTo(Tour)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.TOUR)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.logHistoryTransition('transitioning to Tour');`.
                this.tracer?.logHistoryTransition('transitioning to Tour');
                
                // Step 3: Enter/move towards transition target `Tour`.
                this._SETUPCHECK_enter();
                this._TOUR_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.SETUPCHECK__START)] / { this.tracer?.logHistoryTransition('transitioning to SetupCheck__Start'); } TransitionTo(SetupCheck__Start)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.SETUPCHECK__START)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.logHistoryTransition('transitioning to SetupCheck__Start');`.
                this.tracer?.logHistoryTransition('transitioning to SetupCheck__Start');
                
                // Step 3: Enter/move towards transition target `SetupCheck__Start`.
                this._SETUPCHECK_enter();
                this._SETUPCHECK__START_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: [$gil(this.vars.Running_history == Running_HistoryId.ADJUSTSERVOOFFSETS)] / { this.tracer?.logHistoryTransition('transitioning to AdjustServoOffsets'); } TransitionTo(AdjustServoOffsets)
            if (this.vars.Running_history == BeadSorter.Running_HistoryId.ADJUSTSERVOOFFSETS)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.logHistoryTransition('transitioning to AdjustServoOffsets');`.
                this.tracer?.logHistoryTransition('transitioning to AdjustServoOffsets');
                
                // Step 3: Enter/move towards transition target `AdjustServoOffsets`.
                this._SETUPCHECK_enter();
                this._ADJUSTSERVOOFFSETS_enter();
                
                // Finish transition by calling pseudo state transition function.
                this._AdjustServoOffsets_InitialState_transition();
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for Running.<History>
            
            // Running.<History> behavior
            // uml: else / { this.tracer?.logHistoryTransition('default transition');this.tracer?.edgeTransition('edge34'); } TransitionTo(SetupCheck)
            {
                // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.logHistoryTransition('default transition');this.tracer?.edgeTransition('edge34');`.
                this.tracer?.logHistoryTransition('default transition');this.tracer?.edgeTransition('edge34');
                
                // Step 3: Enter/move towards transition target `SetupCheck`.
                this._SETUPCHECK_enter();
                
                // SetupCheck.<InitialState> behavior
                // uml: / { this.tracer?.edgeTransition('edge22'); } TransitionTo(SetupCheck__Start)
                {
                    // Step 1: Exit states until we reach `SetupCheck` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                    
                    // Step 2: Transition action: `this.tracer?.edgeTransition('edge22');`.
                    this.tracer?.edgeTransition('edge22');
                    
                    // Step 3: Enter/move towards transition target `SetupCheck__Start`.
                    this._SETUPCHECK__START_enter();
                    
                    // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                    return;
                } // end of behavior for SetupCheck.<InitialState>
            } // end of behavior for Running.<History>
        } // end of behavior for Running.<InitialState>
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state SETUPCHECK
    ////////////////////////////////////////////////////////////////////////////////
    
    _SETUPCHECK_enter()
    {
        this.stateId = BeadSorter.StateId.SETUPCHECK;
        
        // SetupCheck behavior
        // uml: enter / { this.tracer?.enterState('SetupCheck'); }
        {
            // Step 1: execute action `this.tracer?.enterState('SetupCheck');`
            this.tracer?.enterState('SetupCheck');
        } // end of behavior for SetupCheck
        
        // SetupCheck behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.SETUPCHECK;)this.tracer?.logHistoryVarUpdate('Running', 'SETUPCHECK'); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.SETUPCHECK;)this.tracer?.logHistoryVarUpdate('Running', 'SETUPCHECK');`
            this.vars.Running_history = BeadSorter.Running_HistoryId.SETUPCHECK;this.tracer?.logHistoryVarUpdate('Running', 'SETUPCHECK');
        } // end of behavior for SetupCheck
    }
    
    _SETUPCHECK_exit()
    {
        // SetupCheck behavior
        // uml: exit / { this.tracer?.exitState('SetupCheck'); }
        {
            // Step 1: execute action `this.tracer?.exitState('SetupCheck');`
            this.tracer?.exitState('SetupCheck');
        } // end of behavior for SetupCheck
        
        this.stateId = BeadSorter.StateId.RUNNING;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ADJUSTSERVOOFFSETS
    ////////////////////////////////////////////////////////////////////////////////
    
    _ADJUSTSERVOOFFSETS_enter()
    {
        this.stateId = BeadSorter.StateId.ADJUSTSERVOOFFSETS;
        
        // AdjustServoOffsets behavior
        // uml: enter / { this.tracer?.enterState('AdjustServoOffsets'); }
        {
            // Step 1: execute action `this.tracer?.enterState('AdjustServoOffsets');`
            this.tracer?.enterState('AdjustServoOffsets');
        } // end of behavior for AdjustServoOffsets
        
        // AdjustServoOffsets behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.ADJUSTSERVOOFFSETS;)this.tracer?.logHistoryVarUpdate('Running', 'ADJUSTSERVOOFFSETS'); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.ADJUSTSERVOOFFSETS;)this.tracer?.logHistoryVarUpdate('Running', 'ADJUSTSERVOOFFSETS');`
            this.vars.Running_history = BeadSorter.Running_HistoryId.ADJUSTSERVOOFFSETS;this.tracer?.logHistoryVarUpdate('Running', 'ADJUSTSERVOOFFSETS');
        } // end of behavior for AdjustServoOffsets
    }
    
    _ADJUSTSERVOOFFSETS_exit()
    {
        // AdjustServoOffsets behavior
        // uml: exit / { this.tracer?.exitState('AdjustServoOffsets'); }
        {
            // Step 1: execute action `this.tracer?.exitState('AdjustServoOffsets');`
            this.tracer?.exitState('AdjustServoOffsets');
        } // end of behavior for AdjustServoOffsets
        
        this.stateId = BeadSorter.StateId.SETUPCHECK;
    }
    
    _ADJUSTSERVOOFFSETS_button2()
    {
        // AdjustServoOffsets behavior
        // uml: BUTTON2 / { this.tracer?.edgeTransition('edge27'); } TransitionTo(SetupCheck__Start)
        {
            // Step 1: Exit states until we reach `SetupCheck` state (Least Common Ancestor for transition).
            this._exitUpToStateHandler(BeadSorter.StateId.SETUPCHECK);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge27');`.
            this.tracer?.edgeTransition('edge27');
            
            // Step 3: Enter/move towards transition target `SetupCheck__Start`.
            this._SETUPCHECK__START_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for AdjustServoOffsets
        
        // No ancestor handles this event.
    }
    
    _AdjustServoOffsets_InitialState_transition()
    {
        // AdjustServoOffsets.<InitialState> behavior
        // uml: / { this.tracer?.edgeTransition('edge32'); } TransitionTo(Wait)
        {
            // Step 1: Exit states until we reach `AdjustServoOffsets` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge32');`.
            this.tracer?.edgeTransition('edge32');
            
            // Step 3: Enter/move towards transition target `Wait`.
            this._WAIT_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for AdjustServoOffsets.<InitialState>
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state DECREASE
    ////////////////////////////////////////////////////////////////////////////////
    
    _DECREASE_enter()
    {
        this.stateId = BeadSorter.StateId.DECREASE;
        
        // DECREASE behavior
        // uml: enter / { this.tracer?.enterState('DECREASE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('DECREASE');`
            this.tracer?.enterState('DECREASE');
        } // end of behavior for DECREASE
        
        // DECREASE behavior
        // uml: enter / { this.tracer?.logActionCode("picker.adjustOffset(-2);"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("picker.adjustOffset(-2);");`
            this.tracer?.logActionCode("picker.adjustOffset(-2);");
        } // end of behavior for DECREASE
    }
    
    _DECREASE_exit()
    {
        // DECREASE behavior
        // uml: exit / { this.tracer?.exitState('DECREASE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('DECREASE');`
            this.tracer?.exitState('DECREASE');
        } // end of behavior for DECREASE
        
        this.stateId = BeadSorter.StateId.ADJUSTSERVOOFFSETS;
    }
    
    _DECREASE_do()
    {
        // DECREASE behavior
        // uml: do / { this.tracer?.edgeTransition('edge28'); } TransitionTo(Wait)
        {
            // Step 1: Exit states until we reach `AdjustServoOffsets` state (Least Common Ancestor for transition).
            this._DECREASE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge28');`.
            this.tracer?.edgeTransition('edge28');
            
            // Step 3: Enter/move towards transition target `Wait`.
            this._WAIT_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for DECREASE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state INCREASE
    ////////////////////////////////////////////////////////////////////////////////
    
    _INCREASE_enter()
    {
        this.stateId = BeadSorter.StateId.INCREASE;
        
        // INCREASE behavior
        // uml: enter / { this.tracer?.enterState('INCREASE'); }
        {
            // Step 1: execute action `this.tracer?.enterState('INCREASE');`
            this.tracer?.enterState('INCREASE');
        } // end of behavior for INCREASE
        
        // INCREASE behavior
        // uml: enter / { this.tracer?.logActionCode("picker.adjustOffset(2);"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("picker.adjustOffset(2);");`
            this.tracer?.logActionCode("picker.adjustOffset(2);");
        } // end of behavior for INCREASE
    }
    
    _INCREASE_exit()
    {
        // INCREASE behavior
        // uml: exit / { this.tracer?.exitState('INCREASE'); }
        {
            // Step 1: execute action `this.tracer?.exitState('INCREASE');`
            this.tracer?.exitState('INCREASE');
        } // end of behavior for INCREASE
        
        this.stateId = BeadSorter.StateId.ADJUSTSERVOOFFSETS;
    }
    
    _INCREASE_do()
    {
        // INCREASE behavior
        // uml: do / { this.tracer?.edgeTransition('edge29'); } TransitionTo(Wait)
        {
            // Step 1: Exit states until we reach `AdjustServoOffsets` state (Least Common Ancestor for transition).
            this._INCREASE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge29');`.
            this.tracer?.edgeTransition('edge29');
            
            // Step 3: Enter/move towards transition target `Wait`.
            this._WAIT_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for INCREASE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state WAIT
    ////////////////////////////////////////////////////////////////////////////////
    
    _WAIT_enter()
    {
        this.stateId = BeadSorter.StateId.WAIT;
        
        // Wait behavior
        // uml: enter / { this.tracer?.enterState('Wait'); }
        {
            // Step 1: execute action `this.tracer?.enterState('Wait');`
            this.tracer?.enterState('Wait');
        } // end of behavior for Wait
        
        // Wait behavior
        // uml: enter / { this.tracer?.logActionCode("picker.displayOffset();"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("picker.displayOffset();");`
            this.tracer?.logActionCode("picker.displayOffset();");
        } // end of behavior for Wait
    }
    
    _WAIT_exit()
    {
        // Wait behavior
        // uml: exit / { this.tracer?.exitState('Wait'); }
        {
            // Step 1: execute action `this.tracer?.exitState('Wait');`
            this.tracer?.exitState('Wait');
        } // end of behavior for Wait
        
        this.stateId = BeadSorter.StateId.ADJUSTSERVOOFFSETS;
    }
    
    _WAIT_button1()
    {
        // Wait behavior
        // uml: BUTTON1 / { this.tracer?.edgeTransition('edge30'); } TransitionTo(DECREASE)
        {
            // Step 1: Exit states until we reach `AdjustServoOffsets` state (Least Common Ancestor for transition).
            this._WAIT_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge30');`.
            this.tracer?.edgeTransition('edge30');
            
            // Step 3: Enter/move towards transition target `DECREASE`.
            this._DECREASE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Wait
        
        // No ancestor handles this event.
    }
    
    _WAIT_button2()
    {
        let consume_event = false;
        
        // Wait behavior
        // uml: BUTTON2 / { this.tracer?.edgeTransition('edge31'); } TransitionTo(INCREASE)
        {
            // Step 1: Exit states until we reach `AdjustServoOffsets` state (Least Common Ancestor for transition).
            this._WAIT_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge31');`.
            this.tracer?.edgeTransition('edge31');
            
            // Step 3: Enter/move towards transition target `INCREASE`.
            this._INCREASE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Wait
        
        // Check if event has been consumed before calling ancestor handler.
        if (!consume_event)
        {
            this._ADJUSTSERVOOFFSETS_button2();
        }
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state SETUPCHECK__START
    ////////////////////////////////////////////////////////////////////////////////
    
    _SETUPCHECK__START_enter()
    {
        this.stateId = BeadSorter.StateId.SETUPCHECK__START;
        
        // SetupCheck__Start behavior
        // uml: enter / { this.tracer?.enterState('SetupCheck__Start'); }
        {
            // Step 1: execute action `this.tracer?.enterState('SetupCheck__Start');`
            this.tracer?.enterState('SetupCheck__Start');
        } // end of behavior for SetupCheck__Start
        
        // SetupCheck__Start behavior
        // uml: enter / { this.tracer?.logActionCode("modeDisplay.print(\"SETUP CHECK\");\nsorter.moveTo(0);\npicker.moveTo(DEG_DROPOFF);\npicker.moveTo(DEG_PICKUP);\nt1Restart();"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("modeDisplay.print(\"SETUP CHECK\");\nsorter.moveTo(0);\npicker.moveTo(DEG_DROPOFF);\npicker.moveTo(DEG_PICKUP);\nt1Restart();");`
            this.tracer?.logActionCode("modeDisplay.print(\"SETUP CHECK\");\nsorter.moveTo(0);\npicker.moveTo(DEG_DROPOFF);\npicker.moveTo(DEG_PICKUP);\nt1Restart();");
        } // end of behavior for SetupCheck__Start
        
        // SetupCheck__Start behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.SETUPCHECK__START;)this.tracer?.logHistoryVarUpdate('Running', 'SETUPCHECK__START'); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.SETUPCHECK__START;)this.tracer?.logHistoryVarUpdate('Running', 'SETUPCHECK__START');`
            this.vars.Running_history = BeadSorter.Running_HistoryId.SETUPCHECK__START;this.tracer?.logHistoryVarUpdate('Running', 'SETUPCHECK__START');
        } // end of behavior for SetupCheck__Start
    }
    
    _SETUPCHECK__START_exit()
    {
        // SetupCheck__Start behavior
        // uml: exit / { this.tracer?.exitState('SetupCheck__Start'); }
        {
            // Step 1: execute action `this.tracer?.exitState('SetupCheck__Start');`
            this.tracer?.exitState('SetupCheck__Start');
        } // end of behavior for SetupCheck__Start
        
        this.stateId = BeadSorter.StateId.SETUPCHECK;
    }
    
    _SETUPCHECK__START_button2()
    {
        // SetupCheck__Start behavior
        // uml: BUTTON2 / { this.tracer?.edgeTransition('edge26'); } TransitionTo(AdjustServoOffsets)
        {
            // Step 1: Exit states until we reach `SetupCheck` state (Least Common Ancestor for transition).
            this._SETUPCHECK__START_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge26');`.
            this.tracer?.edgeTransition('edge26');
            
            // Step 3: Enter/move towards transition target `AdjustServoOffsets`.
            this._ADJUSTSERVOOFFSETS_enter();
            
            // Finish transition by calling pseudo state transition function.
            this._AdjustServoOffsets_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for SetupCheck__Start
        
        // No ancestor handles this event.
    }
    
    _SETUPCHECK__START_do()
    {
        // SetupCheck__Start behavior
        // uml: do [this.tracer?.logGuardCodeEvaluation("t1After(3s)") || this.evaluateGuard('SetupCheck__Start', "do [t1After(3s)] TransitionTo(Tour)")] / { this.tracer?.edgeTransition('edge25'); } TransitionTo(Tour)
        if (this.tracer?.logGuardCodeEvaluation("t1After(3s)") || this.evaluateGuard('SetupCheck__Start', "do [t1After(3s)] TransitionTo(Tour)"))
        {
            // Step 1: Exit states until we reach `SetupCheck` state (Least Common Ancestor for transition).
            this._SETUPCHECK__START_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge25');`.
            this.tracer?.edgeTransition('edge25');
            
            // Step 3: Enter/move towards transition target `Tour`.
            this._TOUR_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for SetupCheck__Start
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state TOUR
    ////////////////////////////////////////////////////////////////////////////////
    
    _TOUR_enter()
    {
        this.stateId = BeadSorter.StateId.TOUR;
        
        // Tour behavior
        // uml: enter / { this.tracer?.enterState('Tour'); }
        {
            // Step 1: execute action `this.tracer?.enterState('Tour');`
            this.tracer?.enterState('Tour');
        } // end of behavior for Tour
        
        // Tour behavior
        // uml: enter / { this.tracer?.logActionCode("tourBin = min(tourBin+1, DEFAULT_BIN);\nsorter.moveTo(tourBin);"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("tourBin = min(tourBin+1, DEFAULT_BIN);\nsorter.moveTo(tourBin);");`
            this.tracer?.logActionCode("tourBin = min(tourBin+1, DEFAULT_BIN);\nsorter.moveTo(tourBin);");
        } // end of behavior for Tour
        
        // Tour behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.TOUR;)this.tracer?.logHistoryVarUpdate('Running', 'TOUR'); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.TOUR;)this.tracer?.logHistoryVarUpdate('Running', 'TOUR');`
            this.vars.Running_history = BeadSorter.Running_HistoryId.TOUR;this.tracer?.logHistoryVarUpdate('Running', 'TOUR');
        } // end of behavior for Tour
    }
    
    _TOUR_exit()
    {
        // Tour behavior
        // uml: exit / { this.tracer?.exitState('Tour'); }
        {
            // Step 1: execute action `this.tracer?.exitState('Tour');`
            this.tracer?.exitState('Tour');
        } // end of behavior for Tour
        
        this.stateId = BeadSorter.StateId.SETUPCHECK;
    }
    
    _TOUR_do()
    {
        // Tour behavior
        // uml: 1. do [this.tracer?.logGuardCodeEvaluation("tourBin>=DEFAULT_BIN") || this.evaluateGuard('Tour', "1. do [tourBin>=DEFAULT_BIN] TransitionTo(TrainingMode)")] / { this.tracer?.edgeTransition('edge23'); } TransitionTo(TrainingMode)
        if (this.tracer?.logGuardCodeEvaluation("tourBin>=DEFAULT_BIN") || this.evaluateGuard('Tour', "1. do [tourBin>=DEFAULT_BIN] TransitionTo(TrainingMode)"))
        {
            // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition).
            this._exitUpToStateHandler(BeadSorter.StateId.RUNNING);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge23');`.
            this.tracer?.edgeTransition('edge23');
            
            // Step 3: Enter/move towards transition target `TrainingMode`.
            this._TRAININGMODE_enter();
            
            // Finish transition by calling pseudo state transition function.
            this._TrainingMode_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for Tour
        
        // Tour behavior
        // uml: do [this.tracer?.logGuardCodeEvaluation("true") || this.evaluateGuard('Tour', "do [true] TransitionTo(Tour)")] / { this.tracer?.edgeTransition('edge24'); } TransitionTo(Tour)
        if (this.tracer?.logGuardCodeEvaluation("true") || this.evaluateGuard('Tour', "do [true] TransitionTo(Tour)"))
        {
            // Step 1: Exit states until we reach `SetupCheck` state (Least Common Ancestor for transition).
            this._TOUR_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge24');`.
            this.tracer?.edgeTransition('edge24');
            
            // Step 3: Enter/move towards transition target `Tour`.
            this._TOUR_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Tour
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state SORTINGMODE
    ////////////////////////////////////////////////////////////////////////////////
    
    _SORTINGMODE_enter()
    {
        this.stateId = BeadSorter.StateId.SORTINGMODE;
        
        // SortingMode behavior
        // uml: enter / { this.tracer?.enterState('SortingMode'); }
        {
            // Step 1: execute action `this.tracer?.enterState('SortingMode');`
            this.tracer?.enterState('SortingMode');
        } // end of behavior for SortingMode
        
        // SortingMode behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE;)this.tracer?.logHistoryVarUpdate('Running', 'SORTINGMODE'); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE;)this.tracer?.logHistoryVarUpdate('Running', 'SORTINGMODE');`
            this.vars.Running_history = BeadSorter.Running_HistoryId.SORTINGMODE;this.tracer?.logHistoryVarUpdate('Running', 'SORTINGMODE');
        } // end of behavior for SortingMode
    }
    
    _SORTINGMODE_exit()
    {
        // SortingMode behavior
        // uml: exit / { this.tracer?.exitState('SortingMode'); }
        {
            // Step 1: execute action `this.tracer?.exitState('SortingMode');`
            this.tracer?.exitState('SortingMode');
        } // end of behavior for SortingMode
        
        this.stateId = BeadSorter.StateId.RUNNING;
    }
    
    _SortingMode_InitialState_transition()
    {
        // SortingMode.<InitialState> behavior
        // uml: / { this.tracer?.edgeTransition('edge19'); } TransitionTo(SortingMode__Start)
        {
            // Step 1: Exit states until we reach `SortingMode` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge19');`.
            this.tracer?.edgeTransition('edge19');
            
            // Step 3: Enter/move towards transition target `SortingMode__Start`.
            this._SORTINGMODE__START_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for SortingMode.<InitialState>
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state SORTINGMODE__DROPOFF
    ////////////////////////////////////////////////////////////////////////////////
    
    _SORTINGMODE__DROPOFF_enter()
    {
        this.stateId = BeadSorter.StateId.SORTINGMODE__DROPOFF;
        
        // SortingMode__Dropoff behavior
        // uml: enter / { this.tracer?.enterState('SortingMode__Dropoff'); }
        {
            // Step 1: execute action `this.tracer?.enterState('SortingMode__Dropoff');`
            this.tracer?.enterState('SortingMode__Dropoff');
        } // end of behavior for SortingMode__Dropoff
        
        // SortingMode__Dropoff behavior
        // uml: enter / { this.tracer?.logActionCode("picker.moveToAndShimmy(DEG_DROPOFF);"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("picker.moveToAndShimmy(DEG_DROPOFF);");`
            this.tracer?.logActionCode("picker.moveToAndShimmy(DEG_DROPOFF);");
        } // end of behavior for SortingMode__Dropoff
        
        // SortingMode__Dropoff behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__DROPOFF;)this.tracer?.logHistoryVarUpdate('Running', 'SORTINGMODE__DROPOFF'); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__DROPOFF;)this.tracer?.logHistoryVarUpdate('Running', 'SORTINGMODE__DROPOFF');`
            this.vars.Running_history = BeadSorter.Running_HistoryId.SORTINGMODE__DROPOFF;this.tracer?.logHistoryVarUpdate('Running', 'SORTINGMODE__DROPOFF');
        } // end of behavior for SortingMode__Dropoff
    }
    
    _SORTINGMODE__DROPOFF_exit()
    {
        // SortingMode__Dropoff behavior
        // uml: exit / { this.tracer?.exitState('SortingMode__Dropoff'); }
        {
            // Step 1: execute action `this.tracer?.exitState('SortingMode__Dropoff');`
            this.tracer?.exitState('SortingMode__Dropoff');
        } // end of behavior for SortingMode__Dropoff
        
        this.stateId = BeadSorter.StateId.SORTINGMODE;
    }
    
    _SORTINGMODE__DROPOFF_do()
    {
        // SortingMode__Dropoff behavior
        // uml: do / { this.tracer?.edgeTransition('edge17'); } TransitionTo(SortingMode__Pickup)
        {
            // Step 1: Exit states until we reach `SortingMode` state (Least Common Ancestor for transition).
            this._SORTINGMODE__DROPOFF_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge17');`.
            this.tracer?.edgeTransition('edge17');
            
            // Step 3: Enter/move towards transition target `SortingMode__Pickup`.
            this._SORTINGMODE__PICKUP_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for SortingMode__Dropoff
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state SORTINGMODE__PICKUP
    ////////////////////////////////////////////////////////////////////////////////
    
    _SORTINGMODE__PICKUP_enter()
    {
        this.stateId = BeadSorter.StateId.SORTINGMODE__PICKUP;
        
        // SortingMode__Pickup behavior
        // uml: enter / { this.tracer?.enterState('SortingMode__Pickup'); }
        {
            // Step 1: execute action `this.tracer?.enterState('SortingMode__Pickup');`
            this.tracer?.enterState('SortingMode__Pickup');
        } // end of behavior for SortingMode__Pickup
        
        // SortingMode__Pickup behavior
        // uml: enter / { this.tracer?.logActionCode("picker.moveTo(DEG_PICKUP);"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("picker.moveTo(DEG_PICKUP);");`
            this.tracer?.logActionCode("picker.moveTo(DEG_PICKUP);");
        } // end of behavior for SortingMode__Pickup
        
        // SortingMode__Pickup behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__PICKUP;)this.tracer?.logHistoryVarUpdate('Running', 'SORTINGMODE__PICKUP'); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__PICKUP;)this.tracer?.logHistoryVarUpdate('Running', 'SORTINGMODE__PICKUP');`
            this.vars.Running_history = BeadSorter.Running_HistoryId.SORTINGMODE__PICKUP;this.tracer?.logHistoryVarUpdate('Running', 'SORTINGMODE__PICKUP');
        } // end of behavior for SortingMode__Pickup
    }
    
    _SORTINGMODE__PICKUP_exit()
    {
        // SortingMode__Pickup behavior
        // uml: exit / { this.tracer?.exitState('SortingMode__Pickup'); }
        {
            // Step 1: execute action `this.tracer?.exitState('SortingMode__Pickup');`
            this.tracer?.exitState('SortingMode__Pickup');
        } // end of behavior for SortingMode__Pickup
        
        this.stateId = BeadSorter.StateId.SORTINGMODE;
    }
    
    _SORTINGMODE__PICKUP_do()
    {
        // SortingMode__Pickup behavior
        // uml: do / { this.tracer?.edgeTransition('edge18'); } TransitionTo(SortingMode__Sensor)
        {
            // Step 1: Exit states until we reach `SortingMode` state (Least Common Ancestor for transition).
            this._SORTINGMODE__PICKUP_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge18');`.
            this.tracer?.edgeTransition('edge18');
            
            // Step 3: Enter/move towards transition target `SortingMode__Sensor`.
            this._SORTINGMODE__SENSOR_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for SortingMode__Pickup
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state SORTINGMODE__SENSOR
    ////////////////////////////////////////////////////////////////////////////////
    
    _SORTINGMODE__SENSOR_enter()
    {
        this.stateId = BeadSorter.StateId.SORTINGMODE__SENSOR;
        
        // SortingMode__Sensor behavior
        // uml: enter / { this.tracer?.enterState('SortingMode__Sensor'); }
        {
            // Step 1: execute action `this.tracer?.enterState('SortingMode__Sensor');`
            this.tracer?.enterState('SortingMode__Sensor');
        } // end of behavior for SortingMode__Sensor
        
        // SortingMode__Sensor behavior
        // uml: enter / { this.tracer?.logActionCode("picker.shimmyAndMoveTo(DEG_SENSOR);\nsorter.shimmyAndMoveTo(min(sorter.readColor(), DEFAULT_BIN));"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("picker.shimmyAndMoveTo(DEG_SENSOR);\nsorter.shimmyAndMoveTo(min(sorter.readColor(), DEFAULT_BIN));");`
            this.tracer?.logActionCode("picker.shimmyAndMoveTo(DEG_SENSOR);\nsorter.shimmyAndMoveTo(min(sorter.readColor(), DEFAULT_BIN));");
        } // end of behavior for SortingMode__Sensor
        
        // SortingMode__Sensor behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__SENSOR;)this.tracer?.logHistoryVarUpdate('Running', 'SORTINGMODE__SENSOR'); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__SENSOR;)this.tracer?.logHistoryVarUpdate('Running', 'SORTINGMODE__SENSOR');`
            this.vars.Running_history = BeadSorter.Running_HistoryId.SORTINGMODE__SENSOR;this.tracer?.logHistoryVarUpdate('Running', 'SORTINGMODE__SENSOR');
        } // end of behavior for SortingMode__Sensor
    }
    
    _SORTINGMODE__SENSOR_exit()
    {
        // SortingMode__Sensor behavior
        // uml: exit / { this.tracer?.exitState('SortingMode__Sensor'); }
        {
            // Step 1: execute action `this.tracer?.exitState('SortingMode__Sensor');`
            this.tracer?.exitState('SortingMode__Sensor');
        } // end of behavior for SortingMode__Sensor
        
        this.stateId = BeadSorter.StateId.SORTINGMODE;
    }
    
    _SORTINGMODE__SENSOR_do()
    {
        // SortingMode__Sensor behavior
        // uml: do / { this.tracer?.edgeTransition('edge21'); } TransitionTo(SortingMode__Dropoff)
        {
            // Step 1: Exit states until we reach `SortingMode` state (Least Common Ancestor for transition).
            this._SORTINGMODE__SENSOR_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge21');`.
            this.tracer?.edgeTransition('edge21');
            
            // Step 3: Enter/move towards transition target `SortingMode__Dropoff`.
            this._SORTINGMODE__DROPOFF_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for SortingMode__Sensor
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state SORTINGMODE__START
    ////////////////////////////////////////////////////////////////////////////////
    
    _SORTINGMODE__START_enter()
    {
        this.stateId = BeadSorter.StateId.SORTINGMODE__START;
        
        // SortingMode__Start behavior
        // uml: enter / { this.tracer?.enterState('SortingMode__Start'); }
        {
            // Step 1: execute action `this.tracer?.enterState('SortingMode__Start');`
            this.tracer?.enterState('SortingMode__Start');
        } // end of behavior for SortingMode__Start
        
        // SortingMode__Start behavior
        // uml: enter / { this.tracer?.logActionCode("modeDisplay.clear();"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("modeDisplay.clear();");`
            this.tracer?.logActionCode("modeDisplay.clear();");
        } // end of behavior for SortingMode__Start
        
        // SortingMode__Start behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__START;)this.tracer?.logHistoryVarUpdate('Running', 'SORTINGMODE__START'); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__START;)this.tracer?.logHistoryVarUpdate('Running', 'SORTINGMODE__START');`
            this.vars.Running_history = BeadSorter.Running_HistoryId.SORTINGMODE__START;this.tracer?.logHistoryVarUpdate('Running', 'SORTINGMODE__START');
        } // end of behavior for SortingMode__Start
    }
    
    _SORTINGMODE__START_exit()
    {
        // SortingMode__Start behavior
        // uml: exit / { this.tracer?.exitState('SortingMode__Start'); }
        {
            // Step 1: execute action `this.tracer?.exitState('SortingMode__Start');`
            this.tracer?.exitState('SortingMode__Start');
        } // end of behavior for SortingMode__Start
        
        this.stateId = BeadSorter.StateId.SORTINGMODE;
    }
    
    _SORTINGMODE__START_do()
    {
        // SortingMode__Start behavior
        // uml: do / { this.tracer?.edgeTransition('edge20'); } TransitionTo(SortingMode__Pickup)
        {
            // Step 1: Exit states until we reach `SortingMode` state (Least Common Ancestor for transition).
            this._SORTINGMODE__START_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge20');`.
            this.tracer?.edgeTransition('edge20');
            
            // Step 3: Enter/move towards transition target `SortingMode__Pickup`.
            this._SORTINGMODE__PICKUP_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for SortingMode__Start
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state TRAININGMODE
    ////////////////////////////////////////////////////////////////////////////////
    
    _TRAININGMODE_enter()
    {
        this.stateId = BeadSorter.StateId.TRAININGMODE;
        
        // TrainingMode behavior
        // uml: enter / { this.tracer?.enterState('TrainingMode'); }
        {
            // Step 1: execute action `this.tracer?.enterState('TrainingMode');`
            this.tracer?.enterState('TrainingMode');
        } // end of behavior for TrainingMode
        
        // TrainingMode behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.TRAININGMODE;)this.tracer?.logHistoryVarUpdate('Running', 'TRAININGMODE'); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.TRAININGMODE;)this.tracer?.logHistoryVarUpdate('Running', 'TRAININGMODE');`
            this.vars.Running_history = BeadSorter.Running_HistoryId.TRAININGMODE;this.tracer?.logHistoryVarUpdate('Running', 'TRAININGMODE');
        } // end of behavior for TrainingMode
    }
    
    _TRAININGMODE_exit()
    {
        // TrainingMode behavior
        // uml: exit / { this.tracer?.exitState('TrainingMode'); }
        {
            // Step 1: execute action `this.tracer?.exitState('TrainingMode');`
            this.tracer?.exitState('TrainingMode');
        } // end of behavior for TrainingMode
        
        this.stateId = BeadSorter.StateId.RUNNING;
    }
    
    _TrainingMode_InitialState_transition()
    {
        // TrainingMode.<InitialState> behavior
        // uml: / { this.tracer?.edgeTransition('edge16'); } TransitionTo(TrainingMode__Start)
        {
            // Step 1: Exit states until we reach `TrainingMode` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge16');`.
            this.tracer?.edgeTransition('edge16');
            
            // Step 3: Enter/move towards transition target `TrainingMode__Start`.
            this._TRAININGMODE__START_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for TrainingMode.<InitialState>
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state READEMPTYSLOT
    ////////////////////////////////////////////////////////////////////////////////
    
    _READEMPTYSLOT_enter()
    {
        this.stateId = BeadSorter.StateId.READEMPTYSLOT;
        
        // ReadEmptySlot behavior
        // uml: enter / { this.tracer?.enterState('ReadEmptySlot'); }
        {
            // Step 1: execute action `this.tracer?.enterState('ReadEmptySlot');`
            this.tracer?.enterState('ReadEmptySlot');
        } // end of behavior for ReadEmptySlot
        
        // ReadEmptySlot behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.READEMPTYSLOT;)this.tracer?.logHistoryVarUpdate('Running', 'READEMPTYSLOT'); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.READEMPTYSLOT;)this.tracer?.logHistoryVarUpdate('Running', 'READEMPTYSLOT');`
            this.vars.Running_history = BeadSorter.Running_HistoryId.READEMPTYSLOT;this.tracer?.logHistoryVarUpdate('Running', 'READEMPTYSLOT');
        } // end of behavior for ReadEmptySlot
    }
    
    _READEMPTYSLOT_exit()
    {
        // ReadEmptySlot behavior
        // uml: exit / { this.tracer?.exitState('ReadEmptySlot'); }
        {
            // Step 1: execute action `this.tracer?.exitState('ReadEmptySlot');`
            this.tracer?.exitState('ReadEmptySlot');
        } // end of behavior for ReadEmptySlot
        
        this.stateId = BeadSorter.StateId.TRAININGMODE;
    }
    
    _ReadEmptySlot_InitialState_transition()
    {
        // ReadEmptySlot.<InitialState> behavior
        // uml: / { this.tracer?.edgeTransition('edge1'); } TransitionTo(ReadEmptySlot__Dropoff)
        {
            // Step 1: Exit states until we reach `ReadEmptySlot` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge1');`.
            this.tracer?.edgeTransition('edge1');
            
            // Step 3: Enter/move towards transition target `ReadEmptySlot__Dropoff`.
            this._READEMPTYSLOT__DROPOFF_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ReadEmptySlot.<InitialState>
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state READEMPTYSLOT__DROPOFF
    ////////////////////////////////////////////////////////////////////////////////
    
    _READEMPTYSLOT__DROPOFF_enter()
    {
        this.stateId = BeadSorter.StateId.READEMPTYSLOT__DROPOFF;
        
        // ReadEmptySlot__Dropoff behavior
        // uml: enter / { this.tracer?.enterState('ReadEmptySlot__Dropoff'); }
        {
            // Step 1: execute action `this.tracer?.enterState('ReadEmptySlot__Dropoff');`
            this.tracer?.enterState('ReadEmptySlot__Dropoff');
        } // end of behavior for ReadEmptySlot__Dropoff
        
        // ReadEmptySlot__Dropoff behavior
        // uml: enter / { this.tracer?.logActionCode("picker.moveToAndShimmy(DEG_DROPOFF);"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("picker.moveToAndShimmy(DEG_DROPOFF);");`
            this.tracer?.logActionCode("picker.moveToAndShimmy(DEG_DROPOFF);");
        } // end of behavior for ReadEmptySlot__Dropoff
        
        // ReadEmptySlot__Dropoff behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.READEMPTYSLOT__DROPOFF;)this.tracer?.logHistoryVarUpdate('Running', 'READEMPTYSLOT__DROPOFF'); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.READEMPTYSLOT__DROPOFF;)this.tracer?.logHistoryVarUpdate('Running', 'READEMPTYSLOT__DROPOFF');`
            this.vars.Running_history = BeadSorter.Running_HistoryId.READEMPTYSLOT__DROPOFF;this.tracer?.logHistoryVarUpdate('Running', 'READEMPTYSLOT__DROPOFF');
        } // end of behavior for ReadEmptySlot__Dropoff
    }
    
    _READEMPTYSLOT__DROPOFF_exit()
    {
        // ReadEmptySlot__Dropoff behavior
        // uml: exit / { this.tracer?.exitState('ReadEmptySlot__Dropoff'); }
        {
            // Step 1: execute action `this.tracer?.exitState('ReadEmptySlot__Dropoff');`
            this.tracer?.exitState('ReadEmptySlot__Dropoff');
        } // end of behavior for ReadEmptySlot__Dropoff
        
        this.stateId = BeadSorter.StateId.READEMPTYSLOT;
    }
    
    _READEMPTYSLOT__DROPOFF_do()
    {
        // ReadEmptySlot__Dropoff behavior
        // uml: do / { this.tracer?.edgeTransition('edge2'); } TransitionTo(ReadEmptySlot__Sensor)
        {
            // Step 1: Exit states until we reach `ReadEmptySlot` state (Least Common Ancestor for transition).
            this._READEMPTYSLOT__DROPOFF_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge2');`.
            this.tracer?.edgeTransition('edge2');
            
            // Step 3: Enter/move towards transition target `ReadEmptySlot__Sensor`.
            this._READEMPTYSLOT__SENSOR_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ReadEmptySlot__Dropoff
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state READEMPTYSLOT__SENSOR
    ////////////////////////////////////////////////////////////////////////////////
    
    _READEMPTYSLOT__SENSOR_enter()
    {
        this.stateId = BeadSorter.StateId.READEMPTYSLOT__SENSOR;
        
        // ReadEmptySlot__Sensor behavior
        // uml: enter / { this.tracer?.enterState('ReadEmptySlot__Sensor'); }
        {
            // Step 1: execute action `this.tracer?.enterState('ReadEmptySlot__Sensor');`
            this.tracer?.enterState('ReadEmptySlot__Sensor');
        } // end of behavior for ReadEmptySlot__Sensor
        
        // ReadEmptySlot__Sensor behavior
        // uml: enter / { this.tracer?.logActionCode("picker.moveTo(DEG_SENSOR);\nempties++;\nsorter.readColor();"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("picker.moveTo(DEG_SENSOR);\nempties++;\nsorter.readColor();");`
            this.tracer?.logActionCode("picker.moveTo(DEG_SENSOR);\nempties++;\nsorter.readColor();");
        } // end of behavior for ReadEmptySlot__Sensor
        
        // ReadEmptySlot__Sensor behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.READEMPTYSLOT__SENSOR;)this.tracer?.logHistoryVarUpdate('Running', 'READEMPTYSLOT__SENSOR'); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.READEMPTYSLOT__SENSOR;)this.tracer?.logHistoryVarUpdate('Running', 'READEMPTYSLOT__SENSOR');`
            this.vars.Running_history = BeadSorter.Running_HistoryId.READEMPTYSLOT__SENSOR;this.tracer?.logHistoryVarUpdate('Running', 'READEMPTYSLOT__SENSOR');
        } // end of behavior for ReadEmptySlot__Sensor
    }
    
    _READEMPTYSLOT__SENSOR_exit()
    {
        // ReadEmptySlot__Sensor behavior
        // uml: exit / { this.tracer?.exitState('ReadEmptySlot__Sensor'); }
        {
            // Step 1: execute action `this.tracer?.exitState('ReadEmptySlot__Sensor');`
            this.tracer?.exitState('ReadEmptySlot__Sensor');
        } // end of behavior for ReadEmptySlot__Sensor
        
        this.stateId = BeadSorter.StateId.READEMPTYSLOT;
    }
    
    _READEMPTYSLOT__SENSOR_do()
    {
        // ReadEmptySlot__Sensor behavior
        // uml: 1. do [this.tracer?.logGuardCodeEvaluation("empties>=NUM_EMPTY_READS") || this.evaluateGuard('ReadEmptySlot__Sensor', "1. do [empties>=NUM_EMPTY_READS] TransitionTo(ReadJammedSlot)")] / { this.tracer?.edgeTransition('edge4'); } TransitionTo(ReadJammedSlot)
        if (this.tracer?.logGuardCodeEvaluation("empties>=NUM_EMPTY_READS") || this.evaluateGuard('ReadEmptySlot__Sensor', "1. do [empties>=NUM_EMPTY_READS] TransitionTo(ReadJammedSlot)"))
        {
            // Step 1: Exit states until we reach `TrainingMode` state (Least Common Ancestor for transition).
            this._exitUpToStateHandler(BeadSorter.StateId.TRAININGMODE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge4');`.
            this.tracer?.edgeTransition('edge4');
            
            // Step 3: Enter/move towards transition target `ReadJammedSlot`.
            this._READJAMMEDSLOT_enter();
            
            // Finish transition by calling pseudo state transition function.
            this._ReadJammedSlot_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for ReadEmptySlot__Sensor
        
        // ReadEmptySlot__Sensor behavior
        // uml: do / { this.tracer?.edgeTransition('edge3'); } TransitionTo(ReadEmptySlot__Dropoff)
        {
            // Step 1: Exit states until we reach `ReadEmptySlot` state (Least Common Ancestor for transition).
            this._READEMPTYSLOT__SENSOR_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge3');`.
            this.tracer?.edgeTransition('edge3');
            
            // Step 3: Enter/move towards transition target `ReadEmptySlot__Dropoff`.
            this._READEMPTYSLOT__DROPOFF_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ReadEmptySlot__Sensor
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state READJAMMEDSLOT
    ////////////////////////////////////////////////////////////////////////////////
    
    _READJAMMEDSLOT_enter()
    {
        this.stateId = BeadSorter.StateId.READJAMMEDSLOT;
        
        // ReadJammedSlot behavior
        // uml: enter / { this.tracer?.enterState('ReadJammedSlot'); }
        {
            // Step 1: execute action `this.tracer?.enterState('ReadJammedSlot');`
            this.tracer?.enterState('ReadJammedSlot');
        } // end of behavior for ReadJammedSlot
        
        // ReadJammedSlot behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.READJAMMEDSLOT;)this.tracer?.logHistoryVarUpdate('Running', 'READJAMMEDSLOT'); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.READJAMMEDSLOT;)this.tracer?.logHistoryVarUpdate('Running', 'READJAMMEDSLOT');`
            this.vars.Running_history = BeadSorter.Running_HistoryId.READJAMMEDSLOT;this.tracer?.logHistoryVarUpdate('Running', 'READJAMMEDSLOT');
        } // end of behavior for ReadJammedSlot
    }
    
    _READJAMMEDSLOT_exit()
    {
        // ReadJammedSlot behavior
        // uml: exit / { this.tracer?.exitState('ReadJammedSlot'); }
        {
            // Step 1: execute action `this.tracer?.exitState('ReadJammedSlot');`
            this.tracer?.exitState('ReadJammedSlot');
        } // end of behavior for ReadJammedSlot
        
        this.stateId = BeadSorter.StateId.TRAININGMODE;
    }
    
    _ReadJammedSlot_InitialState_transition()
    {
        // ReadJammedSlot.<InitialState> behavior
        // uml: / { this.tracer?.edgeTransition('edge5'); } TransitionTo(Jammed)
        {
            // Step 1: Exit states until we reach `ReadJammedSlot` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge5');`.
            this.tracer?.edgeTransition('edge5');
            
            // Step 3: Enter/move towards transition target `Jammed`.
            this._JAMMED_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ReadJammedSlot.<InitialState>
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state JAMMED
    ////////////////////////////////////////////////////////////////////////////////
    
    _JAMMED_enter()
    {
        this.stateId = BeadSorter.StateId.JAMMED;
        
        // Jammed behavior
        // uml: enter / { this.tracer?.enterState('Jammed'); }
        {
            // Step 1: execute action `this.tracer?.enterState('Jammed');`
            this.tracer?.enterState('Jammed');
        } // end of behavior for Jammed
        
        // Jammed behavior
        // uml: enter / { this.tracer?.logActionCode("picker.moveTo(DEG_JAMMED_READ);"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("picker.moveTo(DEG_JAMMED_READ);");`
            this.tracer?.logActionCode("picker.moveTo(DEG_JAMMED_READ);");
        } // end of behavior for Jammed
        
        // Jammed behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.JAMMED;)this.tracer?.logHistoryVarUpdate('Running', 'JAMMED'); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.JAMMED;)this.tracer?.logHistoryVarUpdate('Running', 'JAMMED');`
            this.vars.Running_history = BeadSorter.Running_HistoryId.JAMMED;this.tracer?.logHistoryVarUpdate('Running', 'JAMMED');
        } // end of behavior for Jammed
    }
    
    _JAMMED_exit()
    {
        // Jammed behavior
        // uml: exit / { this.tracer?.exitState('Jammed'); }
        {
            // Step 1: execute action `this.tracer?.exitState('Jammed');`
            this.tracer?.exitState('Jammed');
        } // end of behavior for Jammed
        
        this.stateId = BeadSorter.StateId.READJAMMEDSLOT;
    }
    
    _JAMMED_do()
    {
        // Jammed behavior
        // uml: do / { this.tracer?.edgeTransition('edge8'); } TransitionTo(ReadJammedSlot__Sensor)
        {
            // Step 1: Exit states until we reach `ReadJammedSlot` state (Least Common Ancestor for transition).
            this._JAMMED_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge8');`.
            this.tracer?.edgeTransition('edge8');
            
            // Step 3: Enter/move towards transition target `ReadJammedSlot__Sensor`.
            this._READJAMMEDSLOT__SENSOR_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Jammed
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state READJAMMEDSLOT__DROPOFF
    ////////////////////////////////////////////////////////////////////////////////
    
    _READJAMMEDSLOT__DROPOFF_enter()
    {
        this.stateId = BeadSorter.StateId.READJAMMEDSLOT__DROPOFF;
        
        // ReadJammedSlot__Dropoff behavior
        // uml: enter / { this.tracer?.enterState('ReadJammedSlot__Dropoff'); }
        {
            // Step 1: execute action `this.tracer?.enterState('ReadJammedSlot__Dropoff');`
            this.tracer?.enterState('ReadJammedSlot__Dropoff');
        } // end of behavior for ReadJammedSlot__Dropoff
        
        // ReadJammedSlot__Dropoff behavior
        // uml: enter / { this.tracer?.logActionCode("picker.moveToAndShimmy(DEG_DROPOFF);"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("picker.moveToAndShimmy(DEG_DROPOFF);");`
            this.tracer?.logActionCode("picker.moveToAndShimmy(DEG_DROPOFF);");
        } // end of behavior for ReadJammedSlot__Dropoff
        
        // ReadJammedSlot__Dropoff behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.READJAMMEDSLOT__DROPOFF;)this.tracer?.logHistoryVarUpdate('Running', 'READJAMMEDSLOT__DROPOFF'); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.READJAMMEDSLOT__DROPOFF;)this.tracer?.logHistoryVarUpdate('Running', 'READJAMMEDSLOT__DROPOFF');`
            this.vars.Running_history = BeadSorter.Running_HistoryId.READJAMMEDSLOT__DROPOFF;this.tracer?.logHistoryVarUpdate('Running', 'READJAMMEDSLOT__DROPOFF');
        } // end of behavior for ReadJammedSlot__Dropoff
    }
    
    _READJAMMEDSLOT__DROPOFF_exit()
    {
        // ReadJammedSlot__Dropoff behavior
        // uml: exit / { this.tracer?.exitState('ReadJammedSlot__Dropoff'); }
        {
            // Step 1: execute action `this.tracer?.exitState('ReadJammedSlot__Dropoff');`
            this.tracer?.exitState('ReadJammedSlot__Dropoff');
        } // end of behavior for ReadJammedSlot__Dropoff
        
        this.stateId = BeadSorter.StateId.READJAMMEDSLOT;
    }
    
    _READJAMMEDSLOT__DROPOFF_do()
    {
        // ReadJammedSlot__Dropoff behavior
        // uml: 1. do [this.tracer?.logGuardCodeEvaluation("jammies>=NUM_JAMMED_READS") || this.evaluateGuard('ReadJammedSlot__Dropoff', "1. do [jammies>=NUM_JAMMED_READS] TransitionTo(ReadSlot)")] / { this.tracer?.edgeTransition('edge7'); } TransitionTo(ReadSlot)
        if (this.tracer?.logGuardCodeEvaluation("jammies>=NUM_JAMMED_READS") || this.evaluateGuard('ReadJammedSlot__Dropoff', "1. do [jammies>=NUM_JAMMED_READS] TransitionTo(ReadSlot)"))
        {
            // Step 1: Exit states until we reach `TrainingMode` state (Least Common Ancestor for transition).
            this._exitUpToStateHandler(BeadSorter.StateId.TRAININGMODE);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge7');`.
            this.tracer?.edgeTransition('edge7');
            
            // Step 3: Enter/move towards transition target `ReadSlot`.
            this._READSLOT_enter();
            
            // Finish transition by calling pseudo state transition function.
            this._ReadSlot_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for ReadJammedSlot__Dropoff
        
        // ReadJammedSlot__Dropoff behavior
        // uml: do / { this.tracer?.edgeTransition('edge6'); } TransitionTo(Jammed)
        {
            // Step 1: Exit states until we reach `ReadJammedSlot` state (Least Common Ancestor for transition).
            this._READJAMMEDSLOT__DROPOFF_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge6');`.
            this.tracer?.edgeTransition('edge6');
            
            // Step 3: Enter/move towards transition target `Jammed`.
            this._JAMMED_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ReadJammedSlot__Dropoff
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state READJAMMEDSLOT__SENSOR
    ////////////////////////////////////////////////////////////////////////////////
    
    _READJAMMEDSLOT__SENSOR_enter()
    {
        this.stateId = BeadSorter.StateId.READJAMMEDSLOT__SENSOR;
        
        // ReadJammedSlot__Sensor behavior
        // uml: enter / { this.tracer?.enterState('ReadJammedSlot__Sensor'); }
        {
            // Step 1: execute action `this.tracer?.enterState('ReadJammedSlot__Sensor');`
            this.tracer?.enterState('ReadJammedSlot__Sensor');
        } // end of behavior for ReadJammedSlot__Sensor
        
        // ReadJammedSlot__Sensor behavior
        // uml: enter / { this.tracer?.logActionCode("jammies++;\nsorter.readColor();"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("jammies++;\nsorter.readColor();");`
            this.tracer?.logActionCode("jammies++;\nsorter.readColor();");
        } // end of behavior for ReadJammedSlot__Sensor
        
        // ReadJammedSlot__Sensor behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.READJAMMEDSLOT__SENSOR;)this.tracer?.logHistoryVarUpdate('Running', 'READJAMMEDSLOT__SENSOR'); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.READJAMMEDSLOT__SENSOR;)this.tracer?.logHistoryVarUpdate('Running', 'READJAMMEDSLOT__SENSOR');`
            this.vars.Running_history = BeadSorter.Running_HistoryId.READJAMMEDSLOT__SENSOR;this.tracer?.logHistoryVarUpdate('Running', 'READJAMMEDSLOT__SENSOR');
        } // end of behavior for ReadJammedSlot__Sensor
    }
    
    _READJAMMEDSLOT__SENSOR_exit()
    {
        // ReadJammedSlot__Sensor behavior
        // uml: exit / { this.tracer?.exitState('ReadJammedSlot__Sensor'); }
        {
            // Step 1: execute action `this.tracer?.exitState('ReadJammedSlot__Sensor');`
            this.tracer?.exitState('ReadJammedSlot__Sensor');
        } // end of behavior for ReadJammedSlot__Sensor
        
        this.stateId = BeadSorter.StateId.READJAMMEDSLOT;
    }
    
    _READJAMMEDSLOT__SENSOR_do()
    {
        // ReadJammedSlot__Sensor behavior
        // uml: do / { this.tracer?.edgeTransition('edge9'); } TransitionTo(ReadJammedSlot__Dropoff)
        {
            // Step 1: Exit states until we reach `ReadJammedSlot` state (Least Common Ancestor for transition).
            this._READJAMMEDSLOT__SENSOR_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge9');`.
            this.tracer?.edgeTransition('edge9');
            
            // Step 3: Enter/move towards transition target `ReadJammedSlot__Dropoff`.
            this._READJAMMEDSLOT__DROPOFF_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ReadJammedSlot__Sensor
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state READSLOT
    ////////////////////////////////////////////////////////////////////////////////
    
    _READSLOT_enter()
    {
        this.stateId = BeadSorter.StateId.READSLOT;
        
        // ReadSlot behavior
        // uml: enter / { this.tracer?.enterState('ReadSlot'); }
        {
            // Step 1: execute action `this.tracer?.enterState('ReadSlot');`
            this.tracer?.enterState('ReadSlot');
        } // end of behavior for ReadSlot
        
        // ReadSlot behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.READSLOT;)this.tracer?.logHistoryVarUpdate('Running', 'READSLOT'); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.READSLOT;)this.tracer?.logHistoryVarUpdate('Running', 'READSLOT');`
            this.vars.Running_history = BeadSorter.Running_HistoryId.READSLOT;this.tracer?.logHistoryVarUpdate('Running', 'READSLOT');
        } // end of behavior for ReadSlot
    }
    
    _READSLOT_exit()
    {
        // ReadSlot behavior
        // uml: exit / { this.tracer?.exitState('ReadSlot'); }
        {
            // Step 1: execute action `this.tracer?.exitState('ReadSlot');`
            this.tracer?.exitState('ReadSlot');
        } // end of behavior for ReadSlot
        
        this.stateId = BeadSorter.StateId.TRAININGMODE;
    }
    
    _ReadSlot_InitialState_transition()
    {
        // ReadSlot.<InitialState> behavior
        // uml: / { this.tracer?.edgeTransition('edge10'); } TransitionTo(TrainingMode__Pickup)
        {
            // Step 1: Exit states until we reach `ReadSlot` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge10');`.
            this.tracer?.edgeTransition('edge10');
            
            // Step 3: Enter/move towards transition target `TrainingMode__Pickup`.
            this._TRAININGMODE__PICKUP_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ReadSlot.<InitialState>
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state READSLOT__DROPOFF
    ////////////////////////////////////////////////////////////////////////////////
    
    _READSLOT__DROPOFF_enter()
    {
        this.stateId = BeadSorter.StateId.READSLOT__DROPOFF;
        
        // ReadSlot__Dropoff behavior
        // uml: enter / { this.tracer?.enterState('ReadSlot__Dropoff'); }
        {
            // Step 1: execute action `this.tracer?.enterState('ReadSlot__Dropoff');`
            this.tracer?.enterState('ReadSlot__Dropoff');
        } // end of behavior for ReadSlot__Dropoff
        
        // ReadSlot__Dropoff behavior
        // uml: enter / { this.tracer?.logActionCode("picker.moveToAndShimmy(DEG_DROPOFF);"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("picker.moveToAndShimmy(DEG_DROPOFF);");`
            this.tracer?.logActionCode("picker.moveToAndShimmy(DEG_DROPOFF);");
        } // end of behavior for ReadSlot__Dropoff
        
        // ReadSlot__Dropoff behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.READSLOT__DROPOFF;)this.tracer?.logHistoryVarUpdate('Running', 'READSLOT__DROPOFF'); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.READSLOT__DROPOFF;)this.tracer?.logHistoryVarUpdate('Running', 'READSLOT__DROPOFF');`
            this.vars.Running_history = BeadSorter.Running_HistoryId.READSLOT__DROPOFF;this.tracer?.logHistoryVarUpdate('Running', 'READSLOT__DROPOFF');
        } // end of behavior for ReadSlot__Dropoff
    }
    
    _READSLOT__DROPOFF_exit()
    {
        // ReadSlot__Dropoff behavior
        // uml: exit / { this.tracer?.exitState('ReadSlot__Dropoff'); }
        {
            // Step 1: execute action `this.tracer?.exitState('ReadSlot__Dropoff');`
            this.tracer?.exitState('ReadSlot__Dropoff');
        } // end of behavior for ReadSlot__Dropoff
        
        this.stateId = BeadSorter.StateId.READSLOT;
    }
    
    _READSLOT__DROPOFF_do()
    {
        // ReadSlot__Dropoff behavior
        // uml: 1. do [this.tracer?.logGuardCodeEvaluation("sorter.isTrainingDone()") || this.evaluateGuard('ReadSlot__Dropoff', "1. do [sorter.isTrainingDone()] TransitionTo(SortingMode)")] / { this.tracer?.edgeTransition('edge12'); } TransitionTo(SortingMode)
        if (this.tracer?.logGuardCodeEvaluation("sorter.isTrainingDone()") || this.evaluateGuard('ReadSlot__Dropoff', "1. do [sorter.isTrainingDone()] TransitionTo(SortingMode)"))
        {
            // Step 1: Exit states until we reach `Running` state (Least Common Ancestor for transition).
            this._exitUpToStateHandler(BeadSorter.StateId.RUNNING);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge12');`.
            this.tracer?.edgeTransition('edge12');
            
            // Step 3: Enter/move towards transition target `SortingMode`.
            this._SORTINGMODE_enter();
            
            // Finish transition by calling pseudo state transition function.
            this._SortingMode_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for ReadSlot__Dropoff
        
        // ReadSlot__Dropoff behavior
        // uml: do / { this.tracer?.edgeTransition('edge11'); } TransitionTo(TrainingMode__Pickup)
        {
            // Step 1: Exit states until we reach `ReadSlot` state (Least Common Ancestor for transition).
            this._READSLOT__DROPOFF_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge11');`.
            this.tracer?.edgeTransition('edge11');
            
            // Step 3: Enter/move towards transition target `TrainingMode__Pickup`.
            this._TRAININGMODE__PICKUP_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ReadSlot__Dropoff
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state READSLOT__SENSOR
    ////////////////////////////////////////////////////////////////////////////////
    
    _READSLOT__SENSOR_enter()
    {
        this.stateId = BeadSorter.StateId.READSLOT__SENSOR;
        
        // ReadSlot__Sensor behavior
        // uml: enter / { this.tracer?.enterState('ReadSlot__Sensor'); }
        {
            // Step 1: execute action `this.tracer?.enterState('ReadSlot__Sensor');`
            this.tracer?.enterState('ReadSlot__Sensor');
        } // end of behavior for ReadSlot__Sensor
        
        // ReadSlot__Sensor behavior
        // uml: enter / { this.tracer?.logActionCode("picker.shimmyAndMoveTo(DEG_SENSOR);\nsorter.readColor();\nsorter.runTraining();\nsorter.shimmyAndMoveTo(DEFAULT_BIN);"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("picker.shimmyAndMoveTo(DEG_SENSOR);\nsorter.readColor();\nsorter.runTraining();\nsorter.shimmyAndMoveTo(DEFAULT_BIN);");`
            this.tracer?.logActionCode("picker.shimmyAndMoveTo(DEG_SENSOR);\nsorter.readColor();\nsorter.runTraining();\nsorter.shimmyAndMoveTo(DEFAULT_BIN);");
        } // end of behavior for ReadSlot__Sensor
        
        // ReadSlot__Sensor behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.READSLOT__SENSOR;)this.tracer?.logHistoryVarUpdate('Running', 'READSLOT__SENSOR'); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.READSLOT__SENSOR;)this.tracer?.logHistoryVarUpdate('Running', 'READSLOT__SENSOR');`
            this.vars.Running_history = BeadSorter.Running_HistoryId.READSLOT__SENSOR;this.tracer?.logHistoryVarUpdate('Running', 'READSLOT__SENSOR');
        } // end of behavior for ReadSlot__Sensor
    }
    
    _READSLOT__SENSOR_exit()
    {
        // ReadSlot__Sensor behavior
        // uml: exit / { this.tracer?.exitState('ReadSlot__Sensor'); }
        {
            // Step 1: execute action `this.tracer?.exitState('ReadSlot__Sensor');`
            this.tracer?.exitState('ReadSlot__Sensor');
        } // end of behavior for ReadSlot__Sensor
        
        this.stateId = BeadSorter.StateId.READSLOT;
    }
    
    _READSLOT__SENSOR_do()
    {
        // ReadSlot__Sensor behavior
        // uml: do / { this.tracer?.edgeTransition('edge14'); } TransitionTo(ReadSlot__Dropoff)
        {
            // Step 1: Exit states until we reach `ReadSlot` state (Least Common Ancestor for transition).
            this._READSLOT__SENSOR_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge14');`.
            this.tracer?.edgeTransition('edge14');
            
            // Step 3: Enter/move towards transition target `ReadSlot__Dropoff`.
            this._READSLOT__DROPOFF_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ReadSlot__Sensor
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state TRAININGMODE__PICKUP
    ////////////////////////////////////////////////////////////////////////////////
    
    _TRAININGMODE__PICKUP_enter()
    {
        this.stateId = BeadSorter.StateId.TRAININGMODE__PICKUP;
        
        // TrainingMode__Pickup behavior
        // uml: enter / { this.tracer?.enterState('TrainingMode__Pickup'); }
        {
            // Step 1: execute action `this.tracer?.enterState('TrainingMode__Pickup');`
            this.tracer?.enterState('TrainingMode__Pickup');
        } // end of behavior for TrainingMode__Pickup
        
        // TrainingMode__Pickup behavior
        // uml: enter / { this.tracer?.logActionCode("picker.moveTo(DEG_PICKUP);"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("picker.moveTo(DEG_PICKUP);");`
            this.tracer?.logActionCode("picker.moveTo(DEG_PICKUP);");
        } // end of behavior for TrainingMode__Pickup
        
        // TrainingMode__Pickup behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.TRAININGMODE__PICKUP;)this.tracer?.logHistoryVarUpdate('Running', 'TRAININGMODE__PICKUP'); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.TRAININGMODE__PICKUP;)this.tracer?.logHistoryVarUpdate('Running', 'TRAININGMODE__PICKUP');`
            this.vars.Running_history = BeadSorter.Running_HistoryId.TRAININGMODE__PICKUP;this.tracer?.logHistoryVarUpdate('Running', 'TRAININGMODE__PICKUP');
        } // end of behavior for TrainingMode__Pickup
    }
    
    _TRAININGMODE__PICKUP_exit()
    {
        // TrainingMode__Pickup behavior
        // uml: exit / { this.tracer?.exitState('TrainingMode__Pickup'); }
        {
            // Step 1: execute action `this.tracer?.exitState('TrainingMode__Pickup');`
            this.tracer?.exitState('TrainingMode__Pickup');
        } // end of behavior for TrainingMode__Pickup
        
        this.stateId = BeadSorter.StateId.READSLOT;
    }
    
    _TRAININGMODE__PICKUP_do()
    {
        // TrainingMode__Pickup behavior
        // uml: do / { this.tracer?.edgeTransition('edge13'); } TransitionTo(ReadSlot__Sensor)
        {
            // Step 1: Exit states until we reach `ReadSlot` state (Least Common Ancestor for transition).
            this._TRAININGMODE__PICKUP_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge13');`.
            this.tracer?.edgeTransition('edge13');
            
            // Step 3: Enter/move towards transition target `ReadSlot__Sensor`.
            this._READSLOT__SENSOR_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for TrainingMode__Pickup
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state TRAININGMODE__START
    ////////////////////////////////////////////////////////////////////////////////
    
    _TRAININGMODE__START_enter()
    {
        this.stateId = BeadSorter.StateId.TRAININGMODE__START;
        
        // TrainingMode__Start behavior
        // uml: enter / { this.tracer?.enterState('TrainingMode__Start'); }
        {
            // Step 1: execute action `this.tracer?.enterState('TrainingMode__Start');`
            this.tracer?.enterState('TrainingMode__Start');
        } // end of behavior for TrainingMode__Start
        
        // TrainingMode__Start behavior
        // uml: enter / { this.tracer?.logActionCode("modeDisplay.print(\"TRAINING\");"); }
        {
            // Step 1: execute action `this.tracer?.logActionCode("modeDisplay.print(\"TRAINING\");");`
            this.tracer?.logActionCode("modeDisplay.print(\"TRAINING\");");
        } // end of behavior for TrainingMode__Start
        
        // TrainingMode__Start behavior
        // uml: enter / { $gil(this.vars.Running_history = Running_HistoryId.TRAININGMODE__START;)this.tracer?.logHistoryVarUpdate('Running', 'TRAININGMODE__START'); }
        {
            // Step 1: execute action `$gil(this.vars.Running_history = Running_HistoryId.TRAININGMODE__START;)this.tracer?.logHistoryVarUpdate('Running', 'TRAININGMODE__START');`
            this.vars.Running_history = BeadSorter.Running_HistoryId.TRAININGMODE__START;this.tracer?.logHistoryVarUpdate('Running', 'TRAININGMODE__START');
        } // end of behavior for TrainingMode__Start
    }
    
    _TRAININGMODE__START_exit()
    {
        // TrainingMode__Start behavior
        // uml: exit / { this.tracer?.exitState('TrainingMode__Start'); }
        {
            // Step 1: execute action `this.tracer?.exitState('TrainingMode__Start');`
            this.tracer?.exitState('TrainingMode__Start');
        } // end of behavior for TrainingMode__Start
        
        this.stateId = BeadSorter.StateId.TRAININGMODE;
    }
    
    _TRAININGMODE__START_do()
    {
        // TrainingMode__Start behavior
        // uml: do / { this.tracer?.edgeTransition('edge15'); } TransitionTo(ReadEmptySlot)
        {
            // Step 1: Exit states until we reach `TrainingMode` state (Least Common Ancestor for transition).
            this._TRAININGMODE__START_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge15');`.
            this.tracer?.edgeTransition('edge15');
            
            // Step 3: Enter/move towards transition target `ReadEmptySlot`.
            this._READEMPTYSLOT_enter();
            
            // Finish transition by calling pseudo state transition function.
            this._ReadEmptySlot_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for TrainingMode__Start
        
        // No ancestor handles this event.
    }
    
    // Thread safe.
    static stateIdToString(id)
    {
        switch (id)
        {
            case BeadSorter.StateId.ROOT: return "ROOT";
            case BeadSorter.StateId.PAUSED: return "PAUSED";
            case BeadSorter.StateId.RUNNING: return "RUNNING";
            case BeadSorter.StateId.SETUPCHECK: return "SETUPCHECK";
            case BeadSorter.StateId.ADJUSTSERVOOFFSETS: return "ADJUSTSERVOOFFSETS";
            case BeadSorter.StateId.DECREASE: return "DECREASE";
            case BeadSorter.StateId.INCREASE: return "INCREASE";
            case BeadSorter.StateId.WAIT: return "WAIT";
            case BeadSorter.StateId.SETUPCHECK__START: return "SETUPCHECK__START";
            case BeadSorter.StateId.TOUR: return "TOUR";
            case BeadSorter.StateId.SORTINGMODE: return "SORTINGMODE";
            case BeadSorter.StateId.SORTINGMODE__DROPOFF: return "SORTINGMODE__DROPOFF";
            case BeadSorter.StateId.SORTINGMODE__PICKUP: return "SORTINGMODE__PICKUP";
            case BeadSorter.StateId.SORTINGMODE__SENSOR: return "SORTINGMODE__SENSOR";
            case BeadSorter.StateId.SORTINGMODE__START: return "SORTINGMODE__START";
            case BeadSorter.StateId.TRAININGMODE: return "TRAININGMODE";
            case BeadSorter.StateId.READEMPTYSLOT: return "READEMPTYSLOT";
            case BeadSorter.StateId.READEMPTYSLOT__DROPOFF: return "READEMPTYSLOT__DROPOFF";
            case BeadSorter.StateId.READEMPTYSLOT__SENSOR: return "READEMPTYSLOT__SENSOR";
            case BeadSorter.StateId.READJAMMEDSLOT: return "READJAMMEDSLOT";
            case BeadSorter.StateId.JAMMED: return "JAMMED";
            case BeadSorter.StateId.READJAMMEDSLOT__DROPOFF: return "READJAMMEDSLOT__DROPOFF";
            case BeadSorter.StateId.READJAMMEDSLOT__SENSOR: return "READJAMMEDSLOT__SENSOR";
            case BeadSorter.StateId.READSLOT: return "READSLOT";
            case BeadSorter.StateId.READSLOT__DROPOFF: return "READSLOT__DROPOFF";
            case BeadSorter.StateId.READSLOT__SENSOR: return "READSLOT__SENSOR";
            case BeadSorter.StateId.TRAININGMODE__PICKUP: return "TRAININGMODE__PICKUP";
            case BeadSorter.StateId.TRAININGMODE__START: return "TRAININGMODE__START";
            default: return "?";
        }
    }
    
    // Thread safe.
    static eventIdToString(id)
    {
        switch (id)
        {
            case BeadSorter.EventId.BUTTON0: return "BUTTON0";
            case BeadSorter.EventId.BUTTON1: return "BUTTON1";
            case BeadSorter.EventId.BUTTON2: return "BUTTON2";
            case BeadSorter.EventId.DO: return "DO";
            default: return "?";
        }
    }
}

</script>

    <script type='module'>
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        import svgPanZoom from 'https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/+esm' ;
        mermaid.initialize({ startOnLoad: false });
        await mermaid.run();

        // svg-pan-zoom doesn't like the mermaid viewbox
        document.querySelector('svg').removeAttribute('viewBox');
        document.querySelector('svg').setAttribute('width', '100%');
        document.querySelector('svg').setAttribute('height', '100%');
        document.querySelector('svg').style['max-width'] = '';

        // don't scale the arrow when we scale the transition edge
        document.querySelectorAll('g defs marker[id$=barbEnd]').forEach(marker => {
            marker.setAttribute('markerUnits', 'userSpaceOnUse');
        });

        // https://github.com/StateSmith/StateSmith/issues/404
        // https://github.com/StateSmith/StateSmith/issues/294
        // rewrite $initial_state to a black circle
        document.querySelectorAll(`g[data-id*='(InitialState)']`).forEach(g=> {
          g.innerHTML = `<circle transform='translate(0,3)' height='14' width='14' r='14' class='state - start'></circle>`;
        })

        var panZoom = window.panZoom = svgPanZoom(document.querySelector('svg'), {
            zoomEnabled: true,
            dblClickZoomEnabled: false, // double click zoom gets in the way of quickly clicking on edge events
            controlIconsEnabled: true,
            fit: true,
            center: true
        });

        const diagramEventNamesArray = ['do', 'BUTTON0', 'BUTTON1', 'BUTTON2', ];

        // Mapping from state to available events
        const stateEventsMapping = {
  "Running": [
    "BUTTON0"
  ],
  "TrainingMode": [
    "BUTTON0"
  ],
  "ReadEmptySlot": [
    "BUTTON0"
  ],
  "ReadEmptySlot__Dropoff": [
    "BUTTON0",
    "do"
  ],
  "ReadEmptySlot__Sensor": [
    "BUTTON0",
    "do"
  ],
  "ReadJammedSlot": [
    "BUTTON0"
  ],
  "ReadJammedSlot__Dropoff": [
    "BUTTON0",
    "do"
  ],
  "Jammed": [
    "BUTTON0",
    "do"
  ],
  "ReadJammedSlot__Sensor": [
    "BUTTON0",
    "do"
  ],
  "ReadSlot": [
    "BUTTON0"
  ],
  "ReadSlot__Dropoff": [
    "BUTTON0",
    "do"
  ],
  "TrainingMode__Pickup": [
    "BUTTON0",
    "do"
  ],
  "ReadSlot__Sensor": [
    "BUTTON0",
    "do"
  ],
  "TrainingMode__Start": [
    "BUTTON0",
    "do"
  ],
  "SortingMode": [
    "BUTTON0"
  ],
  "SortingMode__Dropoff": [
    "BUTTON0",
    "do"
  ],
  "SortingMode__Pickup": [
    "BUTTON0",
    "do"
  ],
  "SortingMode__Start": [
    "BUTTON0",
    "do"
  ],
  "SortingMode__Sensor": [
    "BUTTON0",
    "do"
  ],
  "SetupCheck": [
    "BUTTON0"
  ],
  "Tour": [
    "BUTTON0",
    "do"
  ],
  "SetupCheck__Start": [
    "BUTTON0",
    "BUTTON2",
    "do"
  ],
  "AdjustServoOffsets": [
    "BUTTON0",
    "BUTTON2"
  ],
  "DECREASE": [
    "BUTTON0",
    "BUTTON2",
    "do"
  ],
  "INCREASE": [
    "BUTTON0",
    "BUTTON2",
    "do"
  ],
  "Wait": [
    "BUTTON0",
    "BUTTON1",
    "BUTTON2"
  ],
  "Paused": [
    "BUTTON0"
  ]
};

        // https://github.com/StateSmith/StateSmith/issues/522
        const stateEdgeMapping = {
  "Running": [
    0
  ],
  "TrainingMode": [
    0
  ],
  "ReadEmptySlot": [
    0
  ],
  "ReadEmptySlot__Dropoff": [
    0,
    2
  ],
  "ReadEmptySlot__Sensor": [
    0,
    3,
    4
  ],
  "ReadJammedSlot": [
    0
  ],
  "ReadJammedSlot__Dropoff": [
    0,
    6,
    7
  ],
  "Jammed": [
    0,
    8
  ],
  "ReadJammedSlot__Sensor": [
    0,
    9
  ],
  "ReadSlot": [
    0
  ],
  "ReadSlot__Dropoff": [
    0,
    11,
    12
  ],
  "TrainingMode__Pickup": [
    0,
    13
  ],
  "ReadSlot__Sensor": [
    0,
    14
  ],
  "TrainingMode__Start": [
    0,
    15
  ],
  "SortingMode": [
    0
  ],
  "SortingMode__Dropoff": [
    0,
    17
  ],
  "SortingMode__Pickup": [
    0,
    18
  ],
  "SortingMode__Start": [
    0,
    20
  ],
  "SortingMode__Sensor": [
    0,
    21
  ],
  "SetupCheck": [
    0
  ],
  "Tour": [
    0,
    23,
    24
  ],
  "SetupCheck__Start": [
    0,
    25,
    26
  ],
  "AdjustServoOffsets": [
    0,
    27
  ],
  "DECREASE": [
    0,
    27,
    28
  ],
  "INCREASE": [
    0,
    27,
    29
  ],
  "Wait": [
    0,
    30,
    31
  ],
  "Paused": [
    35
  ]
};

        // https://github.com/StateSmith/StateSmith/issues/523
        const stateDescriptionMapping = {
  "BeadSorter": "Vertex: ROOT\n-----------------------------------------\n- Type: StateMachine\n- Diagram Id: 12\n- Initial State: ROOT.\\\u003CInitialState\u003E\n\n### Behaviors\n",
  "Running": "Vertex: Running\n-----------------------------------------\n- Parent: ROOT\n- Type: State\n- Diagram Id: 294\n- Initial State: Running.\\\u003CInitialState\u003E\n\n### Behaviors\nBUTTON0 --\u003E TransitionTo(Paused)\n",
  "TrainingMode": "Vertex: TrainingMode\n-----------------------------------------\n- Parent: Running\n- Type: State\n- Diagram Id: 388\n- Initial State: TrainingMode.\\\u003CInitialState\u003E\n\n### Behaviors\nenter / { $gil(this.vars.Running_history = Running_HistoryId.TRAININGMODE;) }\n\n=== From ancestor \u0060Running\u0060 ===\n\nBUTTON0 --\u003E TransitionTo(Paused)\n",
  "ReadEmptySlot": "Vertex: ReadEmptySlot\n-----------------------------------------\n- Parent: TrainingMode\n- Type: State\n- Diagram Id: 390\n- Initial State: ReadEmptySlot.\\\u003CInitialState\u003E\n\n### Behaviors\nenter / { $gil(this.vars.Running_history = Running_HistoryId.READEMPTYSLOT;) }\n\n=== From ancestor \u0060Running\u0060 ===\n\nBUTTON0 --\u003E TransitionTo(Paused)\n",
  "ReadEmptySlot__Dropoff": "Vertex: ReadEmptySlot__Dropoff\n-----------------------------------------\n- Parent: ReadEmptySlot\n- Type: State\n- Diagram Id: 395\n\n### Behaviors\nenter / { picker.moveToAndShimmy(DEG_DROPOFF); }\n\ndo --\u003E TransitionTo(ReadEmptySlot__Sensor)\n\nenter / { $gil(this.vars.Running_history = Running_HistoryId.READEMPTYSLOT__DROPOFF;) }\n\n=== From ancestor \u0060Running\u0060 ===\n\nBUTTON0 --\u003E TransitionTo(Paused)\n",
  "ReadEmptySlot__Sensor": "Vertex: ReadEmptySlot__Sensor\n-----------------------------------------\n- Parent: ReadEmptySlot\n- Type: State\n- Diagram Id: 398\n\n### Behaviors\n1. do [empties\u003E=NUM_EMPTY_READS] --\u003E TransitionTo(ReadJammedSlot)\n\nenter / { picker.moveTo(DEG_SENSOR);\nempties\u002B\u002B;\nsorter.readColor(); }\n\ndo --\u003E TransitionTo(ReadEmptySlot__Dropoff)\n\nenter / { $gil(this.vars.Running_history = Running_HistoryId.READEMPTYSLOT__SENSOR;) }\n\n=== From ancestor \u0060Running\u0060 ===\n\nBUTTON0 --\u003E TransitionTo(Paused)\n",
  "ReadJammedSlot": "Vertex: ReadJammedSlot\n-----------------------------------------\n- Parent: TrainingMode\n- Type: State\n- Diagram Id: 400\n- Initial State: ReadJammedSlot.\\\u003CInitialState\u003E\n\n### Behaviors\nenter / { $gil(this.vars.Running_history = Running_HistoryId.READJAMMEDSLOT;) }\n\n=== From ancestor \u0060Running\u0060 ===\n\nBUTTON0 --\u003E TransitionTo(Paused)\n",
  "ReadJammedSlot__Dropoff": "Vertex: ReadJammedSlot__Dropoff\n-----------------------------------------\n- Parent: ReadJammedSlot\n- Type: State\n- Diagram Id: 405\n\n### Behaviors\n1. do [jammies\u003E=NUM_JAMMED_READS] --\u003E TransitionTo(ReadSlot)\n\nenter / { picker.moveToAndShimmy(DEG_DROPOFF); }\n\ndo --\u003E TransitionTo(Jammed)\n\nenter / { $gil(this.vars.Running_history = Running_HistoryId.READJAMMEDSLOT__DROPOFF;) }\n\n=== From ancestor \u0060Running\u0060 ===\n\nBUTTON0 --\u003E TransitionTo(Paused)\n",
  "Jammed": "Vertex: Jammed\n-----------------------------------------\n- Parent: ReadJammedSlot\n- Type: State\n- Diagram Id: 408\n\n### Behaviors\nenter / { picker.moveTo(DEG_JAMMED_READ); }\n\ndo --\u003E TransitionTo(ReadJammedSlot__Sensor)\n\nenter / { $gil(this.vars.Running_history = Running_HistoryId.JAMMED;) }\n\n=== From ancestor \u0060Running\u0060 ===\n\nBUTTON0 --\u003E TransitionTo(Paused)\n",
  "ReadJammedSlot__Sensor": "Vertex: ReadJammedSlot__Sensor\n-----------------------------------------\n- Parent: ReadJammedSlot\n- Type: State\n- Diagram Id: 411\n\n### Behaviors\nenter / { jammies\u002B\u002B;\nsorter.readColor(); }\n\ndo --\u003E TransitionTo(ReadJammedSlot__Dropoff)\n\nenter / { $gil(this.vars.Running_history = Running_HistoryId.READJAMMEDSLOT__SENSOR;) }\n\n=== From ancestor \u0060Running\u0060 ===\n\nBUTTON0 --\u003E TransitionTo(Paused)\n",
  "ReadSlot": "Vertex: ReadSlot\n-----------------------------------------\n- Parent: TrainingMode\n- Type: State\n- Diagram Id: 414\n- Initial State: ReadSlot.\\\u003CInitialState\u003E\n\n### Behaviors\nenter / { $gil(this.vars.Running_history = Running_HistoryId.READSLOT;) }\n\n=== From ancestor \u0060Running\u0060 ===\n\nBUTTON0 --\u003E TransitionTo(Paused)\n",
  "ReadSlot__Dropoff": "Vertex: ReadSlot__Dropoff\n-----------------------------------------\n- Parent: ReadSlot\n- Type: State\n- Diagram Id: 419\n\n### Behaviors\n1. do [sorter.isTrainingDone()] --\u003E TransitionTo(SortingMode)\n\nenter / { picker.moveToAndShimmy(DEG_DROPOFF); }\n\ndo --\u003E TransitionTo(TrainingMode__Pickup)\n\nenter / { $gil(this.vars.Running_history = Running_HistoryId.READSLOT__DROPOFF;) }\n\n=== From ancestor \u0060Running\u0060 ===\n\nBUTTON0 --\u003E TransitionTo(Paused)\n",
  "TrainingMode__Pickup": "Vertex: TrainingMode__Pickup\n-----------------------------------------\n- Parent: ReadSlot\n- Type: State\n- Diagram Id: 422\n\n### Behaviors\nenter / { picker.moveTo(DEG_PICKUP); }\n\ndo --\u003E TransitionTo(ReadSlot__Sensor)\n\nenter / { $gil(this.vars.Running_history = Running_HistoryId.TRAININGMODE__PICKUP;) }\n\n=== From ancestor \u0060Running\u0060 ===\n\nBUTTON0 --\u003E TransitionTo(Paused)\n",
  "ReadSlot__Sensor": "Vertex: ReadSlot__Sensor\n-----------------------------------------\n- Parent: ReadSlot\n- Type: State\n- Diagram Id: 425\n\n### Behaviors\nenter / { picker.shimmyAndMoveTo(DEG_SENSOR);\nsorter.readColor();\nsorter.runTraining();\nsorter.shimmyAndMoveTo(DEFAULT_BIN); }\n\ndo --\u003E TransitionTo(ReadSlot__Dropoff)\n\nenter / { $gil(this.vars.Running_history = Running_HistoryId.READSLOT__SENSOR;) }\n\n=== From ancestor \u0060Running\u0060 ===\n\nBUTTON0 --\u003E TransitionTo(Paused)\n",
  "TrainingMode__Start": "Vertex: TrainingMode__Start\n-----------------------------------------\n- Parent: TrainingMode\n- Type: State\n- Diagram Id: 430\n\n### Behaviors\nenter / { modeDisplay.print(\u0022TRAINING\u0022); }\n\ndo --\u003E TransitionTo(ReadEmptySlot)\n\nenter / { $gil(this.vars.Running_history = Running_HistoryId.TRAININGMODE__START;) }\n\n=== From ancestor \u0060Running\u0060 ===\n\nBUTTON0 --\u003E TransitionTo(Paused)\n",
  "SortingMode": "Vertex: SortingMode\n-----------------------------------------\n- Parent: Running\n- Type: State\n- Diagram Id: 435\n- Initial State: SortingMode.\\\u003CInitialState\u003E\n\n### Behaviors\nenter / { $gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE;) }\n\n=== From ancestor \u0060Running\u0060 ===\n\nBUTTON0 --\u003E TransitionTo(Paused)\n",
  "SortingMode__Dropoff": "Vertex: SortingMode__Dropoff\n-----------------------------------------\n- Parent: SortingMode\n- Type: State\n- Diagram Id: 438\n\n### Behaviors\nenter / { picker.moveToAndShimmy(DEG_DROPOFF); }\n\ndo --\u003E TransitionTo(SortingMode__Pickup)\n\nenter / { $gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__DROPOFF;) }\n\n=== From ancestor \u0060Running\u0060 ===\n\nBUTTON0 --\u003E TransitionTo(Paused)\n",
  "SortingMode__Pickup": "Vertex: SortingMode__Pickup\n-----------------------------------------\n- Parent: SortingMode\n- Type: State\n- Diagram Id: 441\n\n### Behaviors\nenter / { picker.moveTo(DEG_PICKUP); }\n\ndo --\u003E TransitionTo(SortingMode__Sensor)\n\nenter / { $gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__PICKUP;) }\n\n=== From ancestor \u0060Running\u0060 ===\n\nBUTTON0 --\u003E TransitionTo(Paused)\n",
  "SortingMode__Start": "Vertex: SortingMode__Start\n-----------------------------------------\n- Parent: SortingMode\n- Type: State\n- Diagram Id: 449\n\n### Behaviors\nenter / { modeDisplay.clear(); }\n\ndo --\u003E TransitionTo(SortingMode__Pickup)\n\nenter / { $gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__START;) }\n\n=== From ancestor \u0060Running\u0060 ===\n\nBUTTON0 --\u003E TransitionTo(Paused)\n",
  "SortingMode__Sensor": "Vertex: SortingMode__Sensor\n-----------------------------------------\n- Parent: SortingMode\n- Type: State\n- Diagram Id: 444\n\n### Behaviors\nenter / { picker.shimmyAndMoveTo(DEG_SENSOR);\nsorter.shimmyAndMoveTo(min(sorter.readColor(), DEFAULT_BIN)); }\n\ndo --\u003E TransitionTo(SortingMode__Dropoff)\n\nenter / { $gil(this.vars.Running_history = Running_HistoryId.SORTINGMODE__SENSOR;) }\n\n=== From ancestor \u0060Running\u0060 ===\n\nBUTTON0 --\u003E TransitionTo(Paused)\n",
  "SetupCheck": "Vertex: SetupCheck\n-----------------------------------------\n- Parent: Running\n- Type: State\n- Diagram Id: 374\n- Initial State: SetupCheck.\\\u003CInitialState\u003E\n\n### Behaviors\nenter / { $gil(this.vars.Running_history = Running_HistoryId.SETUPCHECK;) }\n\n=== From ancestor \u0060Running\u0060 ===\n\nBUTTON0 --\u003E TransitionTo(Paused)\n",
  "Tour": "Vertex: Tour\n-----------------------------------------\n- Parent: SetupCheck\n- Type: State\n- Diagram Id: 383\n\n### Behaviors\n1. do [tourBin\u003E=DEFAULT_BIN] --\u003E TransitionTo(TrainingMode)\n\nenter / { tourBin = min(tourBin\u002B1, DEFAULT_BIN);\nsorter.moveTo(tourBin); }\n\ndo [true] --\u003E TransitionTo(Tour)\n\nenter / { $gil(this.vars.Running_history = Running_HistoryId.TOUR;) }\n\n=== From ancestor \u0060Running\u0060 ===\n\nBUTTON0 --\u003E TransitionTo(Paused)\n",
  "SetupCheck__Start": "Vertex: SetupCheck__Start\n-----------------------------------------\n- Parent: SetupCheck\n- Type: State\n- Diagram Id: 377\n\n### Behaviors\nenter / { modeDisplay.print(\u0022SETUP CHECK\u0022);\nsorter.moveTo(0);\npicker.moveTo(DEG_DROPOFF);\npicker.moveTo(DEG_PICKUP);\nt1Restart(); }\n\ndo [t1After(3s)] --\u003E TransitionTo(Tour)\n\nBUTTON2 --\u003E TransitionTo(AdjustServoOffsets)\n\nenter / { $gil(this.vars.Running_history = Running_HistoryId.SETUPCHECK__START;) }\n\n=== From ancestor \u0060Running\u0060 ===\n\nBUTTON0 --\u003E TransitionTo(Paused)\n",
  "AdjustServoOffsets": "Vertex: AdjustServoOffsets\n-----------------------------------------\n- Parent: SetupCheck\n- Type: State\n- Diagram Id: 473\n- Initial State: AdjustServoOffsets.\\\u003CInitialState\u003E\n\n### Behaviors\nBUTTON2 --\u003E TransitionTo(SetupCheck__Start)\n\nenter / { $gil(this.vars.Running_history = Running_HistoryId.ADJUSTSERVOOFFSETS;) }\n\n=== From ancestor \u0060Running\u0060 ===\n\nBUTTON0 --\u003E TransitionTo(Paused)\n",
  "DECREASE": "Vertex: DECREASE\n-----------------------------------------\n- Parent: AdjustServoOffsets\n- Type: State\n- Diagram Id: 480\n\n### Behaviors\nenter / { picker.adjustOffset(-2); }\n\ndo --\u003E TransitionTo(Wait)\n\n=== From ancestor \u0060AdjustServoOffsets\u0060 ===\n\nBUTTON2 --\u003E TransitionTo(SetupCheck__Start)\n\n=== From ancestor \u0060Running\u0060 ===\n\nBUTTON0 --\u003E TransitionTo(Paused)\n",
  "INCREASE": "Vertex: INCREASE\n-----------------------------------------\n- Parent: AdjustServoOffsets\n- Type: State\n- Diagram Id: 482\n\n### Behaviors\nenter / { picker.adjustOffset(2); }\n\ndo --\u003E TransitionTo(Wait)\n\n=== From ancestor \u0060AdjustServoOffsets\u0060 ===\n\nBUTTON2 --\u003E TransitionTo(SetupCheck__Start)\n\n=== From ancestor \u0060Running\u0060 ===\n\nBUTTON0 --\u003E TransitionTo(Paused)\n",
  "Wait": "Vertex: Wait\n-----------------------------------------\n- Parent: AdjustServoOffsets\n- Type: State\n- Diagram Id: 494\n\n### Behaviors\nenter / { picker.displayOffset(); }\n\nBUTTON1 --\u003E TransitionTo(DECREASE)\n\nBUTTON2 --\u003E TransitionTo(INCREASE)\n\n=== From ancestor \u0060AdjustServoOffsets\u0060 ===\n\nBUTTON2 --\u003E TransitionTo(SetupCheck__Start)\n\n=== From ancestor \u0060Running\u0060 ===\n\nBUTTON0 --\u003E TransitionTo(Paused)\n",
  "Paused": "Vertex: Paused\n-----------------------------------------\n- Parent: ROOT\n- Type: State\n- Diagram Id: 454\n\n### Behaviors\nBUTTON0 --\u003E TransitionTo(Running)\n"
};

        // Get page element references
        const leftPane = document.querySelector('.main');
        const rightPane = document.querySelector('.sidebar');
        const gutter = document.querySelector('.gutter');

        // Function to resize panes
        function resizer(e) {          
          window.addEventListener('mousemove', mousemove);
          window.addEventListener('mouseup', mouseup);          
          let prevX = e.x;
          const rightPanel = rightPane.getBoundingClientRect();
                    
          function mousemove(e) {
            let newX = prevX - e.x;
            rightPane.style.width = rightPanel.width + newX + 'px';
            window.panZoom.resize();
            window.panZoom.fit();
            window.panZoom.center();
          }
          
          function mouseup() {
            window.removeEventListener('mousemove', mousemove);
            window.removeEventListener('mouseup', mouseup);
          }                  
        }

        // Add mouse down event listener for the resizer
        gutter.addEventListener('mousedown', resizer);



        //------------------- drop down functionality start -------------------
        const dropdownButton = document.getElementById('settings-dropdown-button');
        const dropdownDiv = document.getElementById('myDropdown');

        dropdownButton.addEventListener('click', toggleDropdown);

        document.getElementById('clear-button').addEventListener('click', function() {
          const tbody = document.querySelector('#event-logs tbody');
          tbody.innerHTML = '';
        });

        /* When the user clicks on the button, 
        toggle between hiding and showing the dropdown content */
        function toggleDropdown(event) {
          dropdownDiv.classList.toggle('show');
          event.stopPropagation(); // Prevent click from causing the window click handler to close the dropdown
        }

        // Close the dropdown if the user clicks outside of it
        window.onclick = function(event) {
          const isClickedOutsideDropdownDiv = !dropdownDiv.contains(event.target);

          if (isClickedOutsideDropdownDiv) {
            dropdownDiv.classList.remove('show');
          }
        }

        // Close the dropdown if the user presses Escape
        document.addEventListener('keydown', function(event) {
          if (event.key === 'Escape') {
            dropdownDiv.classList.remove('show');
          }
        });

        // Set the state of the timestamp checkbox
        document.getElementById('savedSetting_timestamps').addEventListener('change', function() {
          if(this.checked) {
            document.querySelector('table.console').classList.add('timestamps');
          } else {
            document.querySelector('table.console').classList.remove('timestamps');
          }
        });

        // Set up hide irrelevant events checkbox state and event listener
        document.getElementById('savedSetting_hideIrrelevantEvents').addEventListener('change', function() {
          // When checkbox state changes, only update button visibility, not availability
          updateButtonVisibility();
        });

        // store and restore checkbox states using localStorage.
        // DO AFTER event listeners are set up, so that restored state will trigger the change event and apply the setting.
        const dropdownCheckboxes = document.querySelectorAll(`.dropdown-content input[type='checkbox']`);
        dropdownCheckboxes.forEach(checkbox => {

          if (checkbox.id.startsWith('savedSetting_') === false)
          {
            console.log(`Skipping checkbox with id '${checkbox.id}' for localStorage state saving/restoring because it does not start with 'savedSetting_'.`, checkbox);
            return;
          }

          // append a note to the checkbox title that the state is saved in localStorage
          checkbox.parentElement.title += '\nThis setting is saved in localStorage and will persist across page reloads.';

          // Restore state from localStorage
          const savedState = localStorage.getItem(checkbox.id);
          if (savedState !== null) {
            checkbox.checked = (savedState === 'true');
            checkbox.dispatchEvent(new Event('change')); // Trigger change event to apply the setting
            console.log(`Restored checkbox value for '${checkbox.id}' to '${checkbox.checked}'`, checkbox);
          }

          // Save state to localStorage on change
          checkbox.addEventListener('change', function() {
            localStorage.setItem(checkbox.id, this.checked);
            console.log(`Saved checkbox value for '${checkbox.id}' to '${this.checked}'`, checkbox);
          });
        });

        //------------------- drop down functionality end -------------------



        // Convert a date to a string in the format HH:MM:SS.sss
        function formatTime(date) {
            return date.getHours().toString().padStart(2, '0') + ':' +
                date.getMinutes().toString().padStart(2, '0') + ':' +
                date.getSeconds().toString().padStart(2, '0') + '.' +
                date.getMilliseconds().toString().padStart(3, '0');
        }

        // Add a row to the history table.
        function addEventLogRow(time, event, html = false) {
            var row = document.createElement('tr');
            var timeCell = document.createElement('td');
            timeCell.innerText = formatTime(time);
            timeCell.classList.add('timestamp');
            var eventCell = document.createElement('td');

            if(html) {
              eventCell.innerHTML = event;
            } else {
              eventCell.innerText = event;
            }

            row.appendChild(timeCell);
            row.appendChild(eventCell);
            document.querySelector('#event-logs tbody').appendChild(row);
        }

        var sm = new BeadSorter();
        window.StateSmith_sm = sm; // expose to global scope so people can interact with it from the console if they want to.

        // prompt the user to evaluate guards manually
        sm.evaluateGuard = (vertexName, behaviorUml) => {
            return confirm(`Evaluate guard for\n${vertexName} behavior:\n${behaviorUml}.\n\nPress 'OK' to evaluate guard as true and 'Cancel' to evaluate it as false.`);
        }; 

        const highlightedEdges = new Set();
        function highlightEdge(edgeId) {
            var edge = document.getElementById(edgeId);
            if (edge) {
              edge.classList.add('pathJustTaken');
              highlightedEdges.add(edge);
            }
        }

        function clearHighlightedEdges() {
            for (const edge of highlightedEdges) {
              edge.classList.remove('pathJustTaken');
              const showOldTraversal = false;
              if (showOldTraversal) {
                  // shows that the edge was traversed. Optional, but kinda nice.
                  edge.style.stroke = 'green';
              }
            }
            highlightedEdges.clear();
        }

        function clearHighlightedStates() {
            document.querySelectorAll('g[id].active').forEach(e => e.classList.remove('active'));
        }

        // Function to update event button states (availability and visibility)
        function updateEventButtonStates(currentStateDiagramName) {
            const availableEvents = stateEventsMapping[currentStateDiagramName] || [];

            diagramEventNamesArray.forEach(eventName => {
                const button = document.getElementById('button_' + eventName);
                if (button) {
                    const hasEventHandler = availableEvents.includes(eventName);

                    let title = `Dispatch event '${eventName}' to the state machine.`;

                    if (hasEventHandler) {
                        button.classList.remove('hasNoEventHandler');
                    } else {
                        button.classList.add('hasNoEventHandler');
                        title += '\nThere is no handler for this event in the current state.\nDispatching is valid, but will have no effect on the state machine.';
                    }

                    title += '\nThere is a âš™ï¸ setting to disable these tooltips.';

                    const showTooltips = document.getElementById('savedSetting_showEventButtonTooltips').checked
                    if (showTooltips) {
                        button.title = title;
                    } else {
                        button.removeAttribute('title');
                    }
                }
            });
            
            // Update visibility based on checkbox state
            updateButtonVisibility();
        }

        // Function to update button visibility based on Hide Unused checkbox
        function updateButtonVisibility() {
            const hideIrrelevantEvents = document.getElementById('savedSetting_hideIrrelevantEvents').checked;
            
            diagramEventNamesArray.forEach(eventName => {
                const button = document.getElementById('button_' + eventName);
                if (button) {
                    // Toggle hidden class based on checkbox state and button has no event handler
                    button.classList.toggle('hidden', hideIrrelevantEvents && button.classList.contains('hasNoEventHandler'));
                }
            });
        }

        // https://github.com/StateSmith/StateSmith/issues/522
        function updateEdgeAvailability(currentStateDiagramName) {
            const availableEdges = stateEdgeMapping[currentStateDiagramName] || [];

            document.querySelectorAll('.transition.available').forEach(element => {
              element.classList.remove('available');
            });

            availableEdges.forEach(edgeId => {
                var domId = `edge${edgeId}`;
                var edge = document.getElementById(domId);
                if (edge) {
                  edge.classList.add('available');
                }
            });
        }

        // The simulator uses a tracer callback to perform operations such as 
        // state highlighting and logging.
        sm.tracer = {
            enterState: (mermaidName) => {
                var e = document.querySelector('g[data-id=' + mermaidName + ']') || document.querySelector('g[id=' + mermaidName + ']');

                if(e) {
                  e.classList.add('active');
                  panOnScreen(e);
                } else {
                  console.warn(`Could not find mermaid element to highlight for state '${mermaidName}'.`);
                }

                if (document.getElementById('savedSetting_verboseEnter').checked) {
                    sm.tracer.log(`âž¡ï¸ Entered <span class='identifier'>${mermaidName}</span>`, true);
                }
                
                updateEventButtonStates(mermaidName);
                updateEdgeAvailability(mermaidName);
            },
            exitState: (mermaidName) => {
                document.querySelector('g[data-id=' + mermaidName + ']')?.classList.remove('active');
                document.querySelector('g[id=' + mermaidName + ']')?.classList.remove('active');

                if (document.getElementById('savedSetting_verboseExit').checked) {
                    sm.tracer.log(`â†©ï¸ Exited <span class='identifier'>${mermaidName}</span>`, true);
                }
            },
            edgeTransition: (edgeId) => {
                highlightEdge(edgeId);
            },
            logHistoryVarUpdate: (varName, newValue) => {
                if (document.getElementById('savedSetting_verboseHistory').checked) {
                    sm.tracer.log(`ðŸ•‘ HistoryVar(<span class='identifier'>${varName}</span>) = <span class='identifier'>${newValue}</span>`, true);
                }
            },
            logHistoryTransition: (description) => {
                sm.tracer.log(`ðŸ•‘ History: ${description}.`);
            },
            logGuardCodeEvaluation: (guardCode) => {
                sm.tracer.log(`<span title='Guard code manually evaluated by user for simulation.'>ðŸ›¡ï¸ Guard: <code>[ ${guardCode} ]</code></span>`, true);
            },
            logActionCode: (actionCode) => {
                sm.tracer.log(`<span title='Your actual state machine will run this action code.'>âš¡ Action: <code>${actionCode}</code></span>`, true);
            },
            log: (message, html=false) => {
                addEventLogRow(new Date(), message, html);
            }
        };

        // https://github.com/StateSmith/StateSmith/issues/519
        function forceStateChange(stateNameAnyCase)
        {
          const stateName = stateNameAnyCase.toUpperCase();

          // get ID from stateName
          const stateId = BeadSorter.StateId[stateName];
          if (stateId === undefined) {
            console.error(`Invalid state name '${stateNameAnyCase}' passed to forceStateChange.`);
            console.log('Valid state names are (in any case):', Object.keys(BeadSorter.StateId).slice(1)); // slice(1) to remove ROOT from the list of valid states since it cannot be forced to.
            return;
          }

          // note! This and other ROOT code assumes that it is the first state. This is a fairly safe assumption, but if that ever changes this code will need to be updated.
          if (Object.keys(BeadSorter.StateId)[0] !== 'ROOT') {
            console.warn(`ROOT not found. This should happen. Please open a bug:`, 'https://github.com/StateSmith/StateSmith/issues/new');
          }

          if (stateId === 0) {
            console.error(`Cannot force state to state machine ROOT.`,);
            return;
          }

          let mermaidElement = null;

          // we now need the mermaid state element for the state of interest
          document.querySelectorAll('g[data-id],g[id]').forEach(e => {
            const lowerName = stateNameAnyCase.toLowerCase();
            const matchesLeafState = e.getAttribute('data-id') && e.getAttribute('data-id').toLowerCase() === lowerName;
            const matchesCompoundState = e.getAttribute('id').toLowerCase() === lowerName;

            if (matchesCompoundState || matchesLeafState) {
              mermaidElement = e;
            }
          });

          if (!mermaidElement) {
            console.error(`Could not find mermaid element for state name '${stateNameAnyCase}'. This is unexpected as we already found matching state id. Please open a bug:`, 'https://github.com/StateSmith/StateSmith/issues/new');
            return;
          }

          // force the state change. NOTE! This will only work with Algorithm Balanced2. See https://github.com/StateSmith/StateSmith/wiki/Algorithms.
          sm.stateId = stateId;
          
          // remove the active class from all states, then add it to the forced state.
          clearHighlightedStates();
          // mermaidElement.classList.add('active'); // done by state enter below

          sm.tracer.log(`<span class='dispatched'><a href='https://github.com/StateSmith/StateSmith/issues/519' target='_blank' title='May have impacts! Click for details.'><span class='forced-state'>FORCED STATE</span> to <span class='identifier'>${stateNameAnyCase}</span></span></a>`, true);

          // execute state's enter function
          const enterFunction = sm['_' + stateName + '_enter'];
          if (enterFunction) {
            enterFunction.call(sm); // need to call with sm as 'this' context so that it can update the state machine state and do other things that require access to 'this'.
          } else {
            console.warn(`No enter function found for state '${stateName}'. This is unexpected. Please open a bug:`, 'https://github.com/StateSmith/StateSmith/issues/new');
          }            

          panOnScreen(mermaidElement);
          
          let mermaidStateName;
          
          if (mermaidElement.getAttribute('data-id')) {
            mermaidStateName = mermaidElement.getAttribute('data-id');
          } else {
             mermaidStateName = mermaidElement.getAttribute('id');
          }
          updateEventButtonStates(mermaidStateName);
          clearHighlightedEdges();

          console.log(`Forced state to ${stateNameAnyCase}. See https://github.com/StateSmith/StateSmith/issues/519`);
        }

        // https://github.com/StateSmith/StateSmith/issues/519
        {
          // find simple state node labels
          // Make sure to test with simple states that are just a state name, and ones that have addition labels for non-transition behaviors.
          document.querySelectorAll('g.statediagram-state[data-id] g.label > foreignObject:first-of-type .nodeLabel').forEach(nodeLabel => {
            // confirm that node label matches an actual state. This weeds out pseudo states like `$H`, `$HC`, `$entry_pt`, ...
            const stateName = nodeLabel.textContent.toUpperCase();
            const stateId = BeadSorter.StateId[stateName];
            if (stateId === undefined) {
              return;
            }

            nodeLabel.classList.add('clickableDiagramElement');
          });

          // find composite state node labels
          document.querySelectorAll('g.statediagram-state[id].statediagram-cluster .nodeLabel').forEach(nodeLabel => {
            nodeLabel.classList.add('clickableDiagramElement');
          });

          // allow clicking states to force state machine to that state.
          document.querySelectorAll('.clickableDiagramElement').forEach(nodeLabel => {
            const stateElement = nodeLabel.closest('g.statediagram-state[id]');

            if (!stateElement)
            {
              console.warn('Open bug ticket? Failed finding statediagram-state for', nodeLabel);
            }

            nodeLabel.addEventListener('click', (event) => {

              if (savedSetting_requireCtrlForForceState.checked && !event.ctrlKey) {
                  // if the setting to require ctrl key is enabled, and the ctrl key is not pressed, do not force state.
                  return;
              }

              let stateName = null;

              // this is a bit hacky. Composite states have their name in the 'id' attribute, while simple states have their name in the 'data-id' attribute. We need to check both to support both types of states.
              if (stateElement.classList.contains('statediagram-cluster')) {
                stateName = stateElement.getAttribute('id');
              } else {
                stateName = stateElement.getAttribute('data-id');
              }

              // https://github.com/StateSmith/StateSmith/issues/523
              if (event.altKey)
              {
                const description = stateDescriptionMapping[stateName];
                if (description) {
                  console.log(description);
                  window.alert(description);
                } else {
                  console.warn(`Failed finding description for ${stateName}`);
                }
              } else {
                forceStateChange(stateName);
              }
            });
          });
        }

        // export forceStateChange to global scope so it can be called from the console for testing purposes.
        window.StateSmith_forceStateChange = forceStateChange;

        // Wire up the buttons that dispatch events for the state machine.
        diagramEventNamesArray.forEach(diagramEventName => {
            var button = document.createElement('button');
            button.id = 'button_' + diagramEventName;
            button.className = 'event-button';
            button.innerText = diagramEventName;
            button.addEventListener('click', () => {

                // allow dispatching events even if they have no handler in current state to aid in learning
                // https://github.com/StateSmith/StateSmith/issues/497
                const alwaysAllowEventDispatch = true;

                if (alwaysAllowEventDispatch || !button.classList.contains('hasNoEventHandler')) {
                    clearHighlightedEdges();
                    sm.tracer?.log(`<span class='dispatched'><span class='event-id'>${diagramEventName}</span> DISPATCHED</span>`, true);
                    const fsmEventName = diagramEventName.toUpperCase();
                    sm.dispatchEvent(BeadSorter.EventId[fsmEventName]); 
                }
            });
            document.getElementById(`buttons`).appendChild(button);
        });

        // clicking on edge label will try to send event
        // https://github.com/StateSmith/StateSmith/issues/521
        // DO AFTER buttons exist as we rely on them.
        {
          document.querySelectorAll('g span.edgeLabel').forEach(edgeLabelElement => {
            const edgeLabel = edgeLabelElement.textContent.trim();

            if (!edgeLabel)
            {
              return;
            }

            // ignore any decimal numbers at start, then look for first word which should be event name.
            // This allows for edge labels like: 
            //    `1. INCREASE [count >= 3] / { count++; }` and 
            //    `1.1. MY_EVENT`
            // See https://github.com/StateSmith/StateSmith/wiki/Behaviors
            const eventRegex = /^(?:\d+\.)?(?:\d+\.\s+)?(\w+)\b/;
            const match = edgeLabel.match(eventRegex);
            if (!match) {
              console.log(`Could not parse event name from edge label. This is normal for certain edges. Edge label text was: '${edgeLabel}'.`, edgeLabelElement);
              return;
            }

            const eventName = match[1];
            const button = document.getElementById('button_' + eventName);
            if (!button)
            {
              console.log(`No event button found for event name '${eventName}'. This is normal for certain edges.`, edgeLabelElement);
              return;
            }

            edgeLabelElement.classList.add('clickableDiagramElement');

            edgeLabelElement.addEventListener('click', (event) => {
              button.click();
            });
          });
        }

        sm.tracer?.log(`<span class='dispatched'>START</span>`, true);
        sm.start(); // This will cause `updateEventButtonStates()` to be called.

        function panOnScreen(element) {
            if (!element) return;

            // NOTE! There's some hacks here to prevent multiple rapid calls to panOnScreen.
            // If one transition causes 3 state enters, and each state entry calls panOnScreen, the screen often goes blank.
            // I would guess caused by window.panZoom.panBy()
            // So we put in a little delay hack in here and cancel any pending panning action.

            window.ss_lastPanActionHandle = window.ss_lastPanActionHandle || null;

            if (window.ss_lastPanActionHandle) {
                clearTimeout(window.ss_lastPanActionHandle);
                window.ss_lastPanActionHandle = null;
            }

            window.ss_lastPanActionHandle = setTimeout(() => {
                var bounds = element.getBoundingClientRect();
                if (bounds.x < 0 || bounds.y < 0) {
                    var x = Math.max(0, -bounds.x + 20);
                    var y = Math.max(0, -bounds.y + 20);
                    window.panZoom.panBy({ x: x, y: y });
                }
                var panebounds = document.querySelector('svg').getBoundingClientRect();
                if (bounds.x > panebounds.width || bounds.y > panebounds.height) {
                    var x = Math.min(0, panebounds.width - bounds.x - bounds.width - 20);
                    var y = Math.min(0, panebounds.height - bounds.y - bounds.height - 20);
                    window.panZoom.panBy({ x: x, y: y });
                }
            }, 1);
        }
    </script>


  </body>
</html>
