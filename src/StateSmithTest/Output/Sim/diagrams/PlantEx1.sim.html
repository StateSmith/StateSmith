<!-- 
  -- This file was generated by StateSmith.
  -- Note! The generated state machine code in this file has been specially instrumented to support simulator features.
  -- Regular generated javascript state machine code is smaller and simpler.
  -->
<html>
  <head>
    <link rel='icon' type='image/png' href='https://statesmith.github.io/favicon.png'>

      <!-- The below css makes the titlebar-icon functionality work. See https://fonts.google.com/icons -->
    <link rel='stylesheet' href='https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined'>

    <style>
      body {
        display: flex;
        flex-direction: row;
        margin: 0px;
      }

      /* Fix for mermaid content requiring scroll bars https://github.com/StateSmith/StateSmith/issues/288 */
      pre.mermaid {
        margin: 0px;
      }

      a.mermaid-workaround {
        text-decoration: none;
        color: inherit;
      }

      .wrapper {
        height: 100vh;
        width: 100vw;
        display: flex;
      }

      .pane {
        padding: 1em;
        min-width: 200px;
      }

      .titlebar-icon {
        font-family: 'Material Symbols Outlined', sans-serif;
        font-size: 16px;
        color: #777;
        border-radius: 5px;
      }

      .gutter {
        width: 10px;
        height: 100%;
        background: #ccc;
        position: absolute;
        top: 0;
        left: 0;
        cursor: col-resize;
      }

      .main {
        flex: 1;
        overflow: auto;
        padding: 10px;
      }

      .sidebar {
        width: 300px;
        padding-top: 0px;
        position: relative;
        background-color: #f0f0f0;
        border-left: 1px solid #ccc;
        display: flex;
        flex-direction: column;
      }

      #buttons {
        display: flex;
        flex-direction: column;
      }

      .titlebar {
        background-color: #ddd;
        border-bottom: 1px solid #ccc;
        font-weight: bold;
        padding: 5px;
        display: flex;
      }

      .console {
        border-collapse: collapse;
        margin-top: 10px;
        width: 100%;
      }

      table.console td.timestamp {
        display: none;
      }

      table.console.timestamps td.timestamp {
        display: table-cell;
      }

      table.console td {
          color: rgba(0, 0, 0, 0.7);
      }

      table.console td .dispatched {
          font-weight: bold;
          color: rgba(0, 0, 0, 1);
      }

      table.console tr:has(+tr td .dispatched) {
          border-bottom: 0px;
      }

      table.console tr:has(+tr td .dispatched) td {
          padding-bottom: 25px;
      }

      .console th {
        background-color: #f0f0f0;
        border-bottom: 1px solid #ccc;
        font-weight: normal;
        padding: 5px;
        text-align: left;
      }

      .console tbody {
        font-family: monospace;
      }

      .console tr {
        border-bottom: 1px solid #ccc;
      }

      .console td {
        padding: 5px;
      }
  
      .console td.timestamp {
        font-size: small;
      }

      #event-logs {
        margin-top: 30px;       
        display: flex;
        overflow: auto;    
        flex-direction: column-reverse;
      }

      .console tr:last-child td {
        border-bottom: none;
      }

      .dispatched {
        font-weight: bold;
      }

      .dispatched > .event-id {
        border: 1px solid #000;
        border-radius: 4px;
        padding: 2px;
      }

      button {
        margin: 5px;
      }

      button.event-button, .event-id {
        background-color: #007bff;
        color: white;
      }

      button.event-button {
        transition: opacity 0.3s ease, background-color 0.3s ease;
        opacity: 1;
        cursor: pointer;
      }

      button.event-button.hasNoEventHandler {
        opacity: 0.4;
        background-color: #f0f0f0;
        color: #999;
        cursor: not-allowed;
      }

      button.event-button:not(.hasNoEventHandler):hover {
        background-color: #0056b3;
      }

      /* Style for hiding irrelevant events */
      button.event-button.hidden {
        display: none;
      }



      /* ----------------------------- Dropdown related start ----------------------------- */
      
      .dropdown-button {
        border: none;
        cursor: pointer;
        user-select: none;
      }
      
      .dropdown-button:hover, .dropdown-button:focus {
        background-color: #f1f1f1;
      }
      
      .dropdown {
        position: relative;
        display: inline-block;
        margin-left: auto;
      }
      
      .dropdown-content {
        display: none;
        position: absolute;
        right: 0;
        background-color: #f1f1f1;
        min-width: 250px;
        overflow: auto;
        box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
        z-index: 1;
      }
      
      .dropdown-content .dropdown-item {
        display: block;
        padding: 12px 16px;
        font-weight: normal;
      }

      .dropdown-content .dropdown-item:hover {
        background-color: #ddd;
        cursor: pointer;
      }

      .show {
        display: block;
      }

      /* ----------------------------- Dropdown related end ----------------------------- */



      .transition.active {
        stroke: #fff5ad !important;
        stroke-width: 5px !important;
        filter: drop-shadow( 3px 3px 2px rgba(0, 0, 0, .7));
      }

      .statediagram-state.active > * {
        fill: #fff5ad !important;
        stroke-width: 2px !important;
      }

    </style>
  </head>

  <body>
    <div class='wrapper'>
    <div class='pane main'>
        <pre class='mermaid'>
stateDiagram

%% Initial state name as "." so that it fits in black circle shape.
%% See https://github.com/StateSmith/StateSmith/issues/404
state "." as ROOT.(InitialState)

state NotShooting {

        %% Initial state name as "." so that it fits in black circle shape.
        %% See https://github.com/StateSmith/StateSmith/issues/404
        state "." as NotShooting.(InitialState)

        Idle

        Idle : Idle

        Idle : Ev4 / #123;  #125;

        state Configuring {

                %% Initial state name as "." so that it fits in black circle shape.
                %% See https://github.com/StateSmith/StateSmith/issues/404
                state "." as Configuring.(InitialState)

                NewValueSelection

                NewValueSelection : NewValueSelection

                state NewValuePreview {

                        %% Initial state name as "." so that it fits in black circle shape.
                        %% See https://github.com/StateSmith/StateSmith/issues/404
                        state "." as NewValuePreview.(InitialState)

                        State1

                        State1 : State1

                        State2

                        State2 : State2

                }

        }

}

ROOT.(InitialState) --> NotShooting

NotShooting.(InitialState) --> Idle

Idle --> Configuring : EvConfig

Configuring --> Idle : EvConfig

Configuring.(InitialState) --> NewValueSelection

NewValueSelection --> NewValuePreview : EvNewValue

NewValuePreview --> NewValueSelection : EvNewValueRejected

NewValuePreview --> NewValueSelection : EvNewValueSaved

NewValuePreview.(InitialState) --> State1

State1 --> State2 : Ev2



        </pre>
    </div>

    <div class='pane sidebar'>
      <div id='buttons'>
        <div class='titlebar'>Events
          <div class='dropdown'>
            <span id='settings-dropdown-button' class='titlebar-icon dropdown-button' title='Settings'>settings</span>
            <span id='clear-button' class='titlebar-icon dropdown-button' title='Clear event log'>delete</span>
            <a href='https://github.com/StateSmith/StateSmith/wiki/Simulator' id='help-button' class='titlebar-icon dropdown-button' target='_blank' title='CHECK THIS!&#10;The simulator has a number of quirks and limitations&#10;that you should be aware of.'>help</a>
            <div id='myDropdown' class='dropdown-content'>

              <!-- 
                NOTE! Try not to change the ids of input checkboxes below as that will reset user preferences stored in localStorage.
                NOTE! New settings will be automatically picked up if they start with 'savedSetting_' and are checkboxes.
               -->

              <label class='dropdown-item' for='savedSetting_hideIrrelevantEvents'
                title='When enabled, event dispatching buttons will be hidden if the current active state(s) ignore the event.'>
                <input type='checkbox' id='savedSetting_hideIrrelevantEvents' name='savedSetting_hideIrrelevantEvents'>
                Hide ignored event buttons
              </label>
              <label class='dropdown-item' for='savedSetting_verboseEnter'
                title='Every time a state is entered, it will be logged below in the event log.'>
                <input type='checkbox' id='savedSetting_verboseEnter' name='savedSetting_verboseEnter' checked>
                Log State Entry
              </label>
              <label class='dropdown-item' for='savedSetting_verboseExit'
                title='Every time a state is exited, it will be logged below in the event log.'>
                <input type='checkbox' id='savedSetting_verboseExit' name='savedSetting_verboseExit' checked>
                Log State Exit
              </label>
              <label class='dropdown-item' for='savedSetting_verboseHistory'
                title='Log history pseudo state variable updates'>
                <input type='checkbox' id='savedSetting_verboseHistory' name='savedSetting_verboseHistory' checked>
                Log History Variables
              </label>
              <label class='dropdown-item' for='savedSetting_showEventButtonTooltips'
                 title='Event dispatching buttons will have tooltips with additional info.&#10;ðŸ“¢ NOTE! Changes to this setting take effect on state change or page reload.'>
                <input type='checkbox' id='savedSetting_showEventButtonTooltips' name='savedSetting_showEventButtonTooltips' checked>
                Show event button tooltips
              </label>
              <label class='dropdown-item' for='savedSetting_timestamps'
                title='Controls whether timestamps are shown along side event dispatches.'>
                <input type='checkbox' id='savedSetting_timestamps' name='savedSetting_timestamps'>
                Timestamps
              </label>
            </div>
          </div>
        </div>
      </div>
    
      <div id='event-logs'>
        <table class='console'>
          <tbody>
          </tbody>
        </table>
      </div>
    
      <div class='gutter'></div>
    </div>
    </div>

<script>
// Autogenerated with StateSmith.
// Algorithm: Balanced2. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

// Generated state machine
class PlantEx1
{
// Null by default.
// May be overridden to override guard evaluation (eg. in a simulator)
evaluateGuard = null;
    static EventId = 
    {
        EV2 : 0,
        EV4 : 1,
        EVCONFIG : 2,
        EVNEWVALUE : 3,
        EVNEWVALUEREJECTED : 4,
        EVNEWVALUESAVED : 5,
    }
    static { Object.freeze(this.EventId); }
    
    static EventIdCount = 6;
    static { Object.freeze(this.EventIdCount); }
    
    static StateId = 
    {
        ROOT : 0,
        NOTSHOOTING : 1,
        CONFIGURING : 2,
        NEWVALUEPREVIEW : 3,
        STATE1 : 4,
        STATE2 : 5,
        NEWVALUESELECTION : 6,
        IDLE : 7,
    }
    static { Object.freeze(this.StateId); }
    
    static StateIdCount = 8;
    static { Object.freeze(this.StateIdCount); }
    
    // Used internally by state machine. Feel free to inspect, but don't modify.
    stateId;
    
    // Starts the state machine. Must be called before dispatching events. Not thread safe.
    start()
    {
        this.#ROOT_enter();
        // ROOT behavior
        // uml: TransitionTo(ROOT.<InitialState>)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
            // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.
            
            // ROOT.<InitialState> behavior
            // uml: / { this.tracer?.edgeTransition('edge0'); } TransitionTo(NotShooting)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.edgeTransition('edge0');`.
                this.tracer?.edgeTransition('edge0');
                
                // Step 3: Enter/move towards transition target `NotShooting`.
                this.#NOTSHOOTING_enter();
                
                // NotShooting.<InitialState> behavior
                // uml: / { this.tracer?.edgeTransition('edge1'); } TransitionTo(Idle)
                {
                    // Step 1: Exit states until we reach `NotShooting` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                    
                    // Step 2: Transition action: `this.tracer?.edgeTransition('edge1');`.
                    this.tracer?.edgeTransition('edge1');
                    
                    // Step 3: Enter/move towards transition target `Idle`.
                    this.#IDLE_enter();
                    
                    // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                    return;
                } // end of behavior for NotShooting.<InitialState>
            } // end of behavior for ROOT.<InitialState>
        } // end of behavior for ROOT
    }
    
    // Dispatches an event to the state machine. Not thread safe.
    // Note! This function assumes that the `eventId` parameter is valid.
    dispatchEvent(eventId)
    {
        switch (this.stateId)
        {
            // STATE: PlantEx1
            case PlantEx1.StateId.ROOT:
                // No events handled by this state (or its ancestors).
                break;
            
            // STATE: NotShooting
            case PlantEx1.StateId.NOTSHOOTING:
                // No events handled by this state (or its ancestors).
                break;
            
            // STATE: Configuring
            case PlantEx1.StateId.CONFIGURING:
                switch (eventId)
                {
                    case PlantEx1.EventId.EVCONFIG: this.#CONFIGURING_evconfig(); break;
                }
                break;
            
            // STATE: NewValuePreview
            case PlantEx1.StateId.NEWVALUEPREVIEW:
                switch (eventId)
                {
                    case PlantEx1.EventId.EVNEWVALUEREJECTED: this.#NEWVALUEPREVIEW_evnewvaluerejected(); break;
                    case PlantEx1.EventId.EVNEWVALUESAVED: this.#NEWVALUEPREVIEW_evnewvaluesaved(); break;
                    case PlantEx1.EventId.EVCONFIG: this.#CONFIGURING_evconfig(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: State1
            case PlantEx1.StateId.STATE1:
                switch (eventId)
                {
                    case PlantEx1.EventId.EV2: this.#STATE1_ev2(); break;
                    case PlantEx1.EventId.EVCONFIG: this.#CONFIGURING_evconfig(); break; // First ancestor handler for this event
                    case PlantEx1.EventId.EVNEWVALUEREJECTED: this.#NEWVALUEPREVIEW_evnewvaluerejected(); break; // First ancestor handler for this event
                    case PlantEx1.EventId.EVNEWVALUESAVED: this.#NEWVALUEPREVIEW_evnewvaluesaved(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: State2
            case PlantEx1.StateId.STATE2:
                switch (eventId)
                {
                    case PlantEx1.EventId.EVCONFIG: this.#CONFIGURING_evconfig(); break; // First ancestor handler for this event
                    case PlantEx1.EventId.EVNEWVALUEREJECTED: this.#NEWVALUEPREVIEW_evnewvaluerejected(); break; // First ancestor handler for this event
                    case PlantEx1.EventId.EVNEWVALUESAVED: this.#NEWVALUEPREVIEW_evnewvaluesaved(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: NewValueSelection
            case PlantEx1.StateId.NEWVALUESELECTION:
                switch (eventId)
                {
                    case PlantEx1.EventId.EVNEWVALUE: this.#NEWVALUESELECTION_evnewvalue(); break;
                    case PlantEx1.EventId.EVCONFIG: this.#CONFIGURING_evconfig(); break; // First ancestor handler for this event
                }
                break;
            
            // STATE: Idle
            case PlantEx1.StateId.IDLE:
                switch (eventId)
                {
                    case PlantEx1.EventId.EV4: this.#IDLE_ev4(); break;
                    case PlantEx1.EventId.EVCONFIG: this.#IDLE_evconfig(); break;
                }
                break;
        }
        
    }
    
    // This function is used when StateSmith doesn't know what the active leaf state is at
    // compile time due to sub states or when multiple states need to be exited.
    #exitUpToStateHandler(desiredState)
    {
        while (this.stateId != desiredState)
        {
            switch (this.stateId)
            {
                case PlantEx1.StateId.NOTSHOOTING: this.#NOTSHOOTING_exit(); break;
                
                case PlantEx1.StateId.CONFIGURING: this.#CONFIGURING_exit(); break;
                
                case PlantEx1.StateId.NEWVALUEPREVIEW: this.#NEWVALUEPREVIEW_exit(); break;
                
                case PlantEx1.StateId.STATE1: this.#STATE1_exit(); break;
                
                case PlantEx1.StateId.STATE2: this.#STATE2_exit(); break;
                
                case PlantEx1.StateId.NEWVALUESELECTION: this.#NEWVALUESELECTION_exit(); break;
                
                case PlantEx1.StateId.IDLE: this.#IDLE_exit(); break;
                
                default: return;  // Just to be safe. Prevents infinite loop if state ID memory is somehow corrupted.
            }
        }
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ROOT
    ////////////////////////////////////////////////////////////////////////////////
    
    #ROOT_enter()
    {
        this.stateId = PlantEx1.StateId.ROOT;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state NOTSHOOTING
    ////////////////////////////////////////////////////////////////////////////////
    
    #NOTSHOOTING_enter()
    {
        this.stateId = PlantEx1.StateId.NOTSHOOTING;
        
        // NotShooting behavior
        // uml: enter / { this.tracer?.enterState('NotShooting'); }
        {
            // Step 1: execute action `this.tracer?.enterState('NotShooting');`
            this.tracer?.enterState('NotShooting');
        } // end of behavior for NotShooting
    }
    
    #NOTSHOOTING_exit()
    {
        // NotShooting behavior
        // uml: exit / { this.tracer?.exitState('NotShooting'); }
        {
            // Step 1: execute action `this.tracer?.exitState('NotShooting');`
            this.tracer?.exitState('NotShooting');
        } // end of behavior for NotShooting
        
        this.stateId = PlantEx1.StateId.ROOT;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state CONFIGURING
    ////////////////////////////////////////////////////////////////////////////////
    
    #CONFIGURING_enter()
    {
        this.stateId = PlantEx1.StateId.CONFIGURING;
        
        // Configuring behavior
        // uml: enter / { this.tracer?.enterState('Configuring'); }
        {
            // Step 1: execute action `this.tracer?.enterState('Configuring');`
            this.tracer?.enterState('Configuring');
        } // end of behavior for Configuring
    }
    
    #CONFIGURING_exit()
    {
        // Configuring behavior
        // uml: exit / { this.tracer?.exitState('Configuring'); }
        {
            // Step 1: execute action `this.tracer?.exitState('Configuring');`
            this.tracer?.exitState('Configuring');
        } // end of behavior for Configuring
        
        this.stateId = PlantEx1.StateId.NOTSHOOTING;
    }
    
    #CONFIGURING_evconfig()
    {
        // Configuring behavior
        // uml: EvConfig / { this.tracer?.edgeTransition('edge3'); } TransitionTo(Idle)
        {
            // Step 1: Exit states until we reach `NotShooting` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(PlantEx1.StateId.NOTSHOOTING);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge3');`.
            this.tracer?.edgeTransition('edge3');
            
            // Step 3: Enter/move towards transition target `Idle`.
            this.#IDLE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Configuring
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state NEWVALUEPREVIEW
    ////////////////////////////////////////////////////////////////////////////////
    
    #NEWVALUEPREVIEW_enter()
    {
        this.stateId = PlantEx1.StateId.NEWVALUEPREVIEW;
        
        // NewValuePreview behavior
        // uml: enter / { this.tracer?.enterState('NewValuePreview'); }
        {
            // Step 1: execute action `this.tracer?.enterState('NewValuePreview');`
            this.tracer?.enterState('NewValuePreview');
        } // end of behavior for NewValuePreview
    }
    
    #NEWVALUEPREVIEW_exit()
    {
        // NewValuePreview behavior
        // uml: exit / { this.tracer?.exitState('NewValuePreview'); }
        {
            // Step 1: execute action `this.tracer?.exitState('NewValuePreview');`
            this.tracer?.exitState('NewValuePreview');
        } // end of behavior for NewValuePreview
        
        this.stateId = PlantEx1.StateId.CONFIGURING;
    }
    
    #NEWVALUEPREVIEW_evnewvaluerejected()
    {
        // NewValuePreview behavior
        // uml: EvNewValueRejected / { this.tracer?.edgeTransition('edge6'); } TransitionTo(NewValueSelection)
        {
            // Step 1: Exit states until we reach `Configuring` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(PlantEx1.StateId.CONFIGURING);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge6');`.
            this.tracer?.edgeTransition('edge6');
            
            // Step 3: Enter/move towards transition target `NewValueSelection`.
            this.#NEWVALUESELECTION_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for NewValuePreview
        
        // No ancestor handles this event.
    }
    
    #NEWVALUEPREVIEW_evnewvaluesaved()
    {
        // NewValuePreview behavior
        // uml: EvNewValueSaved / { this.tracer?.edgeTransition('edge7'); } TransitionTo(NewValueSelection)
        {
            // Step 1: Exit states until we reach `Configuring` state (Least Common Ancestor for transition).
            this.#exitUpToStateHandler(PlantEx1.StateId.CONFIGURING);
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge7');`.
            this.tracer?.edgeTransition('edge7');
            
            // Step 3: Enter/move towards transition target `NewValueSelection`.
            this.#NEWVALUESELECTION_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for NewValuePreview
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state STATE1
    ////////////////////////////////////////////////////////////////////////////////
    
    #STATE1_enter()
    {
        this.stateId = PlantEx1.StateId.STATE1;
        
        // State1 behavior
        // uml: enter / { this.tracer?.enterState('State1'); }
        {
            // Step 1: execute action `this.tracer?.enterState('State1');`
            this.tracer?.enterState('State1');
        } // end of behavior for State1
    }
    
    #STATE1_exit()
    {
        // State1 behavior
        // uml: exit / { this.tracer?.exitState('State1'); }
        {
            // Step 1: execute action `this.tracer?.exitState('State1');`
            this.tracer?.exitState('State1');
        } // end of behavior for State1
        
        this.stateId = PlantEx1.StateId.NEWVALUEPREVIEW;
    }
    
    #STATE1_ev2()
    {
        // State1 behavior
        // uml: Ev2 / { this.tracer?.edgeTransition('edge9'); } TransitionTo(State2)
        {
            // Step 1: Exit states until we reach `NewValuePreview` state (Least Common Ancestor for transition).
            this.#STATE1_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge9');`.
            this.tracer?.edgeTransition('edge9');
            
            // Step 3: Enter/move towards transition target `State2`.
            this.#STATE2_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for State1
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state STATE2
    ////////////////////////////////////////////////////////////////////////////////
    
    #STATE2_enter()
    {
        this.stateId = PlantEx1.StateId.STATE2;
        
        // State2 behavior
        // uml: enter / { this.tracer?.enterState('State2'); }
        {
            // Step 1: execute action `this.tracer?.enterState('State2');`
            this.tracer?.enterState('State2');
        } // end of behavior for State2
    }
    
    #STATE2_exit()
    {
        // State2 behavior
        // uml: exit / { this.tracer?.exitState('State2'); }
        {
            // Step 1: execute action `this.tracer?.exitState('State2');`
            this.tracer?.exitState('State2');
        } // end of behavior for State2
        
        this.stateId = PlantEx1.StateId.NEWVALUEPREVIEW;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state NEWVALUESELECTION
    ////////////////////////////////////////////////////////////////////////////////
    
    #NEWVALUESELECTION_enter()
    {
        this.stateId = PlantEx1.StateId.NEWVALUESELECTION;
        
        // NewValueSelection behavior
        // uml: enter / { this.tracer?.enterState('NewValueSelection'); }
        {
            // Step 1: execute action `this.tracer?.enterState('NewValueSelection');`
            this.tracer?.enterState('NewValueSelection');
        } // end of behavior for NewValueSelection
    }
    
    #NEWVALUESELECTION_exit()
    {
        // NewValueSelection behavior
        // uml: exit / { this.tracer?.exitState('NewValueSelection'); }
        {
            // Step 1: execute action `this.tracer?.exitState('NewValueSelection');`
            this.tracer?.exitState('NewValueSelection');
        } // end of behavior for NewValueSelection
        
        this.stateId = PlantEx1.StateId.CONFIGURING;
    }
    
    #NEWVALUESELECTION_evnewvalue()
    {
        // NewValueSelection behavior
        // uml: EvNewValue / { this.tracer?.edgeTransition('edge5'); } TransitionTo(NewValuePreview)
        {
            // Step 1: Exit states until we reach `Configuring` state (Least Common Ancestor for transition).
            this.#NEWVALUESELECTION_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge5');`.
            this.tracer?.edgeTransition('edge5');
            
            // Step 3: Enter/move towards transition target `NewValuePreview`.
            this.#NEWVALUEPREVIEW_enter();
            
            // NewValuePreview.<InitialState> behavior
            // uml: / { this.tracer?.edgeTransition('edge8'); } TransitionTo(State1)
            {
                // Step 1: Exit states until we reach `NewValuePreview` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.edgeTransition('edge8');`.
                this.tracer?.edgeTransition('edge8');
                
                // Step 3: Enter/move towards transition target `State1`.
                this.#STATE1_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for NewValuePreview.<InitialState>
        } // end of behavior for NewValueSelection
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state IDLE
    ////////////////////////////////////////////////////////////////////////////////
    
    #IDLE_enter()
    {
        this.stateId = PlantEx1.StateId.IDLE;
        
        // Idle behavior
        // uml: enter / { this.tracer?.enterState('Idle'); }
        {
            // Step 1: execute action `this.tracer?.enterState('Idle');`
            this.tracer?.enterState('Idle');
        } // end of behavior for Idle
    }
    
    #IDLE_exit()
    {
        // Idle behavior
        // uml: exit / { this.tracer?.exitState('Idle'); }
        {
            // Step 1: execute action `this.tracer?.exitState('Idle');`
            this.tracer?.exitState('Idle');
        } // end of behavior for Idle
        
        this.stateId = PlantEx1.StateId.NOTSHOOTING;
    }
    
    #IDLE_ev4()
    {
        // Idle behavior
        // uml: Ev4
        {
            // Step 1: execute action ``
        } // end of behavior for Idle
        
        // No ancestor handles this event.
    }
    
    #IDLE_evconfig()
    {
        // Idle behavior
        // uml: EvConfig / { this.tracer?.edgeTransition('edge2'); } TransitionTo(Configuring)
        {
            // Step 1: Exit states until we reach `NotShooting` state (Least Common Ancestor for transition).
            this.#IDLE_exit();
            
            // Step 2: Transition action: `this.tracer?.edgeTransition('edge2');`.
            this.tracer?.edgeTransition('edge2');
            
            // Step 3: Enter/move towards transition target `Configuring`.
            this.#CONFIGURING_enter();
            
            // Configuring.<InitialState> behavior
            // uml: / { this.tracer?.edgeTransition('edge4'); } TransitionTo(NewValueSelection)
            {
                // Step 1: Exit states until we reach `Configuring` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `this.tracer?.edgeTransition('edge4');`.
                this.tracer?.edgeTransition('edge4');
                
                // Step 3: Enter/move towards transition target `NewValueSelection`.
                this.#NEWVALUESELECTION_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for Configuring.<InitialState>
        } // end of behavior for Idle
        
        // No ancestor handles this event.
    }
    
    // Thread safe.
    static stateIdToString(id)
    {
        switch (id)
        {
            case PlantEx1.StateId.ROOT: return "ROOT";
            case PlantEx1.StateId.NOTSHOOTING: return "NOTSHOOTING";
            case PlantEx1.StateId.CONFIGURING: return "CONFIGURING";
            case PlantEx1.StateId.NEWVALUEPREVIEW: return "NEWVALUEPREVIEW";
            case PlantEx1.StateId.STATE1: return "STATE1";
            case PlantEx1.StateId.STATE2: return "STATE2";
            case PlantEx1.StateId.NEWVALUESELECTION: return "NEWVALUESELECTION";
            case PlantEx1.StateId.IDLE: return "IDLE";
            default: return "?";
        }
    }
    
    // Thread safe.
    static eventIdToString(id)
    {
        switch (id)
        {
            case PlantEx1.EventId.EV2: return "EV2";
            case PlantEx1.EventId.EV4: return "EV4";
            case PlantEx1.EventId.EVCONFIG: return "EVCONFIG";
            case PlantEx1.EventId.EVNEWVALUE: return "EVNEWVALUE";
            case PlantEx1.EventId.EVNEWVALUEREJECTED: return "EVNEWVALUEREJECTED";
            case PlantEx1.EventId.EVNEWVALUESAVED: return "EVNEWVALUESAVED";
            default: return "?";
        }
    }
}

</script>

    <script type='module'>
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        import svgPanZoom from 'https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/+esm' ;
        mermaid.initialize({ startOnLoad: false });
        await mermaid.run();

        // svg-pan-zoom doesn't like the mermaid viewbox
        document.querySelector('svg').removeAttribute('viewBox');
        document.querySelector('svg').setAttribute('width', '100%');
        document.querySelector('svg').setAttribute('height', '100%');
        document.querySelector('svg').style['max-width'] = '';

        // don't scale the arrow when we scale the transition edge
        document.querySelectorAll('g defs marker[id$=barbEnd]').forEach(marker => {
            marker.setAttribute('markerUnits', 'userSpaceOnUse');
        });

        // https://github.com/StateSmith/StateSmith/issues/404
        // https://github.com/StateSmith/StateSmith/issues/294
        // rewrite $initial_state to a black circle
        document.querySelectorAll(`g[data-id*='(InitialState)']`).forEach(g=> {
          g.innerHTML = `<circle transform='translate(0,3)' height='14' width='14' r='14' class='state - start'></circle>`;
        })

        var panZoom = window.panZoom = svgPanZoom(document.querySelector('svg'), {
            zoomEnabled: true,
            controlIconsEnabled: true,
            fit: true,
            center: true
        });

        const diagramEventNamesArray = ['Ev2', 'Ev4', 'EvConfig', 'EvNewValue', 'EvNewValueRejected', 'EvNewValueSaved', ];

        // Mapping from state to available events
        const stateEventsMapping = {
  "NotShooting": [],
  "Idle": [
    "Ev4",
    "EvConfig"
  ],
  "Configuring": [
    "EvConfig"
  ],
  "NewValueSelection": [
    "EvConfig",
    "EvNewValue"
  ],
  "NewValuePreview": [
    "EvConfig",
    "EvNewValueRejected",
    "EvNewValueSaved"
  ],
  "State1": [
    "Ev2",
    "EvConfig",
    "EvNewValueRejected",
    "EvNewValueSaved"
  ],
  "State2": [
    "EvConfig",
    "EvNewValueRejected",
    "EvNewValueSaved"
  ]
};

        // Get page element references
        const leftPane = document.querySelector('.main');
        const rightPane = document.querySelector('.sidebar');
        const gutter = document.querySelector('.gutter');

        // Function to resize panes
        function resizer(e) {          
          window.addEventListener('mousemove', mousemove);
          window.addEventListener('mouseup', mouseup);          
          let prevX = e.x;
          const rightPanel = rightPane.getBoundingClientRect();
                    
          function mousemove(e) {
            let newX = prevX - e.x;
            rightPane.style.width = rightPanel.width + newX + 'px';
            window.panZoom.resize();
            window.panZoom.fit();
            window.panZoom.center();
          }
          
          function mouseup() {
            window.removeEventListener('mousemove', mousemove);
            window.removeEventListener('mouseup', mouseup);
          }                  
        }

        // Add mouse down event listener for the resizer
        gutter.addEventListener('mousedown', resizer);



        //------------------- drop down functionality start -------------------
        const dropdownButton = document.getElementById('settings-dropdown-button');
        const dropdownDiv = document.getElementById('myDropdown');

        dropdownButton.addEventListener('click', toggleDropdown);

        document.getElementById('clear-button').addEventListener('click', function() {
          const tbody = document.querySelector('#event-logs tbody');
          tbody.innerHTML = '';
        });

        /* When the user clicks on the button, 
        toggle between hiding and showing the dropdown content */
        function toggleDropdown(event) {
          dropdownDiv.classList.toggle('show');
          event.stopPropagation(); // Prevent click from causing the window click handler to close the dropdown
        }

        // Close the dropdown if the user clicks outside of it
        window.onclick = function(event) {
          const isClickedOutsideDropdownDiv = !dropdownDiv.contains(event.target);

          if (isClickedOutsideDropdownDiv) {
            dropdownDiv.classList.remove('show');
          }
        }

        // Close the dropdown if the user presses Escape
        document.addEventListener('keydown', function(event) {
          if (event.key === 'Escape') {
            dropdownDiv.classList.remove('show');
          }
        });

        // Set the state of the timestamp checkbox
        document.getElementById('savedSetting_timestamps').addEventListener('change', function() {
          if(this.checked) {
            document.querySelector('table.console').classList.add('timestamps');
          } else {
            document.querySelector('table.console').classList.remove('timestamps');
          }
        });

        // Set up hide irrelevant events checkbox state and event listener
        document.getElementById('savedSetting_hideIrrelevantEvents').addEventListener('change', function() {
          // When checkbox state changes, only update button visibility, not availability
          updateButtonVisibility();
        });

        // store and restore checkbox states using localStorage.
        // DO AFTER event listeners are set up, so that restored state will trigger the change event and apply the setting.
        const dropdownCheckboxes = document.querySelectorAll(`.dropdown-content input[type='checkbox']`);
        dropdownCheckboxes.forEach(checkbox => {

          if (checkbox.id.startsWith('savedSetting_') === false)
          {
            console.log(`Skipping checkbox with id '${checkbox.id}' for localStorage state saving/restoring because it does not start with 'savedSetting_'.`, checkbox);
            return;
          }

          // append a note to the checkbox title that the state is saved in localStorage
          checkbox.parentElement.title += '\nThis setting is saved in localStorage and will persist across page reloads.';

          // Restore state from localStorage
          const savedState = localStorage.getItem(checkbox.id);
          if (savedState !== null) {
            checkbox.checked = (savedState === 'true');
            checkbox.dispatchEvent(new Event('change')); // Trigger change event to apply the setting
            console.log(`Restored checkbox value for '${checkbox.id}' to '${checkbox.checked}'`, checkbox);
          }

          // Save state to localStorage on change
          checkbox.addEventListener('change', function() {
            localStorage.setItem(checkbox.id, this.checked);
            console.log(`Saved checkbox value for '${checkbox.id}' to '${this.checked}'`, checkbox);
          });
        });

        //------------------- drop down functionality end -------------------



        // Convert a date to a string in the format HH:MM:SS.sss
        function formatTime(date) {
            return date.getHours().toString().padStart(2, '0') + ':' +
                date.getMinutes().toString().padStart(2, '0') + ':' +
                date.getSeconds().toString().padStart(2, '0') + '.' +
                date.getMilliseconds().toString().padStart(3, '0');
        }

        // Add a row to the history table.
        function addEventLogRow(time, event, html = false) {
            var row = document.createElement('tr');
            var timeCell = document.createElement('td');
            timeCell.innerText = formatTime(time);
            timeCell.classList.add('timestamp');
            var eventCell = document.createElement('td');

            if(html) {
              eventCell.innerHTML = event;
            } else {
              eventCell.innerText = event;
            }

            row.appendChild(timeCell);
            row.appendChild(eventCell);
            document.querySelector('#event-logs tbody').appendChild(row);
        }

        var sm = new PlantEx1();

        // prompt the user to evaluate guards manually
        sm.evaluateGuard = (vertexName, behaviorUml) => {
            return confirm(`Evaluate guard for\n${vertexName} behavior:\n${behaviorUml}.\n\nPress 'OK' to evaluate guard as true and 'Cancel' to evaluate it as false.`);
        }; 

        const highlightedEdges = new Set();
        function highlightEdge(edgeId) {
            var edge = document.getElementById(edgeId);
            if (edge) {
              edge.classList.add('active');
              highlightedEdges.add(edge);
            }
        }

        function clearHighlightedEdges() {
            for (const edge of highlightedEdges) {
              edge.classList.remove('active');
              const showOldTraversal = false;
              if (showOldTraversal) {
                  // shows that the edge was traversed. Optional, but kinda nice.
                  edge.style.stroke = 'green';
              }
            }
            highlightedEdges.clear();
        }

        // Function to update event button states (availability and visibility)
        function updateEventButtonStates(currentStateName) {
            const availableEvents = stateEventsMapping[currentStateName] || [];

            diagramEventNamesArray.forEach(eventName => {
                const button = document.getElementById('button_' + eventName);
                if (button) {
                    const hasEventHandler = availableEvents.includes(eventName);

                    let title = `Dispatch event '${eventName}' to the state machine.`;

                    if (hasEventHandler) {
                        button.classList.remove('hasNoEventHandler');
                    } else {
                        button.classList.add('hasNoEventHandler');
                        title += '\nThere is no handler for this event in the current state.\nDispatching is valid, but will have no effect on the state machine.';
                    }

                    title += '\nThere is a âš™ï¸ setting to disable these tooltips.';

                    const showTooltips = document.getElementById('savedSetting_showEventButtonTooltips').checked
                    if (showTooltips) {
                        button.title = title;
                    } else {
                        button.removeAttribute('title');
                    }
                }
            });
            
            // Update visibility based on checkbox state
            updateButtonVisibility();
        }

        // Function to update button visibility based on Hide Unused checkbox
        function updateButtonVisibility() {
            const hideIrrelevantEvents = document.getElementById('savedSetting_hideIrrelevantEvents').checked;
            
            diagramEventNamesArray.forEach(eventName => {
                const button = document.getElementById('button_' + eventName);
                if (button) {
                    // Toggle hidden class based on checkbox state and button has no event handler
                    button.classList.toggle('hidden', hideIrrelevantEvents && button.classList.contains('hasNoEventHandler'));
                }
            });
        }

        // The simulator uses a tracer callback to perform operations such as 
        // state highlighting and logging.
        sm.tracer = {
            enterState: (mermaidName) => {
                var e = document.querySelector('g[data-id=' + mermaidName + ']');
                if(e) {
                  e.classList.add('active');
                  panOnScreen(e);
                }

                if (document.getElementById('savedSetting_verboseEnter').checked) {
                    sm.tracer.log('âž¡ï¸ Entered ' + mermaidName);
                }
                
                // Update event button states
                updateEventButtonStates(mermaidName);
            },
            exitState: (mermaidName) => {
                document.querySelector('g[data-id=' + mermaidName + ']')?.classList.remove('active');

                if (document.getElementById('savedSetting_verboseExit').checked) {
                    sm.tracer.log('â†©ï¸ Exited ' + mermaidName);
                }
            },
            edgeTransition: (edgeId) => {
                highlightEdge(edgeId);
            },
            logHistoryVarUpdate: (varName, newValue) => {
                if (document.getElementById('savedSetting_verboseHistory').checked) {
                    sm.tracer.log(`ðŸ•‘ HistoryVar(${varName}) = ${newValue}`);
                }
            },
            logHistoryTransition: (description) => {
                sm.tracer.log(`ðŸ•‘ History: ${description}.`);
            },
            logGuardCodeEvaluation: (guardCode) => {
                sm.tracer.log(`ðŸ›¡ï¸ User evaluating guard: ${guardCode}`);
            },
            logActionCode: (actionCode) => {
                sm.tracer.log(`âš¡ FSM would execute action: ${actionCode}`);
            },
            log: (message, html=false) => {
                addEventLogRow(new Date(), message, html);
            }
        };

        // Wire up the buttons that dispatch events for the state machine.
        diagramEventNamesArray.forEach(diagramEventName => {
            var button = document.createElement('button');
            button.id = 'button_' + diagramEventName;
            button.className = 'event-button';
            button.innerText = diagramEventName;
            button.addEventListener('click', () => {

                // allow dispatching events even if they have no handler in current state to aid in learning
                // https://github.com/StateSmith/StateSmith/issues/497
                const alwaysAllowEventDispatch = true;

                if (alwaysAllowEventDispatch || !button.classList.contains('hasNoEventHandler')) {
                    clearHighlightedEdges();
                    sm.tracer?.log('<span class=\'dispatched\'><span class=\'event-id\'>' + diagramEventName + '</span> DISPATCHED</span>', true);
                    const fsmEventName = diagramEventName.toUpperCase();
                    sm.dispatchEvent(PlantEx1.EventId[fsmEventName]); 
                }
            });
            document.getElementById(`buttons`).appendChild(button);
        });

        sm.tracer?.log(`<span class='dispatched'>START</span>`, true);
        sm.start(); // This will cause `updateEventButtonStates()` to be called.

        function panOnScreen(element) {
          if(!element) return;

          var bounds = element.getBoundingClientRect();
          if(bounds.x<0 || bounds.y<0) {
              var x = Math.max(0, -bounds.x + 20);
              var y = Math.max(0, -bounds.y + 20);
              window.panZoom.panBy({x: x, y: y});
          }
          var panebounds = document.querySelector('svg').getBoundingClientRect();
          if(bounds.x>panebounds.width || bounds.y>panebounds.height) {
              var x = Math.min(0, panebounds.width - bounds.x - bounds.width - 20);
              var y = Math.min(0, panebounds.height - bounds.y - bounds.height - 20);
              window.panZoom.panBy({x: x, y: y});
          }
        }
    </script>


  </body>
</html>
