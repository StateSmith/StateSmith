using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.CSharp;
using System.Collections.Generic;
using System;
using System.Text;
using StateSmith.Common;
using System.Linq;
using StateSmith.Output.UserConfig;

#nullable enable

// spell-checker: ignore customizer

namespace StateSmith.Output.Gil.C99;

// TODO use a single string for `sm` as replacement for `this`. currently scattered.

public class C99GenVisitor : CSharpSyntaxWalker
{
    public readonly StringBuilder hFileSb;
    public readonly StringBuilder cFileSb;
    public StringBuilder privateSb = new();
    public StringBuilder publicSb = new();
    public StringBuilder sb;
    protected readonly SemanticModel model;
    protected bool renderingPrototypes = false;
    protected readonly IGilToC99Customizer customizer;

    public C99GenVisitor(SemanticModel model, StringBuilder hFileSb, StringBuilder cFileSb, RenderConfigCVars renderConfigC, IGilToC99Customizer customizer) : base(SyntaxWalkerDepth.StructuredTrivia)
    {
        this.model = model;
        sb = hFileSb;
        this.hFileSb = hFileSb;
        this.cFileSb = cFileSb;
        this.customizer = customizer;
        hFileSb.AppendLine("// Autogenerated with StateSmith");
        hFileSb.AppendLineIfNotBlank(renderConfigC.HFileTop);
        hFileSb.AppendLine("#pragma once");
        hFileSb.AppendLine("#include <stdint.h>\n");
        hFileSb.AppendLineIfNotBlank(renderConfigC.HFileIncludes);

        cFileSb.AppendLine("// Autogenerated with StateSmith");
        cFileSb.AppendLineIfNotBlank(renderConfigC.CFileTop);
        cFileSb.AppendLine($"#include \"{customizer.MakeHFileName()}\"");
        cFileSb.AppendLineIfNotBlank(renderConfigC.CFileIncludes);
        cFileSb.AppendLine("#include <stdbool.h> // required for `consume_event` flag");
        cFileSb.AppendLine("#include <string.h> // for memset\n");
    }

    public override void VisitInvocationExpression(InvocationExpressionSyntax node)
    {
        bool done = false;

        done |= GilHelper.HandleGilSpecialInvocations(node, sb);
        done |= GilHelper.HandleGilUnusedVarSpecialInvocation(node, argument =>
        {
            var argName = "sm"; // we only ignore `sm` in ROOT_exit right now so we can cheat here. If that changes, we can visit `argument` instead.
            sb.Append(node.GetLeadingTrivia().ToFullString());
            sb.Append($"(void){argName}");   // trailing semi-colon is already part of parent ExpressionStatement
        });

        if (!done)
        {
            base.VisitInvocationExpression(node);
        }
    }

    // to ignore GIL attributes
    public override void VisitAttributeList(AttributeListSyntax node)
    {
        VisitLeadingTrivia(node.GetFirstToken());
    }

    public override void VisitStructDeclaration(StructDeclarationSyntax node)
    {
        string name = GetCName(node);
        sb = hFileSb;
        sb.AppendLine($"");
        OutputStruct(node, name, outputTypedef: true);
    }

    public override void VisitClassDeclaration(ClassDeclarationSyntax node)
    {
        if (GilHelper.HandleSpecialGilEmitClasses(node, this)) return;

        string name = GetCName(node);
        sb = hFileSb;

        // output enums and constants
        foreach (var kid in node.ChildNodes())
        {
            if (kid is EnumDeclarationSyntax || kid is FieldDeclarationSyntax field && field.IsConst())
                Visit(kid);
        }

        sb = hFileSb;

        // output forward declaration and comment
        sb.AppendLine($"\n");
        OutputAttachedCommentTrivia(node);
        sb.AppendLine($"// forward declaration");
        sb.AppendLine($"typedef struct {name} {name};");

        foreach (var kid in node.ChildNodes().OfType<StructDeclarationSyntax>())
        {
            Visit(kid);
        }

        foreach (var kid in node.ChildNodes().OfType<ClassDeclarationSyntax>())
        {
            Visit(kid);
        }

        sb = hFileSb;
        foreach (var kid in node.ChildNodes().OfType<DelegateDeclarationSyntax>())
        {
            Visit(kid);
        }
        sb.AppendLine();

        publicSb = hFileSb;
        privateSb = cFileSb;
        CaptureFunctionPrototypes(node);

        sb = hFileSb;
        OutputStruct(node, name);

        sb = cFileSb;
        publicSb = cFileSb;
        privateSb = cFileSb;

        foreach (var kid in node.ChildNodes().OfType<ConstructorDeclarationSyntax>())
        {
            Visit(kid);
        }

        foreach (var kid in node.ChildNodes().OfType<MethodDeclarationSyntax>())
        {
            Visit(kid);
        }
    }

    private void OutputStruct(TypeDeclarationSyntax node, string name, bool outputTypedef = false)
    {
        OutputAttachedCommentTrivia(node);
        if (outputTypedef)
            sb.Append("typedef ");

        sb.Append("struct ");
        sb.AppendTokenAndTrivia(node.Identifier, overrideTokenText: name);
        sb.AppendTokenAndTrivia(node.OpenBraceToken);
        sb.AppendLine(PostProcessor.trimBlankLinesMarker);

        foreach (var kid in node.ChildNodes())
        {
            if (kid is FieldDeclarationSyntax field && !field.IsConst())
                Visit(kid);
        }

        sb.AppendLine(PostProcessor.trimBlankLinesMarker);
        VisitLeadingTrivia(node.CloseBraceToken);
        sb.Append('}');
        if (outputTypedef)
            sb.Append($" {name}");
        sb.Append(';');
        VisitTrailingTrivia(node.CloseBraceToken);
        sb.AppendLine();
    }

    private void CaptureFunctionPrototypes(ClassDeclarationSyntax node)
    {
        renderingPrototypes = true;

        List<SyntaxNode> kids = GetMethodsAndConstructors(node);

        foreach (var kid in kids)
        {
            Visit(kid);
            sb.Append(");\n\n");
        }
        renderingPrototypes = false;
    }

    private static List<SyntaxNode> GetMethodsAndConstructors(ClassDeclarationSyntax node)
    {
        List<SyntaxNode> kids = new();
        kids.AddRange(node.ChildNodes().OfType<ConstructorDeclarationSyntax>());
        kids.AddRange(node.ChildNodes().OfType<MethodDeclarationSyntax>().Where(mds => !GilHelper.IsGilNoEmit(mds)));
        return kids;
    }

    // delegates are assumed to be method pointers
    public override void VisitDelegateDeclaration(DelegateDeclarationSyntax node)
    {
        var symbol = model.GetDeclaredSymbol(node).ThrowIfNull();

        AppendNodeLeadingTrivia(node);
        sb.Append("typedef ");
        Visit(node.ReturnType);
        sb.Append("(*");
        sb.Append(GetCName(symbol));
        sb.Append(')');
        sb.Append("(" + GetCName(symbol.ContainingType) + "* sm)");
        //Visit(node.ParameterList);
        VisitToken(node.SemicolonToken);
    }

    public override void VisitConstructorDeclaration(ConstructorDeclarationSyntax node)
    {
        OutputFunctionLeadingTrivia(node);

        sb.Append($"void {node.Identifier.Text}_ctor");

        Visit(node.ParameterList);

        if (!renderingPrototypes)
        {
            var body = node.Body.ThrowIfNull();
            VisitToken(body.OpenBraceToken);
            sb.Append("    memset(sm, 0, sizeof(*sm));\n"); // todo_low - sm should be var so we can use `sm`, `this`, `self`...
            body.VisitChildrenNodesWithWalker(this);
            VisitToken(body.CloseBraceToken);
        }
    }

    private void OutputFunctionLeadingTrivia(SyntaxNode node)
    {
        if (!renderingPrototypes)
        {
            AppendNodeLeadingTrivia(node);
        }
        else
        {
            OutputAttachedCommentTrivia(node);
        }
    }

    private void OutputAttachedCommentTrivia(SyntaxNode node)
    {
        // Only output attached comments. If we find 2 or more end of line trivia without a comment trivia,
        // clear any stored trivia.
        List<SyntaxTrivia> toOutput = new();

        int endOfLineCount = 0;
        foreach (var t in node.GetLeadingTrivia())
        {
            bool isComment = t.IsKind(SyntaxKind.SingleLineCommentTrivia)
                          || t.IsKind(SyntaxKind.MultiLineCommentTrivia); // can also look at others like SingleLineDocumentationCommentTrivia

            if (t.IsKind(SyntaxKind.EndOfLineTrivia))
            {
                endOfLineCount++;
                if (endOfLineCount > 1)
                    toOutput.Clear();
                else if (toOutput.Any()) // append end of line if we already had a comment stored
                    toOutput.Add(t);
            }
            else if (isComment)
            {
                endOfLineCount = 0;
                toOutput.Add(t);
            }
        }

        foreach (var t in toOutput)
        {
            sb.Append(t);
        }
    }

    public override void VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
        sb = node.IsPublic() ? publicSb : privateSb;

        if (GilHelper.IsGilNoEmit(node))
        {
            return;
        }

        OutputFunctionLeadingTrivia(node);

        if (!node.IsPublic())
        {
            sb.Append("static ");
        }

        Visit(node.ReturnType);
        VisitToken(node.Identifier);
        Visit(node.ParameterList);

        if (!renderingPrototypes)
            Visit(node.Body);
    }

    public override void VisitBlock(BlockSyntax node)
    {
        if (renderingPrototypes)
            return;

        base.VisitBlock(node);
    }

    // parameters are declared for methods and constructors
    public override void VisitParameterList(ParameterListSyntax node)
    {
        ISymbol? symbol = null;

        if (node.Parent is MethodDeclarationSyntax mds)
        {
            symbol = model.GetDeclaredSymbol(mds).ThrowIfNull();
        }
        else if (node.Parent is ConstructorDeclarationSyntax cds)
        {
            symbol = model.GetDeclaredSymbol(cds).ThrowIfNull();
        }

        var list = new WalkableChildSyntaxList(this, node.ChildNodesAndTokens());

        if (renderingPrototypes)
            list.Remove(node.CloseParenToken);

        if (symbol?.IsStatic == false)
        {
            list.VisitUpTo(node.OpenParenToken, including: true);

            sb.Append(GetCName(symbol.ContainingType) + "* sm");
            if (node.Parameters.Count > 0)
            {
                sb.Append(", ");
            }
        }

        list.VisitRest();
    }

    // arguments are passed to methods/constructors
    public override void VisitArgumentList(ArgumentListSyntax node)
    {
        var invocation = (InvocationExpressionSyntax)node.Parent.ThrowIfNull();
        var iMethodSymbol = (IMethodSymbol)model.GetSymbolInfo(invocation).ThrowIfNull().Symbol.ThrowIfNull();

        if (!iMethodSymbol.IsStatic)
        {
            var list = new WalkableChildSyntaxList(this, node.ChildNodesAndTokens());
            list.VisitUpTo(node.OpenParenToken, including: true);

            sb.Append("sm");
            if (node.Arguments.Count > 0)
            {
                sb.Append(", ");
            }

            list.VisitRest();
        }
        else
        {
            base.VisitArgumentList(node);
        }
    }

    public override void VisitParameter(ParameterSyntax node)
    {
        var parameterSymbol = model.GetDeclaredSymbol(node);

        if (parameterSymbol != null && parameterSymbol.Type.IsReferenceType && parameterSymbol.Type.BaseType?.Name != nameof(System.MulticastDelegate))
        {
            Visit(node.Type);
            sb.Append(PostProcessor.trimHorizontalWhiteSpaceMarker); // converts `ROOT_enter(Spec1Sm * sm);` to `ROOT_enter(Spec1Sm* sm);`
            sb.Append("* ");
            VisitToken(node.Identifier);
        }
        else
        {
            base.VisitParameter(node);
        }
    }

    // <Expression> <OperatorToken> <Name>
    // `this.stuff` this == Expression. stuff == Name.
    public override void VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
    {
        bool done = false;

        if (ExpressionIsEnumMember(node.Expression))
        {
            // used for enum access: `MyEnumClass.EnumName`
            Visit(node.Name);
            done = true;
        }
        else
        {
            bool isPtr = false;

            if (node.IsKind(SyntaxKind.SimpleMemberAccessExpression))
            {
                // `this.stuff` to `sm->stuff`
                if (node.Expression is ThisExpressionSyntax tes)
                {
                    VisitLeadingTrivia(tes.Token);
                    sb.Append("sm");
                    VisitTrailingTrivia(tes.Token);
                    isPtr = true;
                }
                // `sm.stuff` to `sm->stuff`
                else if (node.Expression is IdentifierNameSyntax identifierNameSyntax)
                {
                    ISymbol? symbol = model.GetSymbolInfo(identifierNameSyntax).Symbol;

                    if (symbol is IParameterSymbol parameterSymbol && parameterSymbol.Type.IsReferenceType)
                    {
                        Visit(identifierNameSyntax);
                        isPtr = true;
                    }
                }
                else
                {
                    Visit(node.Expression);
                }

                if (isPtr)
                {
                    sb.Append("->");
                    VisitTrailingTrivia(node.OperatorToken);
                }
                else
                {
                    VisitToken(node.OperatorToken);
                }

                Visit(node.Name);
                done = true;
            }
        }

        if (!done)
            base.VisitMemberAccessExpression(node);
    }

    public override void VisitNullableType(NullableTypeSyntax node)
    {
        // converts `Func? behavior_func` to `Func behavior_func`
        Visit(node.ElementType);
        VisitLeadingTrivia(node.QuestionToken);
        VisitTrailingTrivia(node.QuestionToken);
    }

    private bool ExpressionIsEnumMember(ExpressionSyntax expressionSyntax)
    {
        ISymbol? symbol = model.GetSymbolInfo(expressionSyntax).Symbol;

        if (symbol == null)
            return false;

        if (symbol is IParameterSymbol ps && ps.Type.TypeKind == TypeKind.Enum)
        {
            return true;
        }

        if (symbol is IFieldSymbol f && f.Type.TypeKind == TypeKind.Enum)
        {
            return true;
        }

        if (symbol is INamedTypeSymbol nts && nts.TypeKind == TypeKind.Enum)
        {
            return true;
        }

        return false;
    }

    public override void VisitToken(SyntaxToken token)
    {
        token.LeadingTrivia.VisitWith(this);

        switch ((SyntaxKind)token.RawKind)
        {
            case SyntaxKind.PublicKeyword:
            case SyntaxKind.EnumKeyword:
            case SyntaxKind.StaticKeyword:
            case SyntaxKind.ReadOnlyKeyword:
            case SyntaxKind.PrivateKeyword:
                return;
        }

        if (token.IsKind(SyntaxKind.ExclamationToken) && token.Parent.IsKind(SyntaxKind.SuppressNullableWarningExpression))
        {
            // ignore exclamations like: `this.current_state_exit_handler!();`
        }
        else if (token.IsKind(SyntaxKind.IdentifierToken) && token.Parent is MethodDeclarationSyntax mds)
        {
            sb.Append(GetCName(model.GetDeclaredSymbol(mds).ThrowIfNull()));
        }
        else if (token.IsKind(SyntaxKind.IdentifierToken) && token.Parent is EnumMemberDeclarationSyntax emds)
        {
            sb.Append(GetCName(model.GetDeclaredSymbol(emds).ThrowIfNull()));
        }
        else if (token.IsKind(SyntaxKind.ThisKeyword))
        {
            sb.Append("sm");
        }
        else
        {
            sb.Append(token);
        }

        token.TrailingTrivia.VisitWith(this);
    }

    public override void VisitTrivia(SyntaxTrivia trivia)
    {
        sb.Append(trivia);
    }

    public override void VisitCastExpression(CastExpressionSyntax node)
    {
        if (IsEnumMemberConversionToInt(node))
        {
            // just visit expression so we omit int cast
            // `(int32_t)event_id` ---> `event_id`
            Visit(node.Expression);
        }
        else
        {
            base.VisitCastExpression(node);
        }
    }

    private bool IsEnumMemberConversionToInt(CastExpressionSyntax node)
    {
        if (node.Type is PredefinedTypeSyntax pts && pts.Keyword.IsKind(SyntaxKind.IntKeyword))
        {
            if (ExpressionIsEnumMember(node.Expression))
            {
                return true;
            }
        }

        return false;
    }

    public override void VisitIdentifierName(IdentifierNameSyntax node)
    {
        var result = node.Identifier.Text;

        switch (result)
        {
            case "Boolean": result = "bool"; break;
            case "SByte": result = "int8_t"; break;
            case "Byte": result = "uint8_t"; break;
            case "Int16": result = "int16_t"; break;
            case "UInt16": result = "uint16_t"; break;
            case "Int32": result = "int32_t"; break;
            case "UInt32": result = "uint32_t"; break;
            case "Int64": result = "int64_t"; break;
            case "UInt64": result = "uint64_t"; break;
            case "Double": result = "float"; break;
            case "Single": result = "double"; break;

            default:
                {
                    SymbolInfo symbol = model.GetSymbolInfo(node);
                    result = GetCName(symbol.Symbol.ThrowIfNull());
                    break;
                }
        }

        node.VisitLeadingTriviaWith(this);
        sb.Append(result);
        node.VisitTrailingTriviaWith(this);
    }

    public override void VisitPredefinedType(PredefinedTypeSyntax node)
    {
        string result = node.Keyword.Text switch
        {
            "void" => "void",
            "bool" => "bool",
            "sbyte" => "int8_t",
            "byte" => "uint8_t",
            "short" => "int16_t",
            "ushort" => "uint16_t",
            "int" => "int32_t",
            "uint" => "uint32_t",
            "long" => "int64_t",
            "ulong" => "uint64_t",
            "float" => "float",
            "double" => "double",
            "string" => "char const * const",
            _ => throw new NotImplementedException(node + ""),
        };

        node.VisitLeadingTriviaWith(this);
        sb.Append(result);
        node.VisitTrailingTriviaWith(this);
    }

    public override void VisitLiteralExpression(LiteralExpressionSyntax node)
    {
        // convert `null` to `NULL`
        if (node.IsKind(SyntaxKind.NullLiteralExpression))
        {
            sb.Append("NULL");
        }
        else
        {
            base.VisitLiteralExpression(node);
        }
    }

    public override void VisitVariableDeclaration(VariableDeclarationSyntax node)
    {
        if (node.Type is ArrayTypeSyntax)
        {
            HandleArrayVarDecl(node);
        }
        else
        {
            base.VisitVariableDeclaration(node);
        }
    }

    public override void VisitFieldDeclaration(FieldDeclarationSyntax node)
    {
        bool done = false;
        bool useDefine = false;
        bool useEnum = true;

        if (node.IsConst())
        {
            if (useDefine)
            {
                done = true;
                AppendNodeLeadingTrivia(node);
                sb.Append("#define ");
                var decl = node.Declaration.Variables.Single();
                sb.Append(GetCName(model.GetDeclaredSymbol(decl).ThrowIfNull()));
                sb.Append(' ');
                Visit(decl.Initializer.ThrowIfNull().Value);
                sb.Append('\n');
            }
            else if (useEnum)
            {
                done = true;
                AppendNodeLeadingTrivia(node);
                sb.Append("enum\n{\n    ");
                Visit(node.Declaration.Variables.Single());
                sb.Append("\n};\n");
            }
        }

        if (!done)
        {
            base.VisitFieldDeclaration(node);
        }
    }

    public override void VisitVariableDeclarator(VariableDeclaratorSyntax node)
    {
        if (node.FirstAncestorOrSelf<FieldDeclarationSyntax>().IsConst())
        {
            sb.Append(GetCName(model.GetDeclaredSymbol(node).ThrowIfNull()));
            VisitTrailingTrivia(node.Identifier);
        }
        else
        {
            VisitToken(node.Identifier);
        }

        if (node.Initializer?.Value is ObjectCreationExpressionSyntax)
        {
            sb.Append(PostProcessor.trimHorizontalWhiteSpaceMarker);
        }
        else
        {
            Visit(node.Initializer);
        }
    }

    private void HandleArrayVarDecl(VariableDeclarationSyntax node)
    {
        var ats = (ArrayTypeSyntax)node.Type;
        Visit(ats.ElementType);
        sb.Append(' ');

        foreach (VariableDeclaratorSyntax v in node.Variables)
        {
            sb.Append(v.Identifier);

            var rank = v.DescendantNodes().OfType<ArrayRankSpecifierSyntax>().SingleOrDefault();
            if (rank != null)
                Visit(rank);
        }
    }

    public override void VisitEnumDeclaration(EnumDeclarationSyntax node)
    {
        AppendNodeLeadingTrivia(node);
        string name = GetCName(node);

        sb.AppendTokenAndTrivia(node.Identifier, overrideTokenText: customizer.MakeEnumDeclaration(name));
        sb.AppendTokenAndTrivia(node.OpenBraceToken);

        foreach (var kid in node.ChildNodesAndTokens().SkipWhile(n => n.IsToken))
        {
            if (kid.IsNode)
            {
                Visit(kid.AsNode());
            }
            else
            {
                if (kid == node.CloseBraceToken)
                    break;
                VisitToken(kid.AsToken());
            }
        }

        VisitLeadingTrivia(node.CloseBraceToken);
        sb.Append($"}} {name};");
        VisitTrailingTrivia(node.CloseBraceToken);
    }

    private void AppendNodeLeadingTrivia(SyntaxNode node)
    {
        sb.Append($"{node.GetLeadingTrivia()}");
    }

    private static string GetFQN(ISymbol symbol)
    {
        var parts = new List<string>();

        parts.Insert(index: 0, symbol.Name);
        symbol = symbol.ContainingSymbol;

        while (symbol != null)
        {
            if (symbol is INamespaceSymbol namespaceSymbol)
            {
                // need to stop at global namespace to prevent ascending into dll
                if (namespaceSymbol.IsGlobalNamespace)
                {
                    break;
                }
            }

            if (symbol is not IMethodSymbol)
                parts.Insert(index: 0, symbol.Name);

            symbol = symbol.ContainingSymbol;
        }

        var fqn = string.Join(".", parts);
        return fqn;
    }

    private static string MangleTypeSymbolName(string fullyQualifiedName)
    {
        string textName = fullyQualifiedName.Replace(oldChar: '.', newChar: '_');
        return textName;
    }

    private string GetCName(ClassDeclarationSyntax node)
    {
        INamedTypeSymbol symbol = model.GetDeclaredSymbol(node).ThrowIfNull();
        return GetCName(symbol);
    }

    private string GetCName(StructDeclarationSyntax node)
    {
        INamedTypeSymbol symbol = model.GetDeclaredSymbol(node).ThrowIfNull();
        return GetCName(symbol);
    }

    private string GetCName(EnumDeclarationSyntax node)
    {
        INamedTypeSymbol symbol = model.GetDeclaredSymbol(node).ThrowIfNull();
        return GetCName(symbol);
    }

    private static string GetCName(ISymbol symbol)
    {
        if (symbol is IFieldSymbol fieldSymbol)
        {
            if (!fieldSymbol.IsStatic && !fieldSymbol.IsConst)
            {
                return fieldSymbol.Name;
            }
        }

        if (symbol.Kind == SymbolKind.Parameter || symbol.Kind == SymbolKind.Local)
        {
            return symbol.Name;
        }

        if (symbol is IMethodSymbol methodSymbol && methodSymbol.DeclaredAccessibility != Accessibility.Public)
        {
            return methodSymbol.Name;
        }

        var fqn = GetFQN(symbol);
        var name = MangleTypeSymbolName(fqn);
        return name;
    }

    private static string GetCName(SymbolInfo symbolInfo)
    {
        return GetCName(symbolInfo.Symbol.ThrowIfNull());
    }
}
